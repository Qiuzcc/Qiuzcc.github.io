<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>牛客算法刷题记录</title>
    <link href="/2022/05/27/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/05/27/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一、链表"><a href="#一、链表" class="headerlink" title="一、链表"></a>一、链表</h3><p><strong>题单：</strong>模板速刷TOP101</p><table><thead><tr><th>题目</th><th>描述</th></tr></thead><tbody><tr><td><strong>BM1</strong> <strong>反转链表</strong></td><td>反转整个链表，错误教训：当链头变为链尾时，一定要将链头的next指向NULL</td></tr><tr><td><strong>BM2</strong> <strong>链表内指定区间反转</strong></td><td>巧妙利用“前哨”节点，让链头永远不变，避免分情况讨论的麻烦。巧妙利用一个temp指针，在区间内转换指针方向</td></tr><tr><td><strong>BM3</strong> <strong>链表中的节点每k个一组翻转</strong></td><td>BM2的反转方法巧妙高效，但不适用于这题，因为它的使用建立在反转区间在链表长度范围内的条件上。但是这题要求，最后长度不足k的区间，保持原样。所以这就要求需要先遍历链表，获取到长度为k的区间进行反转，长度不足k的区间不做改动。</td></tr><tr><td><strong>合并两个排序的链表</strong></td><td>“前哨”，递归做法和迭代做法</td></tr><tr><td><strong>合并k个已排序的链表</strong></td><td>递归分治，优先队列两种做法</td></tr><tr><td><strong>BM6</strong> <strong>判断链表中是否有环</strong></td><td>快慢指针，如果链表有环，那么环一定出现在链尾，也就意味着链表没有NULL，只要设置一快一满两个指针，就一定会相遇（快的每次走两步，满的每次走一步）</td></tr><tr><td><strong>BM7</strong> <strong>链表中环的入口结点</strong></td><td>BM6的进阶，首先判断链表是否有环。如果有环，首先了解一个特点，快指针走的步数是慢指针的两倍。<br />假设链头到环入口的距离为x，环入口距离相遇点的距离为y，相遇点向后到环入口的距离为z，<br />且假设快指针在环里转了a圈，慢指针在环里转了b圈。那么就有 x+y+a(y+z) &#x3D; 2[x+y+b(y+z)]，<br />整理一下得到：(a-2b)(y+z)&#x3D;x+y，代表的含义是：从相遇点出发，一个指针在环里转若干圈，<br />另一个指针从头开始，最终会在原来的相遇点再次相遇；那么在相遇之前，从环入口到相遇点这段路程两个指针是重叠的，由此可以得出两个指针第一个重叠的地方就是环入口。</td></tr><tr><td><strong>BM8</strong> <strong>链表中倒数最后k个结点</strong></td><td>双指针，前后指针，间隔k步</td></tr><tr><td><strong>BM9</strong> <strong>删除链表的倒数第n个节点</strong></td><td>双指针，前后指针，“前哨”结点是处理很多链表问题的很好的技巧</td></tr><tr><td><strong>BM10</strong> <strong>两个链表的第一个公共结点</strong></td><td>双指针，获取链表长度，长的先走，让两条链距离公共点的起点相同</td></tr><tr><td><strong>BM11</strong> <strong>链表相加(二)</strong></td><td>反转链表 + 模拟加法 + 反转链表</td></tr><tr><td><strong>BM12</strong> <strong>单链表的排序</strong></td><td>BM4合并两个有序链表，链表的归并排序，左边界是链表起点，右边界是NULL<br /><strong>递归三要素：终止条件、返回值、本级任务</strong></td></tr><tr><td><strong>BM13</strong> <strong>判断一个链表是否为回文结构</strong></td><td>抓住关键：前序和后序一致即为回文，可以用头插法new一个逆序链表，可以用栈，可以保存到数组中用前后对撞指针</td></tr><tr><td><strong>BM14</strong> <strong>链表的奇偶重排</strong></td><td>一共就两种情况，奇数个节点或者偶数个节点，只要把两种情况的处理方式综合考虑进来，理清逻辑，就很容易解决了。</td></tr><tr><td><strong>BM15</strong> <strong>删除有序链表中重复的元素-I</strong></td><td>前后指针pre和cur</td></tr><tr><td><strong>BM16</strong> <strong>删除有序链表中重复的元素-II</strong></td><td>与BM15相比，难度提升在于，BM15保留了一个重复元素，而这里要把所有都删除，所以需要增加一个指针记录重复元素前一位的元素，用了三个指针pre、cur和nex，函数体里面分为两部分，一个是删除部分，与之对立的是指针前进部分<br />拓展：如果链表是无序的，则使用哈希表map，统计每个节点值出现的次数</td></tr></tbody></table><p><strong>小结</strong></p><ul><li>链表主要考察点有：一、对链表指针的修改，如反转、删除、合并、分离等等。二、对链表性质的考察，如判断链表是否有环、寻找链表环入口、寻找链表之间的公共节点等等。</li><li>链表题中常用的技巧有：双指针、前哨节点</li><li>双指针，又可以分为：快慢指针、前后指针、两条链各一个指针。指针的方向可以是同向间隔k步，同向速度不同、反向</li><li>前哨节点，涉及到链头可能变动时，增加前哨节点可以减少讨论的情况</li></ul><h3 id="二、二分查找-x2F-排序"><a href="#二、二分查找-x2F-排序" class="headerlink" title="二、二分查找&#x2F;排序"></a>二、二分查找&#x2F;排序</h3><p><strong>牛客TOP101</strong></p><table><thead><tr><th>题目</th><th>描述</th></tr></thead><tbody><tr><td><strong>BM17</strong> <strong>二分查找-I</strong></td><td></td></tr><tr><td><strong>BM18</strong> <strong>二维数组中的查找</strong></td><td>一开始注意到了：左上角最小、右下角最大的规律，但是思路陷入了误区，以为要想BM17一样不断通过二分划分新的象限区间，在新的象限里面进行寻找（这样做，坐标计算非常棘手）。<br />但是没有注意到：上方 &lt; 左下角 &lt; 右方 这个特点，利用这个特点，加上以左下角为起点，可以实现<br />二分查找，如果target比当前大，就往右平移；如果target比当前小，就往上平移。结束条件是越过上或右边界</td></tr><tr><td><strong>BM19</strong> <strong>寻找峰值</strong></td><td>利用二分，找波峰。二分向左还是向右的判断条件是mid和mid+1的大小比较</td></tr><tr><td><strong>BM20</strong> <strong>数组中的逆序对</strong></td><td>归并排序统计法，归并排序分为（递归）划分和合并两个步骤，在向上合并的过程中，如果右数组元素比左数组剩余元素小，那么左数组剩余的元素个数就是逆序对的数量。在合并的过程中不断把这个数量累加起来，就得到最终结果</td></tr><tr><td><strong>BM21</strong> <strong>旋转数组的最小数字</strong></td><td>旋转数组在旋转前可以视为AB两段，旋转后为BA（A可能为空数组）。那么在B段和A段中，元素都是升序的<br />取数组中点元素，如果中点 &gt; 右边界，说明中点处于B段，此时最小值在A段，左边界向右移动 L &#x3D; mid+1<br />如果中点 &lt; 右边界，说明此时中点处于A段，最小值可能在中点左边，也可能中点就是最小值，所以右边界左移但包含中点，R&#x3D;mid<br />如果中点 &#x3D; 右边界， 此时中点既可能在A段、也可能在B段，所以需要让右边界左移，继续观察</td></tr><tr><td><strong>BM22</strong> <strong>比较版本号</strong></td><td>这题算到二分有点牵强，唯一的“二”体现在用了双指针，就是两个字符串各一个索引指针。<br />通过将.与.之间的字符串转换为数字进行比较</td></tr></tbody></table><ul><li>二分判断的条件有：指定target值与mid值比较、mid值与相邻的mid+1值比较、mid值与right值比较</li></ul><h3 id="三、二叉树"><a href="#三、二叉树" class="headerlink" title="三、二叉树"></a>三、二叉树</h3><table><thead><tr><th>题目</th><th>描述</th></tr></thead><tbody><tr><td><strong>BM23</strong> <strong>二叉树的前序遍历</strong></td><td>递归思路（简单）：终止条件：指针为空，返回值：无，本级任务：取值加入数组、遍历左子树、遍历右子树。<br />非递归思路（栈）</td></tr><tr><td><strong>BM24</strong> <strong>二叉树的中序遍历</strong></td><td>递归思路（简单）<br />非递归（栈），比前序麻烦，做的不对会陷入“重复进入子树”的困境</td></tr><tr><td><strong>BM25</strong> <strong>二叉树的后序遍历</strong></td><td>递归思路（简单）<br />非递归（栈），比中序麻烦，需要判断右子树有没有被访问过才能决定是否读取根</td></tr><tr><td><strong>BM26</strong> <strong>求二叉树的层序遍历</strong></td><td>方法一：借助队列，两层循环，外循环遍历树的层；内循环遍历当前层的所有节点。<br />利用queue.size()来获知当前层节点的个数，然后通过for循环遍历<br />方法二：递归，可以利用前中后序任意一种遍历，在递归遍历时增加一个参数记录当前深度，然后将节点加到对应深度所在的vector中，需要特别注意vector&lt;vector<int>&gt; 的初始化</td></tr><tr><td><strong>BM27</strong> <strong>按之字形顺序打印二叉树</strong></td><td>与BM26一样的思路，增加一个间隔逆序的操作</td></tr><tr><td></td><td></td></tr><tr><td><strong>BM28</strong> <strong>二叉树的最大深度</strong></td><td>递归<br />非递归（队列），层序遍历</td></tr><tr><td><strong>BM29</strong> <strong>二叉树中和为某一值的路径(一)</strong></td><td>递归，有两个终止条件，一个是节点为空，终止；另一个是节点为子节点，而且路径和刚好满足要求。<br />两个条件分别对应返回值false和true。本级任务是向左右子树递归且把sum值减去当前节点值</td></tr><tr><td><strong>BM30</strong> <strong>二叉搜索树与双向链表</strong></td><td>二叉搜索树的中序遍历，即为顺序链表，所以只需要在中序遍历的过程中建立新的左右指针即可</td></tr><tr><td><strong>BM31</strong> <strong>对称的二叉树</strong></td><td>问题：<strong>如何才能将递归返回的所有bool值并在一起？</strong>，这题需要用两个递归，<br />分别比较 子树根1的左子节点 &#x3D;&#x3D; 子树根2的右子节点  &amp;&amp; 子树根1的右子节点 &#x3D;&#x3D; 子树根2的左子节点</td></tr><tr><td></td><td></td></tr><tr><td><strong>BM32</strong> <strong>合并二叉树</strong></td><td>递归做法<br />非递归做法（栈）：维护两个栈，分别保存两棵树的指针（同步保存对应的指针）<strong>需要回顾</strong></td></tr><tr><td><strong>BM33</strong> <strong>二叉树的镜像</strong></td><td>调换左右子树   <strong>回顾一下官方题解，自己写的递归不够规范优雅</strong></td></tr><tr><td><strong>BM34 判断是不是二叉搜索树</strong></td><td>非递归中序遍历的过程中，增加前后值大小的判断<br />递归做法，<strong>麻烦在于递归返回的处理，递归过程中间返回的false不能被后面的返回值覆盖，需要特别注意</strong></td></tr><tr><td></td><td></td></tr><tr><td><strong>BM35</strong> <strong>判断是不是完全二叉树</strong></td><td>层序遍历，一开始把条件想复杂了，其实条件很简单，就是如果访问过NULL之后，还有节点没访问，那就不是完全二叉树。情况归纳做的不好</td></tr><tr><td><strong>BM36</strong> <strong>判断是不是平衡二叉树</strong></td><td>需要理解递归的本质，以及技巧（递归、回溯、剪枝、空间换时间）</td></tr><tr><td><strong>BM37</strong> <strong>二叉搜索树的最近公共祖先</strong></td><td>类似于<strong>BM7</strong> 链表中环的入口结点，根据二叉搜索树的性质分别获得p和q的搜索路径，然后比较两条搜索路径的相同元素</td></tr><tr><td></td><td></td></tr><tr><td><strong>BM40</strong> <strong>重建二叉树</strong></td><td>根据前序序列和中序序列还原二叉树，利用前序确定下一个元素，利用中序确定左右子树元素，递归</td></tr><tr><td><strong>BM39</strong> <strong>序列化二叉树</strong></td><td>知识点一：<strong>string转char</strong><em>（见下例）<br />知识点二：*<em>int转string</em></em><br />知识点三：<strong>char转int</strong><br />知识点四：<strong>C++指针</strong><br />前序遍历（递归）</td></tr><tr><td><strong>BM41</strong> <strong>输出二叉树的右视图</strong></td><td>我的做法：前序+中序，重建二叉树；层序遍历二叉树，每层的最后一个节点加入结果数组</td></tr></tbody></table><ul><li>recursion，递归</li><li>traverse，穿过</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//string转char*</span><br>string res;<br><span class="hljs-type">char</span>* charRes = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[res.<span class="hljs-built_in">length</span>()+<span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy</span>(charRes,res.<span class="hljs-built_in">c_str</span>());<br>charRes[res.<span class="hljs-built_in">length</span>()]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br><br><span class="hljs-comment">//int转string</span><br><span class="hljs-type">int</span> x = <span class="hljs-number">12</span>;<br>strring temp = <span class="hljs-built_in">to_string</span>(x);<br><br><span class="hljs-comment">//char转int</span><br><span class="hljs-type">char</span> c=<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> val = c-<span class="hljs-string">&#x27;0&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="四、栈、队列、堆"><a href="#四、栈、队列、堆" class="headerlink" title="四、栈、队列、堆"></a>四、栈、队列、堆</h3><table><thead><tr><th>题目</th><th>描述</th></tr></thead><tbody><tr><td><strong>BM45</strong> <strong>滑动窗口的最大值</strong></td><td>知识点一：双端队列（实现单调队列）<br />知识点二：双指针</td></tr><tr><td><strong>BM46</strong> <strong>最小的K个数</strong></td><td>解法一：堆（优先队列）<br />解法二：排序<br />解法三：<strong>快排改编（快排很不熟悉）</strong></td></tr><tr><td><strong>BM47</strong> <strong>寻找第K大</strong></td><td>依然卡在快排上</td></tr><tr><td><strong>BM48</strong> <strong>数据流中的中位数</strong></td><td>做法一：插入排序，C++自带的lower_bound()函数和vector的insert函数<br />做法二：维护两个堆（最大堆和最小堆）</td></tr><tr><td><strong>BM49</strong> <strong>表达式求值</strong></td><td>算术优先级的处理</td></tr></tbody></table><p><strong>算术运算符的优先数</strong></p><table><thead><tr><th>操作服op</th><th>#</th><th>(</th><th>*,&#x2F;,%</th><th>+.-</th><th>)</th></tr></thead><tbody><tr><td>isp（栈内优先数）</td><td>0</td><td>1</td><td>5</td><td>3</td><td>6</td></tr><tr><td>icp（栈外优先数）</td><td>0</td><td>6</td><td>4</td><td>2</td><td>1</td></tr></tbody></table><p>处理方式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">字符表达式后面加#，Ops栈底放#，Nums栈放数字<br><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">(Ops栈不空)</span></span><br>    数字，入栈<br>    <span class="hljs-built_in">icp</span>(ch) &gt; <span class="hljs-built_in">isp</span>(op) ch进栈，读入下一个字符<br>    <span class="hljs-built_in">icp</span>(ch) &lt; <span class="hljs-built_in">isp</span>(op) op退栈，num退栈两次，获得两个数，计算，结果入栈<br>    <span class="hljs-built_in">icp</span>(ch) == <span class="hljs-built_in">isp</span>(op) op退栈，如果是<span class="hljs-string">&#x27;(&#x27;</span>就读入下一个字符<br>return Nums<span class="hljs-selector-class">.top</span>()<br></code></pre></td></tr></table></figure><p><strong>最大堆、最小堆的定义方式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt; q;<span class="hljs-comment">//最小顶堆</span><br>priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,less&lt;<span class="hljs-type">int</span>&gt; &gt;q;<span class="hljs-comment">//最大顶堆</span><br></code></pre></td></tr></table></figure><p><strong>二分查找函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">lower_bound</span>(起始指针，终止指针，查找值)<span class="hljs-comment">//返回大于或等于目标值的第一个位置</span><br><span class="hljs-built_in">upper_bound</span>()<span class="hljs-comment">//返回大于目标值的第一个位置</span><br><span class="hljs-built_in">binary_search</span>()<span class="hljs-comment">//若目标值存在则返回true，否则返回false</span><br>    <br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(pos,elem)</span><span class="hljs-comment">//在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。</span></span><br></code></pre></td></tr></table></figure><p><strong>快排的多种做法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(L&lt;R)&#123;<br>        <span class="hljs-type">int</span> mid = <span class="hljs-built_in">partition</span>(A,L,R);<span class="hljs-comment">//分割左右区间</span><br>        <span class="hljs-built_in">QuickSort</span>(A,L,mid);<span class="hljs-comment">//采取右边界不能访问，即左开右闭的区间 [L,R)</span><br>        <span class="hljs-built_in">QuickSort</span>(A,mid+<span class="hljs-number">1</span>,R);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//众多方法的区别就体现在如何划分左右区间上面</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<span class="hljs-comment">//版本一，对向双指针</span><br>    <span class="hljs-type">int</span> pivot = A[L];<span class="hljs-comment">//支点的选择也有很多策略，复杂情况下选择居中的元素时间效率更高</span><br>    <span class="hljs-type">int</span> left=L,right=R<span class="hljs-number">-1</span>;<span class="hljs-comment">//这里R是边界值，不可取</span><br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; A[right]&gt;=pivot)&#123;right--;&#125;<br>        A[left] = A[right];<br>        <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; A[left]&lt;=pivot)&#123;left++;&#125;<br>        A[right] = A[left];<br>    &#125;<br>    A[left] = pivot;<span class="hljs-comment">//while结束后，left==right，所以这里取left和right都一样</span><br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<span class="hljs-comment">//版本二，同向双指针</span><br>    <span class="hljs-type">int</span> pivot = A[L];<br>    <span class="hljs-type">int</span> i=L;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=L+<span class="hljs-number">1</span>;j&lt;R;j++)&#123;<br>        <span class="hljs-keyword">if</span>(A[j]&lt;pivot)&#123;<br>            <span class="hljs-built_in">swap</span>(A[i++],A[j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span></span>&#123;<span class="hljs-comment">//版本三，选择居中支点</span><br>    <span class="hljs-type">int</span> t = (L+R)/<span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> pivot = A[t];<br>    <span class="hljs-built_in">swap</span>(A[L],A[t]);<br>    <br>    <span class="hljs-comment">//后面的步骤一样</span><br>    <span class="hljs-type">int</span> left=L,right=R<span class="hljs-number">-1</span>;<span class="hljs-comment">//这里R是边界值，不可取</span><br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; A[right]&gt;=pivot)&#123;right--;&#125;<br>        A[left] = A[right];<br>        <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; A[left]&lt;=pivot)&#123;left++;&#125;<br>        A[right] = A[left];<br>    &#125;<br>    A[left] = pivot;<span class="hljs-comment">//while结束后，left==right，所以这里取left和right都一样</span><br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五、哈希"><a href="#五、哈希" class="headerlink" title="五、哈希"></a>五、哈希</h3><table><thead><tr><th>题目</th><th>描述</th></tr></thead><tbody><tr><td><strong>BM50</strong> <strong>两数之和</strong></td><td>遍历数组，判断（目标值 - 当前值）是否在哈希表中，不在则将当前值和下标加入哈希表。unordered_map</td></tr><tr><td><strong>BM51</strong> <strong>数组中出现次数超过一半的数字</strong></td><td>做法一：哈希表统计出现次数，两次遍历<br />做法二：候选法（最优解），借助cand候选值和count计数器模拟出两两不同相消的操作（巧妙）</td></tr><tr><td><strong>BM52</strong> <strong>数组中只出现一次的两个数字</strong></td><td>做法一：哈希表统计<br />做法二：异或运算（需要熟悉异或运算的性质）</td></tr><tr><td><strong>BM53</strong> <strong>缺失的第一个正整数</strong></td><td>做法一：unordered_set，插入用emplace（效率比insert高），查找用find<br />做法二：<strong>原地哈希</strong>，借用数组的下标作为哈希键</td></tr><tr><td><strong>BM54</strong> <strong>三数之和</strong></td><td>找a+b+c&#x3D;0的组合，排序+（固定单点+双指针）遍历，注意点细节很多（数组为空，元素重复）</td></tr></tbody></table><p><strong>异或运算的性质：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">a⊕b⊕c⊕b⊕<span class="hljs-attribute">c</span>=a<br>0⊕<span class="hljs-attribute">0</span>=0<br>0⊕<span class="hljs-attribute">1</span>=1<br></code></pre></td></tr></table></figure><h3 id="六、递归-x2F-回溯"><a href="#六、递归-x2F-回溯" class="headerlink" title="六、递归&#x2F;回溯"></a>六、递归&#x2F;回溯</h3><table><thead><tr><th>题目</th><th>描述</th></tr></thead><tbody><tr><td><strong>BM55</strong> <strong>没有重复项数字的全排列</strong></td><td>传统做法，访问标记数组+临时存放数组空间<br />题解做法：递归swap两两交换位置（关键要能够图解过程）</td></tr><tr><td><strong>BM56</strong> <strong>有重复项数字的全排列</strong></td><td>传统做法 + 去重操作：（如果当前的元素num[i]与同一层的前一个元素num[i-1]相同且num[i-1]已经用，也不需要将其纳入，前提：元素有序）<br />i&gt;0 &amp;&amp; initStr[i-1]&#x3D;&#x3D;initStr[i] &amp;&amp; !vis[i-1]</td></tr><tr><td><strong>BM57</strong> <strong>岛屿数量</strong></td><td>深度优先搜索，我的做法：借助标记数组（开辟一个辅助数组）<br />题解做法：深度优先搜索的时候将1修改为0，缺点：改变了原数组</td></tr><tr><td><strong>BM58</strong> <strong>字符串的排列</strong></td><td>字符可能重复，与<strong>BM56</strong>类似，BM56与这里的区别在于BM56是有序序列，而这里的字符串是无序的<br />做法一：是先将字符串排序，然后在排列的过程中避免重复项（与BM56的做法一致）<br />做法二：递归swap两两交换位置，利用set去重，最后set转vector返回</td></tr><tr><td><strong>BM59</strong> <strong>N皇后问题</strong></td><td>递归层数 作为行数（直接满足不同行的条件）；<br />递归内部循环遍历每个可能都列号，判断是否满足不同列、不在同一斜线的条件<br />难点在于同一斜线的判断：这里有两种方法：<br />方法一：<strong>row-col 可以唯一确定正斜线，row+col可以唯一确定反斜线</strong><br />方法二：<strong>当前点（row,col）与之前的所有点（i,j）遍历比较，abs(row-i) &#x3D;&#x3D; abs(col-j)可以判定处于同一斜线</strong><br />可以采用标记集合set（方法一，空间换时间，递归+回溯），也可以写一个判定函数遍历所有点一一比较</td></tr><tr><td><strong>BM60</strong> <strong>括号生成</strong></td><td>与<strong>BM56</strong>类似，初始化一个有序的括号序列，然后按照BM56的思路进行全排列，<br />在排列的过程中对括号进行有效性监视，我在这里采用的方法是借助一个变量记录当前括号序列的累加值<br />遇到左括号，加一；遇到右括号，减一；递归过程如果累加值小于0，说明有多余的）在（前面，<br />跳过当前的序列<br />官方题解的解释：<strong>保证左括号出现的次数比右括号多时我们再使用右括号就一定能保证括号合法了</strong></td></tr><tr><td><strong>BM61</strong> <strong>矩阵最长递增路径</strong></td><td>与<strong>BM57</strong>类似，都是对二维矩阵进行递归深度优先搜索，使用标记数组记录递归过程访问过的节点<br />题解做法：使用dp数组，记录每个节点出发的最长路径（动态规划、空间换时间，可以避免重复的递归）</td></tr></tbody></table><p><strong>递归全排列两种做法：</strong></p><ul><li>传统做法：访问标记数组+临时存放数组空间，适用于各种类型的容器，包括原始的数组int A[]</li><li>swap做法：递归swap两两交换位置，适用于现成的容器具有现成的swap等方法可以直接调用</li></ul><p><strong>递归过程图解：</strong></p><p><img src="/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220519111009.jpg" alt="微信图片_20220519111009"></p><h3 id="七、动态规划"><a href="#七、动态规划" class="headerlink" title="七、动态规划"></a>七、动态规划</h3><table><thead><tr><th>题目</th><th>描述</th></tr></thead><tbody><tr><td><strong>BM62</strong> <strong>斐波那契数列</strong></td><td>做法一：递归+记忆化搜索<br />做法二：动态规划（迭代）</td></tr><tr><td><strong>BM63</strong> <strong>跳台阶</strong></td><td><strong>BM62</strong>的变形<br />A[i] &#x3D; A[i-2] + A[i-1]</td></tr><tr><td><strong>BM64</strong> <strong>最小花费爬楼梯</strong></td><td>动态规划：将问题的解决方案视作一系列决策的结果<br />过程为：确定初始状态，然后执行状态转移。<br />A[i] &#x3D; min (A[i-2]+cost[i-2] , A[i-1]+cost[i-1])</td></tr><tr><td><strong>BM65</strong> <strong>最长公共子序列(二)</strong></td><td>dp矩阵记录最长长度，dir矩阵记录每个点来自的方向<br />状态转移方式：<br />如果str1[i-1] &#x3D;&#x3D; str2[j-1] ，那么dp[i] [j]&#x3D;dp[i-1] [j-1] +1<br />否则，dp[i] [j]&#x3D; max(dp[i-1] [j] , dp[i] [j-1] )</td></tr><tr><td><strong>BM66</strong> <strong>最长公共子串</strong></td><td>与<strong>BM65</strong>类似，维护dp的方式稍有不同<br />如果str1[i-1] !&#x3D; str2[j-1] ， 那么 dp[i] [j] &#x3D;0 <br />因为子串要求必须相邻</td></tr><tr><td><strong>BM67</strong> <strong>不同路径的数目(一)</strong></td><td>F[i] [j] &#x3D; F[i-1] [j] + F[i] [j-1]，左、上边界外层填充0</td></tr><tr><td><strong>BM68</strong> <strong>矩阵的最小路径和</strong></td><td>左、上边界外层填充极大值 INT_MAX<br />初始化dp[1] [1] &#x3D; matrix[0] [0]<br />后续：dp[i] [j] &#x3D; min(dp[i-1] [j], dp[i] [j-1]) + matrix[i-1] [j-1]</td></tr><tr><td><strong>BM69</strong> <strong>把数字翻译成字符串</strong></td><td>一维的dp数组，巧妙的地方，增加了一个值为1的前哨<br />与<strong>BM62</strong>、<strong>BM63</strong>相同的本质，区别在于这里增加了一定的条件</td></tr><tr><td><strong>BM70</strong> <strong>兑换零钱(一)</strong></td><td>动态规划的状态转移方式是从后往前推导出来的，但是计算却是从前往后计算，它需要一个初始状态。<br />两种做法，做法一：暴力枚举+记忆化搜索，好处：修改一下可以获取所有符合条件的组合<br />做法二：动态规划，dp数组初始化为极大值，dp[0] &#x3D; 0; <br />状态转移方程：dp[i] &#x3D; min( dp[i], dp[i-arr[j]]+1) <br />判断是否货币组合是否恰好满足条件：看dp[aim]是否大于aim（大于，就说明dp[aim]没有改变过，没有合适的组合）</td></tr><tr><td><strong>BM71</strong> <strong>最长上升子序列(一)</strong></td><td>将问题拆分成一个个子问题，将序列从长度1一直拆分到完整长度，依次获得每个长度子序列的最长上升子序列<br />双重循环，第一重循环遍历序列的每个长度的子序列，从1到length<br />第二重循环，判断当前子序列最长的上升子序列长度<br />第一重：for(int i&#x3D;0;i&lt;arr.length();i++)  第二重：for(int j&#x3D;0;j&lt;i;j++) <br />判断：if(arr[i]&gt;arr[j] &amp;&amp; dp[j]+1&gt;dp[i])  dp[i] &#x3D; dp[j]+1</td></tr><tr><td><strong>BM72</strong> <strong>连续子数组的最大和</strong></td><td>动态规划，初始化：dp[0] &#x3D; arr[0]<br />状态转移方程： dp[i] &#x3D; max( arr[i] , arr[i]+dp[i-1])，<br />因为数组内存在负数，所以并不是元素越多越好<br />解释：如果当前值加上前面子序列的子数组最大和比原来小，那么对于以当前值为结尾的子序列，当前值就是连续子数组的最大和<br />如果当前值加上前面子序列的子数组最大和比原来大，那么就应该把当前值加入到最大和子数组中，形成新的最大和子数组</td></tr><tr><td><strong>BM73</strong> <strong>最长回文子串</strong></td><td>回文子串的判定：从中间向两边扩展，左右相同就是回文子串（注意：“中间”包含一个字符和<br />两个字符两种情况，即奇数回文子串和偶数回文子串两种情况）<br />遍历字符串的每个字符，分别以每个字符和每两个字符为中心，向两边扩展求回文子串的长度<br />取遍历过程中最大的长度即为结果</td></tr><tr><td><strong>BM74</strong> <strong>数字字符串转化成IP地址</strong></td><td><strong>string转int：stoi(str)    substr(int pos,int length第二个参数不给的话默认截取到尾部)</strong><br />做法一：递归回溯+剪枝，学会一个string类型回溯的技巧：在改变本级string之前，先保存一遍<br />回溯的时候直接赋值回这个保存的临时值就OK了，这是string类型独有的回溯技巧（数组不适用）<br />做法二：迭代枚举</td></tr><tr><td></td><td></td></tr><tr><td><strong>BM75</strong> **编辑距离(一)**（较难）</td><td>dp[i] [j]表示从两个字符串首部各自到str1[i] 和 str2[j]为止的子串需要的编辑距离<br /><strong>初始条件：</strong>假设第一个字符为空，那么字符串一每次增加一个字符，对应dp[0] [j]每次递增一<br />同理，dp[i] [0]每次递增一<br /><strong>状态转移：</strong>如果str1[i]与str2[j]相等，那么dp[i] [j]当前字符不需要改变，等于dp[i-1] [j-1]<br />如果str1[i]和str2[j]不相等，那么最短距离需要在【修改当前字符、删除当前字符、增加新字符】当中选择一个最小值，即dp[i] [j] &#x3D; min(dp[i-1] [j-1], min(dp[i-1] [j], dp[i] [j-1])) + 1<br /><strong>难点：在于理解修改、删除、增加分别对应的dp操作</strong></td></tr><tr><td><strong>BM76</strong> <strong>正则表达式匹配</strong>（较难）</td><td><strong>还是不太理解状态转移到原理</strong><br /></td></tr><tr><td><strong>BM77</strong> <strong>最长的括号子串</strong></td><td>必须通过元素下标计算有效括号的长度！（具体解释写在了牛客BM66的“讨论”里面了）</td></tr><tr><td><strong>BM78</strong> <strong>打家劫舍(一)</strong></td><td>不能偷相邻2家，那么中间可能会跳过1家，也可能为了偷更多钱跳过2家 <br />dp[1] &#x3D; nums[0] 只有一家，那么偷它收益最大<br />dp[i] &#x3D; max(dp[i-1] , dp[i-2]+nums[i-1]) <br />解释：如果偷当前家，那么累计收益为当前家+上上家的累计最大收益；如果不偷当前家，那么累计收益是截止上家的累计最大收益</td></tr><tr><td><strong>BM79</strong> <strong>打家劫舍(二)</strong></td><td>链型数组变成环型数组，第一家和最后一家不能同时偷。<br />所以分两种情况：偷第一家不偷最后一家，不遍历最后一个元素。偷最后一家不偷第一家，不遍历第一个元素</td></tr><tr><td><strong>BM80</strong> <strong>买卖股票的最好时机(一)</strong></td><td>题目：一次交易<br /><strong>贪心做法</strong>：每日价格-前面最小价格。初始化第一个数为最小值，然后遍历，如果当前值比最小值小，更新最小值；如果当前值比最小值大，比较Max和当前值-最小值的大小，维护Max</td></tr><tr><td><strong>BM81</strong> <strong>买卖股票的最好时机(二)</strong></td><td>题目：不限次数交易<br /><strong>贪心做法：</strong>把每段单调增区间的收益加进去</td></tr><tr><td><strong>BM82</strong> <strong>买卖股票的最好时机(三)</strong></td><td>题目：限制两次交易<br />没做</td></tr></tbody></table><p><strong>列举出现过的状态转移方程</strong></p><ul><li>BM72，单个数组连续子串最大值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[i] = <span class="hljs-built_in">max</span>(arr[i] , arr[i]+dp[i<span class="hljs-number">-1</span>] )<br></code></pre></td></tr></table></figure><ul><li>BM66，两个数组的最长公共子串</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(str[i]==str[j]) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span>  dp[i][j]=<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><ul><li>BM65，两个数组的最长公共子序列</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(str[i]==str[j]) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span>  dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]);<br></code></pre></td></tr></table></figure><ul><li>BM71，单个数组的最长上升子序列</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(arr[i]&gt;arr[j] &amp;&amp; dp[j]+<span class="hljs-number">1</span>&gt;dp[i]) dp[i]=dp[j]+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="八、字符串"><a href="#八、字符串" class="headerlink" title="八、字符串"></a>八、字符串</h3><table><thead><tr><th>题目</th><th>描述</th></tr></thead><tbody><tr><td><strong>BM83</strong> <strong>字符串变形</strong></td><td>方法一：分割字符串+栈<br />方法二：双反转（先反转整个字符串，再单独反转单词）</td></tr><tr><td><strong>BM84</strong> <strong>最长公共前缀</strong></td><td>substr(pos,length)</td></tr><tr><td><strong>BM85</strong> <strong>验证IP地址</strong></td><td>IPv4的条件：1.数值方面，数字字符只能在0-9范围、不能有前导0、数值小于等于255、数值个数为4；2.符号方面，点号的个数为3<br />IPv6的条件：1.数值方面，数字字符在0-9或者A-Z或者a-z的范围、数值字符个数小于等于4、数值个数为8；2.符号方面，冒号的个数为7</td></tr><tr><td><strong>BM86</strong> <strong>大数加法</strong></td><td>扩展<br /><strong>知识点一：int转string</strong><br /><strong>知识点二：string转int：</strong>stoi(string)<br /><strong>知识点三：char与int互转</strong><br /><strong>知识点四：char*与string互转</strong></td></tr></tbody></table><ul><li><strong>string转int</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string str=<span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> value = <span class="hljs-built_in">stoi</span>(str);<br><span class="hljs-type">int</span> result = value + <span class="hljs-number">27</span>;<br>cout&lt;&lt;result;<span class="hljs-comment">//150</span><br></code></pre></td></tr></table></figure><ul><li><strong>int转string</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> value = <span class="hljs-number">123</span>;<br>string str = <span class="hljs-string">&quot;456&quot;</span>;<br>str += <span class="hljs-built_in">to_string</span>(value);<br>cout &lt;&lt; str;<span class="hljs-comment">//456123</span><br></code></pre></td></tr></table></figure><ul><li><strong>char和int互转</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*char转int*/</span><br><span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;3&#x27;</span>;<br><span class="hljs-type">int</span> value = ch-<span class="hljs-string">&#x27;0&#x27;</span>;<br>cout&lt;&lt; value +<span class="hljs-number">1</span>;<span class="hljs-comment">//4，如果不-&#x27;0&#x27;，结果是52，因为3对应的ascii码是50</span><br><br><span class="hljs-comment">/*int转char（备注：int只能是个位数，不然就不能转char类型了）*/</span><br><span class="hljs-type">int</span> value = <span class="hljs-number">2</span>;<br><span class="hljs-type">char</span> ch = value + <span class="hljs-string">&#x27;0&#x27;</span>;<br>string str=<span class="hljs-string">&quot;1&quot;</span>;<br>str+=ch;<br>cout&lt;&lt;str;<span class="hljs-comment">//12，如果不转char（不+&#x27;0&#x27;），结果为1，因为ascii值2对应的是一个不显示的字符</span><br></code></pre></td></tr></table></figure><ul><li><strong>string转char</strong>*，使用c_str()方法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">char</span> c[<span class="hljs-number">20</span>];<span class="hljs-comment">//初始化一个char数组空间</span><br>string str = <span class="hljs-string">&quot;12345&quot;</span>;<br><span class="hljs-built_in">strcpy_s</span>(c, str.<span class="hljs-built_in">c_str</span>());<br>cout &lt;&lt; c;<span class="hljs-comment">//12345</span><br></code></pre></td></tr></table></figure><ul><li><strong>char*转string</strong>，直接赋值即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = <span class="hljs-string">&quot;hello&quot;</span>;<br>string str = p;<span class="hljs-comment">//声明和定义不一定需要在一起</span><br>cout &lt;&lt; str;<span class="hljs-comment">//hello</span><br></code></pre></td></tr></table></figure><h3 id="九、双指针"><a href="#九、双指针" class="headerlink" title="九、双指针"></a>九、双指针</h3><table><thead><tr><th>题目</th><th>描述</th></tr></thead><tbody><tr><td><strong>BM87</strong> <strong>合并两个有序的数组</strong></td><td>逆向思考，因为题目要求将结果放置到原数组中，所以为了不覆盖原数组，可以从预计两个数组合并后的末尾开始放置。</td></tr><tr><td><strong>BM88</strong> <strong>判断是否为回文字符串</strong></td><td>做法一：从两端向中间遍历（对向相迎双指针）<br />进阶做法：从中间向两遍遍历，长度分奇数和偶数两种情况</td></tr><tr><td><strong>BM89</strong> <strong>合并区间</strong></td><td><strong>在类里面自定义比较函数，需要加上static关键字</strong></td></tr><tr><td><strong>BM90</strong> <strong>最小覆盖子串</strong></td><td>遍历unordered_map的方法，前后双指针，用map记录覆盖子串的情况<br />用一个函数判断是否覆盖完子串，没有覆盖完，前指针移动扩大窗口范围；覆盖完之后，后指针移动缩小窗口。用另外的left和right记录最小窗口</td></tr><tr><td><strong>BM91 反转字符串</strong></td><td>太过简单</td></tr><tr><td><strong>BM92</strong> <strong>最长无重复子数组</strong></td><td>与<strong>BM89</strong>是同一种题型，滑动动态大小窗口，<br />BM89的特点是：要求覆盖子串，所以需要子串中所有元素都至少出现一次，可以多次，所以适合用map统计频数<br />而这题的特点是：要求不重复，所以子串中的元素出现次数只能少于一次，适合用set判断是否出现过（用map时间复杂度就高了）<br />BM89求最小，所以初始值L和R要取尽可能大。这题求最长，所以初始值L和R要尽可能小<br />两题相同的地方是滑动窗口的过程，不同点在于滑动过程中的比较，BM89是滑动寻找满足条件的情况，这里是滑动到不满足条件为止。L和R都是在满足条件的情况下取的最值</td></tr><tr><td><strong>BM93</strong> <strong>盛水最多的容器</strong></td><td>贪心+双指针，贪心利用了“短板效应”，水桶高度取决于短的那条边，所以每次舍弃短板，寻找更长的板（不一定能找到）</td></tr><tr><td><strong>BM94</strong> <strong>接雨水问题</strong></td><td>做法一：双指针，利用短板效应，最简单容易理解<br />做法二：动态规划，计算出中间每个柱子的两侧最大高度，取最小的那个就是盛水高度<br />做法三：单调栈，依次计算每个V字形区间的盛水量，较麻烦</td></tr></tbody></table><p><strong>遍历unordered_map的方法 :</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = hash.<span class="hljs-built_in">begin</span>(); iter != hash.<span class="hljs-built_in">end</span>(); iter++)&#123;<br>    cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//可以直接用方括号的方式直接赋值，或者修改值</span><br></code></pre></td></tr></table></figure><h3 id="十、贪心算法"><a href="#十、贪心算法" class="headerlink" title="十、贪心算法"></a>十、贪心算法</h3><table><thead><tr><th>题目</th><th>描述</th></tr></thead><tbody><tr><td><strong>BM95</strong> <strong>分糖果问题</strong></td><td>使用辅助数组记录结果，从左往右遍历，<strong>增区间从1开始递增</strong>；<br />从右往左遍历，<strong>增区间从1开始递增</strong>，稍微不同的是这时还需要比较A的值，<br />增区间如果左边糖果已经比右边多了那么不用改变，因为这是从左往右遍历的结果；<br />但如果增区间左边仍然比右边少，那么需要比右边多加一<br /><strong>贪心体现在</strong>：从左往右、从右往左遍历的时候都<strong>从最小的1开始递增</strong></td></tr><tr><td><strong>BM96</strong> <strong>主持人调度（二）</strong></td><td><strong>本题要求</strong>：活动时间有重合，主持所有活动需要多少名主持人<br />做法：step1，将数组按start时间排序；step2，使用辅助数组A，模拟主持人阵容；step3，遍历arr数组，将每场活动的end时间加入到A数组，如果A中有元素的end时间小于等于当前活动的start时间，那么加入到当前A元素；如果当前A中没有元素的end时间小于等于当前活动的start时间，需要新增加一个空间（增加一名主持人）；step4，最后统计A的大小<br /><strong>题目扩展</strong>：活动时间有重合，一个主持人最多能主持多少场活动<br />做法：将arr数组按end时间排序，依次遍历arr，如果当前start大于等于上一个end，结果+1，同时end更新为当前活动的end</td></tr></tbody></table><h3 id="十一、模拟"><a href="#十一、模拟" class="headerlink" title="十一、模拟"></a>十一、模拟</h3><table><thead><tr><th>题目</th><th>描述</th></tr></thead><tbody><tr><td><strong>BM97</strong> <strong>旋转数组</strong></td><td>三次翻转，reverse(start,end)、reverse(start,start+m)、reverse(start+m,end)</td></tr><tr><td><strong>BM98</strong> <strong>螺旋矩阵</strong></td><td>一开始用while，自己给自己找麻烦<br />分别使用left、right、top、bottom记录四个边界<br />所有操作可以分为4步：第1步，上边界从左到右，做完上边界下移；<br />第2步，右边界从上到下，做完右边界左移；<br />第3步，下边界从右到左，做完下边界上移；<br />第4步，左边界从下到上，做完左边界右移。<br />其中每一步做完之后，检查对应边界的情况，比如右边界左移之后，检查左边界是否超过了右边界（重合不算）</td></tr><tr><td><strong>BM99</strong> <strong>顺时针旋转矩阵</strong></td><td>顺时针旋转：[i] [j] &#x3D; [n-1-j] [i]<br />180度旋转：[i] [j] &#x3D; [n-1-i] [n-1-j]<br />逆时针旋转： [i] [j] &#x3D; [j] [n-1-i]<br />倒置转换：先将上三角矩阵和下三角矩阵转置，然后每行倒置，利用矩阵变换的规律</td></tr><tr><td><strong>BM100</strong> <strong>设计LRU缓存结构</strong></td><td>最久未用先删除策略，使用计数器记录每个key距离上次被使用的时间，最长时间没被使用的删除</td></tr><tr><td><strong>BM101</strong> <strong>设计LFU缓存结构</strong></td><td>最少使用最早调用先删除策略<br />做法：使用计数器记录key被调用的次数，使用计时器记录每个key距离上一次调用的时间<br /><strong>细节：</strong>不管是set还是get操作，每一次调用都要让所有key的计时器加一，因为没有注意到这个细节导致了出错</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>算法训练</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git无法连接访问github【解决过程】</title>
    <link href="/2022/05/27/Git/Git%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%AE%BF%E9%97%AEgithub%E3%80%90%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%E3%80%91/"/>
    <url>/2022/05/27/Git/Git%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%AE%BF%E9%97%AEgithub%E3%80%90%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h2 id="Git无法连接访问github"><a href="#Git无法连接访问github" class="headerlink" title="Git无法连接访问github"></a>Git无法连接访问github</h2><h3 id="一、事情背景"><a href="#一、事情背景" class="headerlink" title="一、事情背景"></a>一、事情背景</h3><p>大半个月没有使用github，今天更新技术博客的时候，先是发现之前使用的fluid主题出bug了（无法加载在线js和css资源），费了半天时间重装主题终于搞定fluid主题的bug之后。突然又发现Typora无法上传照片到github了，然后又转过头来解决照片的问题（把图床从github转到了阿里云的OSS数据服务）。然后又花了半天时间重新配置了主题，当最终在本地浏览到效果满意，准备部署到github时，git和github的连接又出问题了（简直心态崩了）。</p><h3 id="二、问题描述"><a href="#二、问题描述" class="headerlink" title="二、问题描述"></a>二、问题描述</h3><p>先是部署的时候，报错（如下）</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">ssh: connect <span class="hljs-built_in">to</span> host github.com port <span class="hljs-number">22</span>: Connection timed out<br>fatal: Could <span class="hljs-keyword">not</span> <span class="hljs-built_in">read</span> <span class="hljs-built_in">from</span> remote repository.<br><br>Please make sure you have <span class="hljs-keyword">the</span> correct access rights<br><span class="hljs-keyword">and</span> <span class="hljs-keyword">the</span> repository exists.<br>......<br></code></pre></td></tr></table></figure><p><img src="/Git%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%AE%BF%E9%97%AEgithub%E3%80%90%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%E3%80%91.assets/202205270021736.png" alt="image-20220526225644489"></p><p>提示：没有正确的访问权限或者仓库不存在。</p><p>为了检查是否存在其它问题，于是做了<strong>测试ssh连接</strong>和<strong>克隆仓库</strong>两项测试：结果都报了同样的错误</p><p><img src="/Git%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%AE%BF%E9%97%AEgithub%E3%80%90%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%E3%80%91.assets/202205270021738.png" alt="image-20220526230541377"></p><p>仓库是存在的，所以<strong>问题就出在无法访问github服务器</strong>。</p><p>逐一排除可能造成git无法访问github服务器的原因：</p><ul><li><p><strong>没有正确配置SSH key</strong></p><p>重新生成配置SSH key了两次，发现问题并没有解决</p></li><li><p><strong>22端口无法访问的原因</strong></p><p>网上搜索最多的解决办法之一就是改端口，于是测试了更换443端口</p></li></ul><p><strong>Five hours later…</strong></p><h3 id="三、解决办法"><a href="#三、解决办法" class="headerlink" title="三、解决办法"></a>三、解决办法</h3><p>瞎打误撞了半天，最后终于撞见了真正的问题原因，因为删除了.ssh目录下的<code>known hosts</code>文件。</p><p>浪费了那么久，校园网也有很大的责任，wifi换成手机热点之后，才提示出hostname无法解析度原因，然后按照网上的经验，在<code>C:\Windows\System32\drivers\etc\hosts</code>文件中增加了github.com的IP地址之后，才让known hosts文件浮出水面。</p><p><img src="/Git%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%AE%BF%E9%97%AEgithub%E3%80%90%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%E3%80%91.assets/202205270021740.png" alt="image-20220527000546824"></p><p>至于为什么删除<code>known hosts</code>文件会导致无法连接，需要先了解一下ssh验证的机制，以及<code>known hosts</code>文件发挥的作用</p><p><img src="/Git%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E8%AE%BF%E9%97%AEgithub%E3%80%90%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%E3%80%91.assets/202205270021741.png" alt="image-20220527000640222"></p><p>参考文章：<a href="https://blog.csdn.net/qq_39387856/article/details/100100903"> SSH之known_hosts文件</a></p><p>有效解决的过程：</p><ol><li>wifi从校园网更换为手机热点（因为校园网为了安全可能会增加一些屏蔽操作，很谜~）</li><li>在<code>C:\Windows\System32\drivers\etc\hosts</code>文件中增加了github.com的IP地址，然后clone一个库，让ssh重新生成了<code>known hosts</code>文件</li><li>重新连接成功</li></ol><p>最终参考找到解决办法的文章：<a href="https://blog.csdn.net/zhouzhiwengang/article/details/124960506"> Git提示：ssh: Could not resolve hostname github.com: No address associated with hostname_在奋斗的大道的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid主题排版出错，重装一次主题解决</title>
    <link href="/2022/05/27/hexo/Fluid%E4%B8%BB%E9%A2%98%E6%8E%92%E7%89%88%E7%AA%81%E7%84%B6%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/05/27/hexo/Fluid%E4%B8%BB%E9%A2%98%E6%8E%92%E7%89%88%E7%AA%81%E7%84%B6%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Fluid主题排版出错，重装一次主题解决"><a href="#Fluid主题排版出错，重装一次主题解决" class="headerlink" title="Fluid主题排版出错，重装一次主题解决"></a>Fluid主题排版出错，重装一次主题解决</h2><h3 id="一、存在问题"><a href="#一、存在问题" class="headerlink" title="一、存在问题"></a>一、存在问题</h3><p>大半个月没有浏览Hexo博客，再次浏览的时候发现网页的排版布局竟然出错了</p><p><img src="/Fluid%E4%B8%BB%E9%A2%98%E6%8E%92%E7%89%88%E7%AA%81%E7%84%B6%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/202205261709246.png" alt="image-20220526111234003"></p><p><em>PS：导航栏排版出错</em></p><p><img src="/Fluid%E4%B8%BB%E9%A2%98%E6%8E%92%E7%89%88%E7%AA%81%E7%84%B6%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/202205261709247.png" alt="image-20220526111310242"></p><p><em>PS：内容板块的宽度失效</em></p><p><img src="/Fluid%E4%B8%BB%E9%A2%98%E6%8E%92%E7%89%88%E7%AA%81%E7%84%B6%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/202205261709249.png" alt="image-20220526111354033"></p><p><em>PS：footer部分排版也出错了</em></p><p>打开“开发者模式”查看一下，发现控制台报了一系列错误</p><p><img src="/Fluid%E4%B8%BB%E9%A2%98%E6%8E%92%E7%89%88%E7%AA%81%E7%84%B6%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/202205261709250.png" alt="image-20220526110658076"></p><h3 id="二、原因分析"><a href="#二、原因分析" class="headerlink" title="二、原因分析"></a>二、原因分析</h3><p>原因是访问一些在线的css和js文件失败了。所以推测是主题配置的原因。</p><p>经过反复的<code>hexo clean</code>、<code>hexo g</code>之后，并没有解决什么问题，查看了主题配置文件<code>config_fluid.yaml</code>和hexo的配置文件<code>config.yaml</code>，发现也没有可以改变引用这些配置文件的地方。</p><h3 id="三、解决办法"><a href="#三、解决办法" class="headerlink" title="三、解决办法"></a>三、解决办法</h3><p>于是决定采取以下办法：</p><ul><li>首先恢复默认主题，看看是否还会存在因为在线css和js资源无法加载引起的排版问题</li><li>如果上一步成功解决，那么尝试重新安装fluid主题，看看是否重装能不能避免问题</li><li>如果重装fluid主题，仍然出现原来的问题，那么就判定为fluid主题的问题，那么再更换另外一个主题</li></ul><h4 id="1、恢复默认主题"><a href="#1、恢复默认主题" class="headerlink" title="1、恢复默认主题"></a>1、恢复默认主题</h4><p>打开<code>config.yaml</code>文件，修改theme字段</p><p><img src="/Fluid%E4%B8%BB%E9%A2%98%E6%8E%92%E7%89%88%E7%AA%81%E7%84%B6%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/202205261709251.png" alt="image-20220526114027002"></p><p>恢复为hexo默认的landscape主题之后，再次生成，打开服务器，浏览</p><p><img src="/Fluid%E4%B8%BB%E9%A2%98%E6%8E%92%E7%89%88%E7%AA%81%E7%84%B6%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/202205261709252.png" alt="image-20220526114048041"></p><p>发现fluid主题之前排版出现的问题被解决了，验证了推测是fluid主题内部的问题</p><h4 id="2、重装fluid主题"><a href="#2、重装fluid主题" class="headerlink" title="2、重装fluid主题"></a>2、重装fluid主题</h4><p>首先卸载hexo项目下的<code>hexo-theme-fluid</code>包，</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> uninstall hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>发现hexo目录下的<code>config_fluid.yaml</code>文件还在，手动删除它</p><p><img src="/Fluid%E4%B8%BB%E9%A2%98%E6%8E%92%E7%89%88%E7%AA%81%E7%84%B6%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/202205261709253.png" alt="image-20220526121757118"></p><p>安装fluid主题，参考官方文档：<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev&#x2F;hexo-theme-fluid: 一款 Material Design 风格的 Hexo 主题 </a></p><p>Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-theme-fluid</span><br></code></pre></td></tr></table></figure><p>在hexo目录下新建一个<code>_config.fluid.yml</code>，把主题的 <a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">_config.yml</a> 内容复制进去</p><p>更换fluid主题，修改<code>config.yml</code>如下：</p><p><img src="/Fluid%E4%B8%BB%E9%A2%98%E6%8E%92%E7%89%88%E7%AA%81%E7%84%B6%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/202205261709254.png" alt="image-20220526123158823"></p><p><em>补充：language那一行需要注释掉，不然报错</em></p><p>删除掉public文件夹下所有内容（不是必须的，个人觉得删一删安心一点）</p><p><code>hexo g</code>、<code>hexo s</code>，打开网址浏览，发现问题成功解决了！</p><p><img src="/Fluid%E4%B8%BB%E9%A2%98%E6%8E%92%E7%89%88%E7%AA%81%E7%84%B6%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/202205261709255.png" alt="image-20220526123849194"></p><p><img src="/Fluid%E4%B8%BB%E9%A2%98%E6%8E%92%E7%89%88%E7%AA%81%E7%84%B6%E5%87%BA%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95.assets/202205261709256.png" alt="image-20220526123858471"></p><p>一切恢复正常，默认配置还没有修改。</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 引用类型</title>
    <link href="/2022/05/13/%E5%89%8D%E7%AB%AF/JavaScript%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/05/13/%E5%89%8D%E7%AB%AF/JavaScript%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>基本引用类型（Date、RegExp、JSON、原始值包装对象），集合引用类型（Array、Map、Set），迭代与扩展操作</p><span id="more"></span><h2 id="JavaScript-引用类型"><a href="#JavaScript-引用类型" class="headerlink" title="JavaScript 引用类型"></a>JavaScript 引用类型</h2><blockquote>引用值（或者对象）是某个特定引用类型的实例。在ECMAScript中，引用类型是把数据和功能组织到一起的结构。<p>    新对象通过使用new操作符后跟一个构造函数（constructor）来创建    </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br></code></pre></td></tr></table></figure><p>在这里，<code>Data()</code>就是一个构造函数（constructor）</p><h3 id="一、基本引用类型"><a href="#一、基本引用类型" class="headerlink" title="一、基本引用类型"></a>一、基本引用类型</h3><blockquote>1、Date<br>    2、RegExp<br>    3、JSON<br>    4、原始值包装类型（String、Number、Boolean）<br></blockquote><h4 id="1、Date"><a href="#1、Date" class="headerlink" title="1、Date"></a>1、Date</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>now; <span class="hljs-comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span><br>now.<span class="hljs-title function_">getFullYear</span>(); <span class="hljs-comment">// 2015, 年份</span><br>now.<span class="hljs-title function_">getMonth</span>(); <span class="hljs-comment">// 5, 月份，注意月份范围是0~11，5表示六月</span><br>now.<span class="hljs-title function_">getDate</span>(); <span class="hljs-comment">// 24, 表示24号</span><br>now.<span class="hljs-title function_">getDay</span>(); <span class="hljs-comment">// 3, 表示星期三</span><br>now.<span class="hljs-title function_">getHours</span>(); <span class="hljs-comment">// 19, 24小时制</span><br>now.<span class="hljs-title function_">getMinutes</span>(); <span class="hljs-comment">// 49, 分钟</span><br>now.<span class="hljs-title function_">getSeconds</span>(); <span class="hljs-comment">// 22, 秒</span><br>now.<span class="hljs-title function_">getMilliseconds</span>(); <span class="hljs-comment">// 875, 毫秒数</span><br>now.<span class="hljs-title function_">getTime</span>(); <span class="hljs-comment">// 1435146562875, 以number形式表示的时间戳</span><br></code></pre></td></tr></table></figure><p><strong>创建Date对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2015</span>, <span class="hljs-number">5</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">30</span>, <span class="hljs-number">123</span>);<br>d; <span class="hljs-comment">// Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</span><br></code></pre></td></tr></table></figure><p><strong>特别注意：月份下标是0-11</strong>，所以定义的时候要比真实月份减一，获取的月份也比真实小一</p><p><strong>格式化方法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> D = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><br>D.<span class="hljs-title function_">toLocaleString</span>()<span class="hljs-comment">//&#x27;2022/5/3 20:29:53&#x27;</span><br>D.<span class="hljs-title function_">toString</span>()<span class="hljs-comment">//&#x27;Tue May 03 2022 20:29:53 GMT+0800 (中国标准时间)&#x27;</span><br>D.<span class="hljs-title function_">valueOf</span>()<span class="hljs-comment">//1651580993637</span><br><br>D.<span class="hljs-title function_">toDateString</span>()<span class="hljs-comment">//&#x27;Tue May 03 2022&#x27;</span><br>D.<span class="hljs-title function_">toTimeString</span>()<span class="hljs-comment">//&#x27;20:33:55 GMT+0800 (中国标准时间)&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="2、RegExp"><a href="#2、RegExp" class="headerlink" title="2、RegExp"></a>2、RegExp</h4><p><strong>语法：</strong><code>let expression = /pattern/flags</code>  </p><ul><li>pattern，指正则表达式</li><li>flags，标记，用于控制正则表达式的行为<ul><li>g，全局模式，查找字符串的全部内容</li><li>i，不区分大小写</li></ul></li></ul><p><strong>正则表达式符号</strong></p><table><thead><tr><th>符号</th><th>说明</th><th></th><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>\d</td><td>1个数字</td><td></td><td>\w</td><td>1个字母或数字</td></tr><tr><td>\s</td><td>1个或多个空格或占位符</td><td></td><td>.</td><td>1个任意字符</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>后缀</strong></td><td><strong>说明</strong></td><td></td><td><strong>后缀</strong></td><td><strong>说明</strong></td></tr><tr><td>*</td><td>任意数量</td><td></td><td>+</td><td>至少一个</td></tr><tr><td>？</td><td>0个或1个</td><td></td><td>{n}</td><td>n个</td></tr><tr><td>$</td><td>行的结束</td><td></td><td>{n,m}</td><td>n-m个</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>前缀</strong></td><td>说明</td><td></td><td><strong>转义字符</strong></td><td><strong>说明</strong></td></tr><tr><td>^</td><td>行的开始</td><td></td><td>\</td><td>一些特殊的符号，如-，需要用\作为前缀</td></tr></tbody></table><p><code>[]</code>表示范围，如<code>[0-9a-zA-Z\_]</code>表示一个数字、字母或下划线</p><p><code>()</code>，<code>(com|org)</code>表示从com或org当中选一个</p><p><strong>创建方式</strong></p><ul><li><p>方式一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> re1 = <span class="hljs-regexp">/\d&#123;3&#125;\-\d&#123;3-8&#125;/g</span> ;<br>re1.<span class="hljs-title function_">test</span>(<span class="hljs-number">010</span>-<span class="hljs-number">10086</span>)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure></li><li><p>方式二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> re2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;/\d&#123;3&#125;\-\d&#123;3-8&#125;/&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul><p><strong>属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> re = <span class="hljs-regexp">/[bc]at/gi</span>;<br>re.<span class="hljs-property">global</span><span class="hljs-comment">//true</span><br>re.<span class="hljs-property">ignoreCase</span><span class="hljs-comment">//true</span><br>re.<span class="hljs-property">source</span><span class="hljs-comment">//&#x27;[bc]at&#x27;</span><br>re.<span class="hljs-property">flags</span><span class="hljs-comment">//&#x27;gi&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>实例方法</strong></p><ul><li><p>实例.exec()，传入一个字符串参数，（找到匹配项）返回第一个匹配信息的数组，（没找到匹配项）返回null</p><p>两个额外属性：<code>index</code>和<code>input</code>。<code>index</code>表示字符串中匹配的起点，<code>input</code>表示查找的字符串</p></li><li><p>实例.test()，传入一个字符串参数，返回一个boolead值</p></li></ul><p><strong>功能</strong></p><ul><li><p><strong>切分字符串</strong>，用正则表达式作为切分字符，比固定字符更加灵活</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a,b;; c  d&#x27;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/[\s+\,\;]+/</span>); <span class="hljs-comment">//结果为：[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>分组</strong>，正则表达式还有提取子串的功能，用<code>()</code>表示的就是要提取的分组（Group），匹配失败的时候返回null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/^(\d&#123;3&#125;)\-(\d&#123;3,8&#125;)$/</span>;<br>re.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;010-12345&#x27;</span>);<span class="hljs-comment">//结果为 [ &quot;010-12345&quot;, &quot;010&quot;, &quot;12345&quot; ]</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>贪婪匹配</strong></p><p>正则匹配默认为贪婪匹配，就是匹配尽可能多的字符，但这有时并不是我们多希望的，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/^(\d+)(0*)$/</span>;<br>re.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;102300&#x27;</span>);<span class="hljs-comment">//[&#x27;102300&#x27;,&#x27;102300&#x27;,&#x27;&#x27;] 这里\d+匹配了后面所有的0</span><br></code></pre></td></tr></table></figure><p>通过添加一个<code>?</code>后缀采取非贪婪匹配</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/^(\d+?)(0*)$/</span>;<br>re.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;102300&#x27;</span>);<span class="hljs-comment">//[&#x27;102300&#x27;,&#x27;1023&#x27;,&#x27;00&#x27;]</span><br></code></pre></td></tr></table></figure><p><strong>全局搜索</strong></p><p>在正则表达式后面添加<code>g</code>，表示全局匹配，全局匹配表示可以多次执行<code>exec()</code>进行匹配</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;JavaScript, VBScript, JScript and ECMAScript&#x27;</span>;<br><span class="hljs-keyword">var</span> re=<span class="hljs-regexp">/[a-zA-Z]+Script/g</span>;<br>re.<span class="hljs-title function_">exec</span>(s);<br></code></pre></td></tr></table></figure><h4 id="3、JSON"><a href="#3、JSON" class="headerlink" title="3、JSON"></a>3、JSON</h4><p>JavaScript Object Notation的缩写，JS对象符号，它是一种数据交换格式。</p><p>为了统一解析，JSON的字符串规定必须用双引号<code>&quot;&quot;</code>，Object的键也必须用双引号<code>&quot;&quot;</code></p><br><p><strong>序列化</strong>，<code>JSON.stringify(objectName)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xiaoming = &#123;...&#125;;<br><span class="hljs-keyword">var</span> s = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(xiaoming);<br></code></pre></td></tr></table></figure><p>还可以加上一些参数</p><ul><li><p><code>JSON.stringify(xiaoming,null,&#39;  &#39;)</code>：<code>&#39; &#39;</code>表示按缩进输出</p></li><li><p><code>JSON.stringify(xiaoming,[&#39;name&#39;,&#39;skills&#39;],&#39; &#39;)</code>：传入一个Array[]，筛选输出的值</p></li><li><p>传入一个函数，如下：把所有属性值变成大写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">convert</span>(<span class="hljs-params">key,value</span>)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value == <span class="hljs-string">&#x27;string&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">toUpperCase</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(xiaoming,convert,<span class="hljs-string">&#x27; &#x27;</span>);<br><span class="hljs-keyword">var</span> s2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(xiaoming,[<span class="hljs-string">&#x27;name&#x27;</span>],convert,<span class="hljs-string">&#x27; &#x27;</span>);<span class="hljs-comment">//错误，不能这么传递参数</span><br></code></pre></td></tr></table></figure></li><li><p>还可以控制序列化的规则，在对象内部定义一个<code>toJSON()</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xiaoming = &#123;<br>...<br>    <span class="hljs-attr">toJSON</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span>&#123;<br>            <span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>,<br>            <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span><br>        &#125;;<br>    &#125;<br>&#125;<br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(xiaoming);<span class="hljs-comment">//只返回&#123;&quot;Name&quot;:&quot;小明&quot;,&quot;Age&quot;:14&#125;&#x27;，不返回其余属性</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xiaoming = &#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&quot;xiaoming&quot;</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">18</span>,<br>    <span class="hljs-attr">toJSON</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span>&#123;<br>            <span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>.<span class="hljs-title function_">toUpperCase</span>(),<br>            <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span><br>        &#125;;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> s = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(xiaoming,[<span class="hljs-string">&#x27;Name&#x27;</span>],<span class="hljs-string">&#x27; &#x27;</span>);<br>s<span class="hljs-comment">//输出为：&quot;&#123;\&quot;Name\&quot;: \&quot;XIAOMING\&quot;&#125;&quot;</span><br></code></pre></td></tr></table></figure><br><p><strong>反序列化</strong>，<code>JSON.parse()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;[1,2,3,true]&#x27;</span>);<span class="hljs-comment">//[1,2,3,true]</span><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;&#123;&quot;Name&quot;:&quot;xiaoming&quot;&#125;&#x27;</span>);<span class="hljs-comment">//Object &#123; Name: &quot;xiaoming&quot; &#125;</span><br></code></pre></td></tr></table></figure><p><code>JSON.parse()</code>还可以接收一个函数，用来转换解析出的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;&#123;&quot;Name&quot;:&quot;小明&quot;,&quot;age&quot;:&quot;20&quot;&#125;&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">key,value</span>)&#123;<br>    <span class="hljs-keyword">if</span>(key === <span class="hljs-string">&#x27;age&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> value+<span class="hljs-string">&quot;岁&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;)<br>obj;<span class="hljs-comment">//Object &#123; Name: &quot;小明&quot;, age: &quot;20岁&quot; &#125;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="4、原始值包装类型"><a href="#4、原始值包装类型" class="headerlink" title="4、原始值包装类型"></a>4、原始值包装类型</h4><p>ECMAScript提供了3种特殊的引用类型：Boolean、Number和String</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-string">&quot;text&quot;</span>;<br><span class="hljs-keyword">let</span> s2 = s1.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>s1是一个string原始值变量，逻辑上本不应该有诸如substring的方法，但是它又成功运行了，这是因为，在此期间后台做了一些操作：</p><p>（1）创建一个String类型的实例；（2）调用实例上的特定方法；（3）销毁实例。</p><p>引用类型与原始值包装类型的主要区别在于对象的生命周期</p><p><strong>由于String不属于集合引用类型，所以把String的诸多性质放到《JavaScript基础》-【基本数据类型】里面探究了。</strong></p><h3 id="二、集合引用类型"><a href="#二、集合引用类型" class="headerlink" title="二、集合引用类型"></a>二、集合引用类型</h3><blockquote> 1、对象<br>2、Array<br>3、Map和WeakMap<br>4、Set和WeakSet<br>5、迭代与扩展操作</blockquote><h4 id="1、对象Object"><a href="#1、对象Object" class="headerlink" title="1、对象Object"></a>1、对象Object</h4><p><strong>创建对象的两种方式</strong>：</p><ul><li>new操作符 + Object构造函数</li><li>对象字面量表示法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Liu&quot;</span>;<br>person[<span class="hljs-string">&#x27;first name&#x27;</span>]=<span class="hljs-string">&quot;Liu&quot;</span>;<span class="hljs-comment">//如果不是有效的变量名，需要通过中括号这种方式定义(中括号里面的变量需要用引号包裹)</span><br>person.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;<br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;Liu&quot;</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">21</span>,<br>    <span class="hljs-title function_">say</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> hello`</span>);&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>存取对象的属性的两种方式：</strong></p><ul><li>点语法</li><li>中括号，可以使用一些不符合变量命名要求的键</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Liu&quot;</span>;<br>person[<span class="hljs-string">&quot;first name&quot;</span>]=<span class="hljs-string">&quot;Liu&quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>判断属性是否存在的两种方式：</strong></p><ul><li>in判断</li><li>hasOwnProperty()方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> person<br>person.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;name&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="2、数组Array"><a href="#2、数组Array" class="headerlink" title="2、数组Array"></a>2、数组Array</h4><p><strong>创建方式：</strong></p><ul><li>new操作符 + Array构造函数，其中new操作符可选</li><li>数组字面量</li><li>Array.from()，传入一个可迭代的结构，或者是有length属性和可索引元素的结构。可选第二个参数，映射函数参数</li><li>Array.of()，把一组参数转换为数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<br><span class="hljs-keyword">let</span> colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">5</span>);<span class="hljs-comment">//new的时候指定数组长度</span><br><span class="hljs-keyword">let</span> colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>,<span class="hljs-string">&#x27;blue&#x27;</span>);<span class="hljs-comment">//new的时候传入初始化元素</span><br><br><span class="hljs-keyword">let</span> colors = <span class="hljs-title class_">Array</span>();<br><span class="hljs-keyword">let</span> colors = <span class="hljs-title class_">Array</span>(<span class="hljs-number">5</span>);<span class="hljs-comment">//new的时候指定数组长度</span><br><span class="hljs-keyword">let</span> colors = <span class="hljs-title class_">Array</span>(<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>,<span class="hljs-string">&#x27;blue&#x27;</span>);<span class="hljs-comment">//new的时候传入初始化元素</span><br><br><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>,<span class="hljs-string">&#x27;blue&#x27;</span>];<br><span class="hljs-keyword">let</span> colors = [,,<span class="hljs-string">&#x27;blue&#x27;</span>];<span class="hljs-comment">//缺省的自动补undefined</span><br><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">&#x27;Java&#x27;</span>);<span class="hljs-comment">//[&#x27;J&#x27;, &#x27;a&#x27;, &#x27;v&#x27;, &#x27;a&#x27;]</span><br><span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>).<span class="hljs-title function_">set</span>(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(m);<span class="hljs-comment">//[[1,2],[3,4]]</span><br><span class="hljs-keyword">let</span> a1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(a1);<span class="hljs-comment">//[1, 2, 3]，深拷贝的方式</span><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(a1,<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span>x**<span class="hljs-number">2</span>);<span class="hljs-comment">//[1, 4, 9]</span><br><br><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//[1, 2, 3]</span><br></code></pre></td></tr></table></figure><p><strong>数组长度：</strong></p><ul><li>arr.length 获取数组长度，也可以通过<code>arr.length=xx</code>来改变数组长度，多删少补undefined</li></ul><p><strong>数组的方法：</strong></p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>arr.slice(start,end)</td><td>数组切片，返回一个新数组。如果不加参数返回整个数组，可以用来深拷贝。如果只给一个参数，它将作为起始索引</td></tr><tr><td>arr.push()和arr.pop()</td><td>数组末尾添加、删除。pop()会返回值，类似于栈的操作</td></tr><tr><td>arr.unshift()和arr.shift()</td><td>用来在数组头插入和删除。shift()会返回值</td></tr><tr><td>arr.sort()</td><td>直接对当前的数组进行排序（按照字符串的顺序排，而不是按照数的大小排），修改发生在原数组上，同时返回数组的引用</td></tr><tr><td>arr.reverse()</td><td>颠倒当前数组的元素位置，修改发生在原数组上，同时返回数组的引用</td></tr><tr><td>arr.join(‘-‘)</td><td>参数必须为字符或字符串，返回一个所有元素以参数相连接的字符串</td></tr><tr><td>arr.concact( arr2 )</td><td>连接arr和arr2，并返回一个新数组，原数组不变</td></tr><tr><td>arr.splice(start,num,[item1,item2,…])</td><td>在当前数组上发生改变，从start开始，删除num个元素，在start位置开始插入item。同时将删除掉的元素组成一个数组作为返回值。</td></tr><tr><td>arr.indexOf()<br />lastIndexOf()<br />includes()</td><td>接受一个参数，查找该参数元素在数组中的下标，如果不存在返回-1<br />从数组末尾（最后一项）开始向前搜索<br />返回布尔值，表示是否至少找到一个与指定元素匹配的项</td></tr><tr><td>find()<br />findIndex()</td><td>返回第一个匹配的元素，<br />返回第一个匹配元素的索引</td></tr><tr><td>forEach()</td><td>把每个元素依次作用于传入的函数，但是不返回新的数组<br />arr.forEach(function(element,index,array){…})</td></tr><tr><td>every()</td><td>判断数组的所有元素是否满足测试条件</td></tr><tr><td>map()和reduce()</td><td>map的作用是把一个函数作用到Array的所有元素上，返回一个新的数组<br />reduce的作用是把一个函数累加作用在Array的元素上，它必须要有两个参数，返回一个值</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">every</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>)&#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">toLowerCase</span>() === s;<br>&#125;))<span class="hljs-comment">//false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">find</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>)&#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">toLowerCase</span>() === s;<br>&#125;))<span class="hljs-comment">//pear</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>)&#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">toLowerCase</span>() === s;<br>&#125;))<span class="hljs-comment">//1</span><br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>,<span class="hljs-number">21</span>];<br>arr.<span class="hljs-title function_">sort</span>();<span class="hljs-comment">//[1,10,2,21]</span><br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">x,y</span>)&#123;<br><span class="hljs-keyword">if</span>(x&lt;y)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<br><span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<br>&#125;)<span class="hljs-comment">//[ 21, 10, 2, 1 ]</span><br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">x,y</span>)=&gt;</span>x&gt;y);<span class="hljs-comment">//[ 1, 2, 10, 21 ]</span><br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;  &#x27;</span>];<br><span class="hljs-keyword">var</span> r = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123; <span class="hljs-keyword">return</span> s; &#125;); <span class="hljs-comment">// r = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;  &#x27;]</span><br><span class="hljs-keyword">var</span> r = arr.<span class="hljs-title function_">filter</span>( <span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s);<br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];<br>arr.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">element,index,arr</span>)&#123;<br>    <span class="hljs-keyword">if</span>(index % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(element);&#125;<br>    <span class="hljs-keyword">return</span> element*element;<br>&#125;)<span class="hljs-comment">// 1 3 5 7 9</span><br>arr;<span class="hljs-comment">// Array(9) [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]</span><br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br>arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">x,y</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;)<span class="hljs-comment">//10</span><br></code></pre></td></tr></table></figure><p><strong>判断变量是否为数组类型的方法：</strong></p><ul><li>arr instanceof Array</li><li>Array.isArray(arr)</li></ul><h4 id="3、Map"><a href="#3、Map" class="headerlink" title="3、Map"></a>3、Map</h4><blockquote>对象Object的属性值只能为字符串。为了突破这个限制，ES6新增了Map对象，Map 结构提供了“值—值”的对应，并且能够记住键的原始插入顺序，任何值(对象或者原始值) 都可以作为一个键或一个值</blockquote><p><strong>Map定义方式：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;Mike&#x27;</span>,<span class="hljs-number">80</span>],[<span class="hljs-string">&#x27;Jode&#x27;</span>,<span class="hljs-number">90</span>]]);<br>m <span class="hljs-comment">//&#123;&#x27;Mike&#x27; =&gt; 80, &#x27;Jode&#x27; =&gt; 90&#125;</span><br><br><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>m.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Mike&#x27;</span>,<span class="hljs-number">80</span>);<br>m.<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>,<span class="hljs-number">90</span>);<br>等价于：<br><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>().<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Mike&#x27;</span>,<span class="hljs-number">80</span>).<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>,<span class="hljs-number">90</span>);<br>m<span class="hljs-comment">//&#123;&#x27;Mike&#x27; =&gt; 80, 1 =&gt; 90&#125;</span><br></code></pre></td></tr></table></figure><p><strong>Map的方法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">m.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;Mike&#x27;</span>); <span class="hljs-comment">//80</span><br>m.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;Mike&#x27;</span>); <span class="hljs-comment">//true</span><br>m.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;Mike&#x27;</span>);<br>m.<span class="hljs-title function_">get</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//90</span><br></code></pre></td></tr></table></figure><p><strong>Map的迭代：</strong></p><ul><li>entries()方法，或者Symbol.iterator属性（实际上它也是引用entries()）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;Mike&#x27;</span>,<span class="hljs-number">80</span>],[<span class="hljs-string">&#x27;Jode&#x27;</span>,<span class="hljs-number">90</span>]]);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> pair <span class="hljs-keyword">of</span> m.<span class="hljs-title function_">entries</span>())&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pair);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> pair <span class="hljs-keyword">of</span> m[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]())&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pair);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><ul><li>WeakMap和Map的区别在于，Map的键值可以是任意JavaScript类型，但WeakMap的键类型只能是Object或者继承自Object的类型。这些键不属于正式的引用，所以不影响垃圾回收，这也是使用WeakMap的意义。</li><li>因为WeakMap的元素随时可能会被回收，所以它不支持迭代。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> wm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><span class="hljs-keyword">const</span> loginButton = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#login&#x27;</span>);<br>wm.<span class="hljs-title function_">set</span>(loginButton,&#123;<span class="hljs-attr">disabled</span>:<span class="hljs-literal">true</span>&#125;);<br></code></pre></td></tr></table></figure><h4 id="4、Set"><a href="#4、Set" class="headerlink" title="4、Set"></a>4、Set</h4><p><strong>Set的创建方式：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;3&#x27;</span>]);<br><br><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>s.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>s.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;3&#x27;</span>);<br>等价于：<br><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>().<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;3&#x27;</span>);<br>s<span class="hljs-comment">//&#123;1, &#x27;3&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p><strong>Set的方法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">s.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;3&#x27;</span>);<span class="hljs-comment">//返回一个boolean值，表示是否存在要删除的值</span><br>s.<span class="hljs-title function_">has</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//返回boolean值</span><br></code></pre></td></tr></table></figure><p><strong>Set的迭代方法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;3&#x27;</span>]);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> s.<span class="hljs-title function_">values</span>())&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">//1,2,3</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> s[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]())&#123;<br>    <span class="hljs-title function_">alert</span>(value);<span class="hljs-comment">//1,2,3</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&quot;val1&quot;</span>]);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> s1.<span class="hljs-title function_">values</span>())&#123;<br>    value = <span class="hljs-string">&quot;val2&quot;</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">//val2</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;val1&#x27;</span>));<span class="hljs-comment">//true</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> s1.<span class="hljs-title function_">values</span>())&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<span class="hljs-comment">//val1</span><br>&#125;<span class="hljs-comment">//实际上，Set内部的值并没有被改变</span><br></code></pre></td></tr></table></figure><h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><ul><li>WeakSet中的“weak”（弱），描述的是JavaScript垃圾回收程序对待“弱集合”中值的方式</li><li>弱集合中的值只能是Object或者继承自Object的类型，尝试使用非对象设置值会抛出TypeError</li><li>不可迭代值</li></ul><h4 id="5、迭代与扩展操作"><a href="#5、迭代与扩展操作" class="headerlink" title="5、迭代与扩展操作"></a>5、迭代与扩展操作</h4><p>ECMAScript 6新增的<strong>迭代器</strong>和<strong>扩展操作符</strong>对集合引用类型特别有用。</p><p>Array、Map、Set都定义了默认迭代器，所以都支持for-of循环，也意味着这些类型兼容扩展操作符<code>...</code></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 面向对象</title>
    <link href="/2022/05/13/%E5%89%8D%E7%AB%AF/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/05/13/%E5%89%8D%E7%AB%AF/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>对象、原型继承、类</p><span id="more"></span><h2 id="JavaScript-面向对象"><a href="#JavaScript-面向对象" class="headerlink" title="JavaScript 面向对象"></a>JavaScript 面向对象</h2><h3 id="一、理解对象"><a href="#一、理解对象" class="headerlink" title="一、理解对象"></a>一、理解对象</h3><blockquote>对象就是一组属性的无序集合（ES定义），对象的内容可以看作一组名/值对，其中值可以是数据或函数（方法）</blockquote><h4 id="1、对象属性"><a href="#1、对象属性" class="headerlink" title="1、对象属性"></a>1、对象属性</h4><p><strong>对象属性的类型</strong></p><p>对象属性具有自己的特征，这些特征被一些内部属性所表示（用两个中括号括起来以示区别，开发者并不能直接访问这些属性）。</p><p>内部属性分为两种：1、数据属性；2、访问器属性</p><p><strong>数据属性：</strong></p><table><thead><tr><th>[[Configurable]]</th><th>表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性</th></tr></thead><tbody><tr><td>[[Enumerable]]</td><td>表示属性是否可以通过for-in循环返回</td></tr><tr><td>[[Writable]]</td><td>表示属性的值是否可以被修改</td></tr><tr><td>[[Value]]</td><td>读取和写入属性值的位置</td></tr></tbody></table><p><strong>访问器属性：</strong>不包含数据值，包含getter和setter函数，用来读取和设置属性值</p><table><thead><tr><th>[[Configurable]]</th><th>表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性</th></tr></thead><tbody><tr><td>[[Configurable]]</td><td>表示属性是否可以通过for-in循环返回</td></tr><tr><td>[[Get]]</td><td>获取函数，在读取属性时调用。默认值为undefined。</td></tr><tr><td>[[Get]]</td><td>设置函数，在写入属性时调用。默认值为undefined</td></tr></tbody></table><p><strong>修改、获取属性的特性的方法：</strong></p><ul><li>Object.defineProperty()方法</li><li>Object.defineProperties()方法</li><li>Object.getOwnPropertyDescriptor()方法</li><li>Object.getOwnPropertyDescriptors()方法</li></ul><h4 id="2、对象语法（糖）"><a href="#2、对象语法（糖）" class="headerlink" title="2、对象语法（糖）"></a>2、对象语法（糖）</h4><p>ES6为定义和操作对象新增了很多语法糖</p><p><strong>属性值简写：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;Mike&quot;</span>;<br><span class="hljs-keyword">let</span> person = &#123;<br>    name<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person);<span class="hljs-comment">//&#123;name: &#x27;Mike&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p><strong>可计算属性：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> nameKey = <span class="hljs-string">&#x27;name&#x27;</span>;<br><span class="hljs-keyword">let</span> person = &#123;<br>    [nameKey]:<span class="hljs-string">&quot;Liu&quot;</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person);<span class="hljs-comment">//&#123;name: &#x27;Liu&#x27;&#125;</span><br><br><span class="hljs-keyword">const</span> nameKey = <span class="hljs-string">&#x27;name&#x27;</span>;<br><span class="hljs-keyword">const</span> ageKey = <span class="hljs-string">&#x27;age&#x27;</span>;<br><span class="hljs-keyword">let</span> uniqueToken = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUniqueKey</span>(<span class="hljs-params">key</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>_<span class="hljs-subst">$&#123;uniqueToken++&#125;</span>`</span>;<br>&#125;<br><span class="hljs-keyword">let</span> person = &#123;<br>    [<span class="hljs-title function_">getUniqueKey</span>(nameKey)]:<span class="hljs-string">&#x27;Qiu&#x27;</span>,<br>    [<span class="hljs-title function_">getUniqueKey</span>(ageKey)]:<span class="hljs-number">25</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person);<span class="hljs-comment">//&#123;name_0: &#x27;Qiu&#x27;, age_1: 25&#125;</span><br></code></pre></td></tr></table></figure><p><strong>简写方法名：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params">name</span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`hello <span class="hljs-subst">$&#123;name&#125;</span>`</span>);&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解构赋值：</strong>使用与对象匹配的结构来实现对象属性赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Matt&#x27;</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">21</span><br>&#125;<br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">name</span>:personName,age=<span class="hljs-number">11</span>,job=<span class="hljs-string">&quot;student&quot;</span>,grade&#125; = person;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personName);<span class="hljs-comment">//Matt</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age);<span class="hljs-comment">//21</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(job);<span class="hljs-comment">//student</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(grade);<span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure><p>解构并不要求变量必须在解构表达式中声明。不过，如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> personName,personAge;<br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Matt&#x27;</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">21</span><br>&#125;<br>(&#123;<span class="hljs-attr">name</span>:personName,age=personAge&#125; = person);<br></code></pre></td></tr></table></figure><h3 id="二、创建对象"><a href="#二、创建对象" class="headerlink" title="二、创建对象"></a>二、创建对象</h3><h4 id="1、原始的创建方式"><a href="#1、原始的创建方式" class="headerlink" title="1、原始的创建方式"></a>1、原始的创建方式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person1 =&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;Liu&quot;</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">21</span><br>&#125;<br><span class="hljs-keyword">let</span> person2 = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;Qiu&quot;</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">24</span><br>&#125;<br></code></pre></td></tr></table></figure><p>显而易见，这种创建对象的方式，会出现大量重复的代码，于是有了下面的构造函数模式</p><h4 id="2、构造函数模式"><a href="#2、构造函数模式" class="headerlink" title="2、构造函数模式"></a>2、构造函数模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);&#125;<br>&#125;<br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Liu&#x27;</span>,<span class="hljs-number">21</span>);<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Qiu&#x27;</span>,<span class="hljs-number">24</span>);<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//使用函数表达式也可以</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);&#125;<br>&#125;<br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Liu&#x27;</span>,<span class="hljs-number">21</span>);<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>;<span class="hljs-comment">//在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加</span><br></code></pre></td></tr></table></figure><p>按照惯例，<strong>构造函数名称的首字母都是要大写的</strong>，非构造函数则以小写字母开头</p><p>new操作符 + 构造函数 方式的<strong>创建过程，后台会执行以下步骤：</strong>（Prototype：原型）</p><p>（1）在内存中创建一个新对象。（2）这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype属性。（3）构造函数内部的this被赋值为这个新对象（即this指向新对象）。（4）执行构造函数内部的代码（给新对象添加属性）。</p><p>这种方式没有完全解决重复的问题，例如sayName函数其实代码是一样的，但是它会在每个对象中新建一个Function对象，为了解决这个问题，就引出了下面的原型模式</p><h4 id="3、原型模式"><a href="#3、原型模式" class="headerlink" title="3、原型模式"></a>3、原型模式</h4><p>每个函数都会创建一个<strong>prototype属性</strong>，这个属性是<strong>一个对象</strong>，<strong>包含应该由特定引用类型的实例共享的属性和方法</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age</span>)&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);&#125;<br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Liu&#x27;</span>,<span class="hljs-number">21</span>);<br>person1.<span class="hljs-title function_">sayName</span>();<span class="hljs-comment">//Liu</span><br></code></pre></td></tr></table></figure><p>只有Person原型可以访问prototype属性，new出来的实例无法直接访问prototype属性，但可以通过浏览器提供的<code>__proto__</code>访问到（并且可以修改）</p><p><img src="/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20220513104304562.png" alt="image-20220513104304562"></p><p><strong>原型语法：</strong></p><ul><li><p>in操作符 &amp; hasOwnProperty()方法</p><p>in操作符可以检查对象是否具有某个属性（实例上以及原型上）</p><p>hasOwnProperty()方法可以检查对象实例上是否具有某个属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> person1<span class="hljs-comment">//返回true或者false</span><br>person1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<span class="hljs-comment">//返回true或者false</span><br></code></pre></td></tr></table></figure></li><li><p>罗列出对象所有可枚举的属性，Object.keys()方法</p><p>罗列出对象所有属性，不管是否可以枚举，Object.getOwnPropertyNames()方法</p></li><li><p>对象迭代</p><p>Object.values()返回对象值的数组，Object.entries()返回键&#x2F;值对的数组</p></li><li><p>原型的动态性</p><p>随时能给原型添加属性和方法，并能够立即反映在所有对象实例上，实质上是对原型对象的扩充</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> friend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi&#x27;</span>);&#125;<br>friend.<span class="hljs-title function_">sayHi</span>();<br></code></pre></td></tr></table></figure><p>但是<strong>通过对象字面量方式重写整个原型会修改原型的指针</strong>，实质上是指向了一个新建的原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> friend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>=&#123;<br>    <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hi&#x27;</span>);&#125;<br>&#125;<br>friend.<span class="hljs-title function_">sayHi</span>();<span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="三、原型继承"><a href="#三、原型继承" class="headerlink" title="三、原型继承"></a>三、原型继承</h3><h4 id="1、原型链模式"><a href="#1、原型链模式" class="headerlink" title="1、原型链模式"></a>1、原型链模式</h4><blockquote>做法：把构造函数的原型赋值为另一个类型的实例。<br>优点：子类就可以访问父类的所有属性和方法<br>缺点：所有继承的属性和方法都会在对象实例间共享，无法做到实例私有</blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>);<br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>();<br></code></pre></td></tr></table></figure><p><img src="/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20220513105726606.png" alt="image-20220513105726606"></p><h4 id="2、盗用构造函数模式"><a href="#2、盗用构造函数模式" class="headerlink" title="2、盗用构造函数模式"></a>2、盗用构造函数模式</h4><blockquote>做法：在子类构造函数中调用父类构造函数（避免了原型链无法做到实例私有的缺点）<br>优点：达到了实例属性私有的效果<br>缺点：子类不能访问父类原型上的方法，即原型链没有接上</blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-string">&#x27;Liu&#x27;</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">21</span>;<br>&#125;<br><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br>instance.<span class="hljs-property">__proto__</span><span class="hljs-comment">//constructor: ƒ SubType()</span><br>instance.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span><span class="hljs-comment">//constructor: ƒ Object()</span><br></code></pre></td></tr></table></figure><h4 id="3、组合继承模式"><a href="#3、组合继承模式" class="headerlink" title="3、组合继承模式"></a>3、组合继承模式</h4><blockquote>做法：通过原型链继承共享的属性和方法，通过盗用构造函数继承实例属性<br>优点：子既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性<br>缺点：仍然可以会继承一些不需要的属性，如下例的colors属性</blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>,<span class="hljs-string">&#x27;blue&#x27;</span>];<br>&#125;<br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-title class_">Super</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,name);<span class="hljs-comment">//第二次调用SuperType()构造函数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>&#125;<br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>();<span class="hljs-comment">//第一次调用SuperType()构造函数</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);&#125;<br><span class="hljs-keyword">let</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&#x27;Liu&#x27;</span>,<span class="hljs-number">21</span>);<br></code></pre></td></tr></table></figure><h4 id="4、寄生式继承模式"><a href="#4、寄生式继承模式" class="headerlink" title="4、寄生式继承模式"></a>4、寄生式继承模式</h4><blockquote>做法：先基于一个对象创建一个新对象，然后再增强这个新对象，最后返回新对象</blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//原型式继承</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">object</span>(<span class="hljs-params">o</span>)&#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;&#125;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>ECMAScript 5通过增加<strong>Object.create()方法</strong>将原型式继承的概念规范化了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person =&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Liu&#x27;</span>,<br>    <span class="hljs-attr">friends</span>:[<span class="hljs-string">&#x27;Van&#x27;</span>,<span class="hljs-string">&#x27;Mike&#x27;</span>]<br>&#125;<br><br><span class="hljs-keyword">let</span> anotherPerson = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(person)<br>anotherPerson.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hi&#x27;</span>);&#125;<br>anotherPerson.<span class="hljs-property">__proto__</span><span class="hljs-comment">//&#123;name: &#x27;Liu&#x27;, friends: Array(2)&#125;</span><br></code></pre></td></tr></table></figure><p>这个例子基于person对象返回了一个新对象。新返回的anotherPerson对象具有person的所有属性和方法，还有一个新方法叫sayHi()</p><h4 id="5、寄生式组合继承"><a href="#5、寄生式组合继承" class="headerlink" title="5、寄生式组合继承"></a>5、寄生式组合继承</h4><blockquote>做法：盗用构造函数继承属性，但是是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本，<br>即让子类的prototype = 父类的prototype</blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-params">subType,superType</span>)&#123;<br>    <span class="hljs-keyword">let</span> prototype = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(superType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<span class="hljs-comment">//创建父类原型prototype的副本，不是浅复制</span><br>    prototype.<span class="hljs-property">constuctor</span> = subType;<span class="hljs-comment">//新建原型对象的constructor指回子类构造函数，解决重写原型导致constructor丢失的问题</span><br>    subType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = prototype;<span class="hljs-comment">//将新建原型对象赋值给子类原型</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//另外一种写法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inherits</span>(<span class="hljs-params">Child,Parent</span>)&#123;<br>    <span class="hljs-keyword">var</span> F = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>    <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>,<span class="hljs-string">&#x27;blue&#x27;</span>];<br>&#125;<br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,name);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>&#125;<br><span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-title class_">SubType</span>,<span class="hljs-title class_">SuperType</span>);<br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);&#125;<br><span class="hljs-title class_">SubType</span>.<span class="hljs-property">colors</span><span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure><p>寄生式组合继承的原型链示意图</p><img src="JavaScript面向对象.assets/image-20220414164122219.png" alt="image-20220414164122219" style="zoom: 33%;" /><h3 id="四、类"><a href="#四、类" class="headerlink" title="四、类"></a>四、类</h3><h4 id="1、类的使用方式"><a href="#1、类的使用方式" class="headerlink" title="1、类的使用方式"></a>1、类的使用方式</h4><p><strong>类的定义方式：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;&#125;<span class="hljs-comment">//类声明</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Animal</span> = <span class="hljs-keyword">class</span>&#123;&#125;<span class="hljs-comment">//类表达式</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonName</span>&#123;&#125;<span class="hljs-comment">//PersonName在外部是不可访问的，只能通过Person访问</span><br></code></pre></td></tr></table></figure><ul><li>函数声明可以提升，但类定义不能</li><li>函数受函数作用域限制，而类受块作用域限制</li></ul><p><strong>添加实例成员：</strong></p><p>在构造函数内，为实例添加“自有”属性，在构造函数执行后，还可以在外部为实例添加成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=<span class="hljs-string">&#x27;Mike&#x27;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-function">()=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br></code></pre></td></tr></table></figure><p><strong>添加原型方法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">//添加到this的内容会保存到每个不同的实例上</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=<span class="hljs-string">&#x27;Mike&#x27;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-function">()=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>    <span class="hljs-comment">//在类块中定义的内容会保存在类的原型上</span><br>    <span class="hljs-title function_">locate</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;prototype&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>获取和设置访问器：</strong>语法与行为跟普通对象一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">newName</span>)&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">name_</span> = newName;&#125;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>()&#123;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name_</span>;&#125;<br>&#125;<br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>p.<span class="hljs-property">name</span>=<span class="hljs-string">&quot;Jake&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>    <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Liu</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;Liu&#x27;</span>);<br><br><span class="hljs-comment">//实现继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrimaryStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Student</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,grade</span>)&#123;<br>        <span class="hljs-variable language_">super</span>(name);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = grade;<br>    &#125;<br>    <span class="hljs-title function_">getGrade</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a>2、继承</h4><p>ECMAScript 6新增特性中最出色的一个就是原生支持了类继承机制。虽然类继承使用的是新语法，但背后依旧使用的是原型链</p><p><strong>extends关键字：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span>&#123;&#125;<br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>();<br>b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Vehicle</span><span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>派生类都会通过原型链访问到类和原型上定义的方法。this的值会反映调用相应方法的实例或者类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span>&#123;<br>    <span class="hljs-title function_">identifyPrototype</span>(<span class="hljs-params">id</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id,<span class="hljs-variable language_">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">identifyClass</span>(<span class="hljs-params">id</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id,<span class="hljs-variable language_">this</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span>&#123;&#125;<br><span class="hljs-keyword">let</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>();<br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>;<br>v.<span class="hljs-title function_">identifyPrototype</span>(<span class="hljs-string">&#x27;vehicle&#x27;</span>);<span class="hljs-comment">//vehicle Vehicle &#123;&#125;</span><br>b.<span class="hljs-title function_">identifyPrototype</span>(<span class="hljs-string">&#x27;bus&#x27;</span>);<span class="hljs-comment">//bus Bus &#123;&#125;</span><br><span class="hljs-title class_">Bus</span>.<span class="hljs-title function_">identifyClass</span>(<span class="hljs-string">&#x27;bus&#x27;</span>);<br><span class="hljs-title class_">Vehicle</span>.<span class="hljs-title function_">identifyClass</span>(<span class="hljs-string">&#x27;vehicle&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>super()关键字：</strong></p><p>派生类的方法可以通过super关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、静态方法内部。</p><p>在类构造函数中使用super()可以调用父类构造函数，而且<strong>如果在子类中定义了constructor方法，必须在里面调用super()</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">hasEngine</span>=<span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">super</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在静态方法中可以通过super调用继承的类上定义的静态方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;vehicle&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">identify</span>();<br>    &#125;<br>&#125;<br><span class="hljs-title class_">Bus</span>.<span class="hljs-title function_">test</span>();<span class="hljs-comment">//vehicle</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 函数</title>
    <link href="/2022/05/13/%E5%89%8D%E7%AB%AF/JavaScript%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/13/%E5%89%8D%E7%AB%AF/JavaScript%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>函数定义、参数、属性、返回值，箭头函数，递归，闭包</p><span id="more"></span> <h2 id="JavaScript——函数"><a href="#JavaScript——函数" class="headerlink" title="JavaScript——函数"></a>JavaScript——函数</h2><h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><blockquote> <p>内容摘要</p> <p>1.函数名<br> 2.函数声明 vs 函数表达式</p> </blockquote><p><strong>函数名，就是指向函数的指针。</strong>这个性质决定了后面很多特性，例如：不能重载、函数可以作为变量赋值，等等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num</span>)&#123;<span class="hljs-keyword">return</span> num+<span class="hljs-number">1</span>;&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num</span>)&#123;<span class="hljs-keyword">return</span> num+<span class="hljs-number">2</span>;&#125;<br><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//3</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">one</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello&#x27;</span>;&#125;<br><span class="hljs-keyword">let</span> two = one;<br>one = <span class="hljs-literal">null</span>;<br><span class="hljs-title function_">two</span>();<br></code></pre></td></tr></table></figure><p><em>add实际上函数的指针，所以第2行代码实际上是赋予了add一个新的函数指针</em></p><h4 id="1-1-函数声明"><a href="#1-1-函数声明" class="headerlink" title="1.1 函数声明"></a>1.1 函数声明</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">n1,n2</span>)&#123;<br>    <span class="hljs-keyword">return</span> n1+n2;<br>&#125;<br></code></pre></td></tr></table></figure><p>具有<strong>函数声明提升</strong>，函数声明会在任何代码执行前，被添加到执行上下文，所以可以在定义之前使用函数</p><h4 id="1-2-函数表达式"><a href="#1-2-函数表达式" class="headerlink" title="1.2 函数表达式"></a>1.2 函数表达式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sum = <span class="hljs-keyword">function</span>(<span class="hljs-params">n1,n2</span>)&#123;<br>    <span class="hljs-keyword">return</span> n1+n2;<br>&#125;<br></code></pre></td></tr></table></figure><p>不具备<strong>函数声明提升</strong>，如果在定义之前调用它，会报错</p><h3 id="二、函数参数"><a href="#二、函数参数" class="headerlink" title="二、函数参数"></a>二、函数参数</h3><blockquote><p>内容摘要</p><p>1.命名参数 & arguments <br>2.默认参数值<br> 3.参数扩展与收集<br></p></blockquote><p><strong>函数参数特性：</strong>ECMAScript函数既不关心传入的参数个数，也不关心这些参数的数据类型。函数内部有一个隐藏的arguments对象，是类数组对象，用来保存传入的参数。</p><h4 id="2-1-arguments"><a href="#2-1-arguments" class="headerlink" title="2.1 arguments"></a>2.1 arguments</h4><ul><li>arguments对象由传入的参数决定</li><li>可以通过<code>arguments.length</code>获得对象长度，可以通过arguments[0]的方式访问其中的元素</li><li>arguments的值会始终和对应的命名参数同步（见以下代码示例）</li><li>箭头函数没有arguments对象</li><li>有一个callee属性，指向arguments所在函数的指针</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doAdd</span>(<span class="hljs-params">num1,num2</span>)&#123;<br>    <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]=<span class="hljs-number">10</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num2);<br>&#125;<br><span class="hljs-title function_">doAdd</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//10</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doAdd2</span>(<span class="hljs-params">num1,num2</span>)&#123;<br>    num2 = <span class="hljs-number">10</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-title function_">doAdd2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//10</span><br></code></pre></td></tr></table></figure><h4 id="2-2-默认参数"><a href="#2-2-默认参数" class="headerlink" title="2.2 默认参数"></a>2.2 默认参数</h4><p>只要在函数定义中的参数后面用&#x3D;就可以为参数赋一个默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num1,num2=<span class="hljs-number">10</span></span>)&#123;<span class="hljs-keyword">return</span> num1+num2;&#125;<br><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//11</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num1=<span class="hljs-number">10</span>,num2</span>)&#123;<span class="hljs-keyword">return</span> num1+num2;&#125;<br><span class="hljs-title function_">add</span>(<span class="hljs-literal">undefined</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//11</span><br><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//NaN</span><br></code></pre></td></tr></table></figure><p><em>如果默认参数写在前面，而且想使用它，那么可以在调用的时候在对应位置传入undefined</em></p><p><strong>默认参数作用域</strong></p><p>后面的参数，可以引用先定义的参数，但是不能反过来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num1=<span class="hljs-number">10</span>,num2=num1</span>)&#123;<span class="hljs-keyword">return</span> num1+num2;&#125;<br><span class="hljs-title function_">add</span>();<span class="hljs-comment">//20</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num1=num2,num2=<span class="hljs-number">10</span></span>)&#123;<span class="hljs-keyword">return</span> num1+num2;&#125;<br><span class="hljs-title function_">add</span>();<span class="hljs-comment">//Error</span><br></code></pre></td></tr></table></figure><h4 id="2-3-参数扩展与收集"><a href="#2-3-参数扩展与收集" class="headerlink" title="2.3 参数扩展与收集"></a>2.3 参数扩展与收集</h4><p>ES6新增了扩展操作符<code>...</code>，既可以用于调用时传参，也可以用于定义函数参数</p><p><strong>参数扩展</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">values = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSum</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>;i++)&#123;sum+=<span class="hljs-variable language_">arguments</span>[i];&#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-title function_">getSum</span>(...values);<br><span class="hljs-title function_">getSum</span>(<span class="hljs-number">1</span>,...values);<br><span class="hljs-title function_">getSum</span>(<span class="hljs-number">1</span>,...values,<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p><strong>参数收集</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSum</span>(<span class="hljs-params">firstValue,...values</span>)&#123;...&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-this"><a href="#2-4-this" class="headerlink" title="2.4 this"></a>2.4 this</h4><p><strong>在标准函数中，</strong>this引用的是调用函数的上下文对象</p><p><strong>在箭头函数中，</strong>this永远指向的都是定义箭头函数的上下文</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">inner</span>();<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">callee</span>.<span class="hljs-property">caller</span>);<br>&#125;<br><span class="hljs-title function_">outer</span>();<br></code></pre></td></tr></table></figure><h3 id="三、函数属性"><a href="#三、函数属性" class="headerlink" title="三、函数属性"></a>三、函数属性</h3><ul><li><p><strong>length属性</strong>，保存命名参数的个数</p></li><li><p><strong>prototype属性</strong>，保存引用类型所有实例方法的地方，诸如<code>toString()</code></p></li><li><p><strong>apply方法</strong>，语法：<code>函数名.apply(上下文对象，参数Array)</code></p></li><li><p><strong>call方法</strong>，语法：<code>函数名.call(上下文对象，[参数1，参数2，,,,]</code>，其中方括号<code>[]</code>表示可选的意思</p><p>以上两个方法最强大的地方在于，用来改变函数调用上下文（即函数体内this）的能力，如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-keyword">let</span> o = &#123;<span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;blue&#x27;</span>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayColor</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span>);&#125;<br><span class="hljs-title function_">sayColor</span>();<span class="hljs-comment">//red</span><br>sayColor.<span class="hljs-title function_">apply</span>(o);<span class="hljs-comment">//blue</span><br></code></pre></td></tr></table></figure></li><li><p><strong>bind方法</strong>，创建一个新的函数实例，并绑定this值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span>;<br><span class="hljs-keyword">let</span> o = &#123;<span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;blue&#x27;</span>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayColor</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span>);&#125;<br><span class="hljs-keyword">let</span> objectSayColor = sayColor.<span class="hljs-title function_">bind</span>(o);<br></code></pre></td></tr></table></figure></li></ul><h3 id="四、返回值"><a href="#四、返回值" class="headerlink" title="四、返回值"></a>四、返回值</h3><p>直接在函数体内使用return即可返回指定值</p><p><strong>函数作为返回值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">callFunction</span>(<span class="hljs-params">fun,argu</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fun</span>(argu);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num</span>)&#123;<br>    <span class="hljs-keyword">return</span> num+<span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-title function_">callFunction</span>(add,<span class="hljs-number">1</span>);<span class="hljs-comment">//11</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callFunction</span>(<span class="hljs-params">fun1,fun2,argu1,argu2</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fun1</span>(argu1)+<span class="hljs-title function_">fun2</span>(argu2);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num</span>)&#123;<br>    <span class="hljs-keyword">return</span> num+<span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-title function_">callFunction</span>(add,add,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//23</span><br></code></pre></td></tr></table></figure><h3 id="五、箭头函数"><a href="#五、箭头函数" class="headerlink" title="五、箭头函数"></a>五、箭头函数</h3><p><strong>格式：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(参数) =&gt; &#123;函数体&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>参数</strong></p><ul><li>如果只有一个，可以省略括号</li><li>如果没有、或者有多个，需要括号</li><li>如果要设置默认值，需要括号</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">x =&gt; &#123;...&#125;<br>(x,y) =&gt; &#123;...&#125;<br>(x=<span class="hljs-number">1</span>) =&gt; &#123;...&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>函数体</strong></p><ul><li>如果只有一行代码，可以省略大括号，默认会返回这行代码的值</li><li>如果不止一行，需要带上大括号</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(x,y) =&gt; x+y<br>(x,y) =&gt; &#123;...&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>其它：</strong></p><ul><li>不能使用<code>arguments</code>、<code>super</code>、<code>new.target</code></li><li>不能作为构造函数</li><li>没有<code>prototype</code>属性</li></ul></li></ul><h3 id="六、递归"><a href="#六、递归" class="headerlink" title="六、递归"></a>六、递归</h3><p><strong>方式一，使用函数名（不推荐！）</strong>。因为一旦函数名的指向发生变化，内部递归就将发生错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">num</span>)&#123;<br>    <span class="hljs-keyword">if</span>(num&lt;=<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<br>    <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">factorial</span>(num-<span class="hljs-number">1</span>);&#125;<br>&#125;<br><span class="hljs-keyword">let</span> other = factorial;<br>factorial = <span class="hljs-literal">null</span>;<br><span class="hljs-title function_">other</span>();<br></code></pre></td></tr></table></figure><p><strong>方式二，使用arguments.callee，严格模式下无效</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">num</span>)&#123;<br>    <span class="hljs-keyword">if</span>(num&lt;=<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<br>    <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">arguments</span>.<span class="hljs-title function_">callee</span>(num-<span class="hljs-number">1</span>);&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方式三，使用命名函数表达式（推荐）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> factioral = (<span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">num</span>)&#123;<br>    <span class="hljs-keyword">if</span>(num&lt;=<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<br>    <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>(num-<span class="hljs-number">1</span>);&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="七、闭包"><a href="#七、闭包" class="headerlink" title="七、闭包"></a>七、闭包</h3><p>闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。<strong>内部函数无法直接访问外部函数的this和arguments</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCompareFunction</span>(<span class="hljs-params">propertyName</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">object1,object2</span>)&#123;<br>        <span class="hljs-keyword">let</span> value1 = object1[propertyName];<br>        <span class="hljs-keyword">let</span> value2 = object2[propertyName];<br>        <span class="hljs-keyword">if</span>(value1&lt;value2)&#123;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>createCompareFunction</code>将返回一个函数，调用完毕之后，它的作用域链会被销毁，但是它的活动对象仍然保存在内存中，直到匿名函数被销毁之后，才被销毁。所以使用闭包会占用更多的内存！</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 迭代器&amp;生成器</title>
    <link href="/2022/05/13/%E5%89%8D%E7%AB%AF/JavaScript%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2022/05/13/%E5%89%8D%E7%AB%AF/JavaScript%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>迭代器与生成器</p><span id="more"></span><h2 id="JavaScript-迭代器-amp-生成器"><a href="#JavaScript-迭代器-amp-生成器" class="headerlink" title="JavaScript 迭代器&amp;生成器"></a>JavaScript 迭代器&amp;生成器</h2><h3 id="一、迭代器"><a href="#一、迭代器" class="headerlink" title="一、迭代器"></a>一、迭代器</h3><h4 id="1、迭代器模式"><a href="#1、迭代器模式" class="headerlink" title="1、迭代器模式"></a>1、迭代器模式</h4><p><strong>迭代器模式：</strong>通过原生语言结构，让用户无需知道如何迭代就能实现迭代操作。</p><p>迭代器模式（特别是在ECMAScript这个语境下）描述了一个方案，即可以把有些结构称为<strong>“可迭代对象”（iterable）</strong>，因为它们实现了正式的<strong>Iterable接口</strong>，而且可以通过<strong>迭代器Iterator</strong>消费。</p><p>每个迭代器都会关联一个可迭代对象，而迭代器会暴露迭代其关联可迭代对象的API。迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。这种概念上的分离正是Iterable和Iterator的强大之处</p><h4 id="2、iterable可迭代协议"><a href="#2、iterable可迭代协议" class="headerlink" title="2、iterable可迭代协议"></a>2、iterable可迭代协议</h4><p>实现<strong>Iterable接口</strong>（<strong>可迭代协议</strong>）要求同时具备两种能力：1、支持迭代的自我识别能力；2、创建实现Iterator接口的对象的能力。在ECMAScript中，这意味着必须暴露<strong>一个属性</strong>作为<strong>“默认迭代器”</strong>，而且这个属性必须使用特殊的<strong>Symbol.iterator作为键</strong>。这个默认属性会引用一个迭代器工厂函数，在需要的时候后台会调用这个工厂函数返回一个新的迭代器iterator</p><p>检查一个对象是否满足可迭代协议，可以通过查看默认迭代器属性<code>Symbol.iterator</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>num[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>];<span class="hljs-comment">//undefined</span><br>arr[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>];<span class="hljs-comment">//ƒ values() &#123; [native code] &#125;</span><br></code></pre></td></tr></table></figure><h4 id="3、iterator迭代器协议"><a href="#3、iterator迭代器协议" class="headerlink" title="3、iterator迭代器协议"></a>3、iterator迭代器协议</h4><p>iterator迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。不同迭代器的实例之间没有关联。</p><p>迭代器API使用next()方法遍历数据，next()方法每次返回一个<code>IteratorResult</code>对象，包含两个属性done和value。done是<code>boolean</code>类型，表示后面是否还有值；value表示返回的值。当遍历完毕后继续调用next()，会一直返回<code>&#123;done:false,value:undefined&#125;</code></p><p><strong>自定义一个迭代器实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//这个类实现了可迭代接口（Iterable）</span><br><span class="hljs-comment">//调用默认的迭代器工厂函数会返回，一个实现迭代器接口（Iterator）的迭代器对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&#123;<br>    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()&#123;<br>        <span class="hljs-keyword">return</span>&#123;<br>            <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>)&#123;<br>                <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">done</span>:<span class="hljs-literal">false</span>,<span class="hljs-attr">value</span>:<span class="hljs-string">&#x27;Foo&#x27;</span>&#125;;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();<br>f[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();<br></code></pre></td></tr></table></figure><h4 id="4、自定义迭代器"><a href="#4、自定义迭代器" class="headerlink" title="4、自定义迭代器"></a>4、自定义迭代器</h4><p>任何实现Iterator接口的对象都可以作为迭代器使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">limit</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">limit</span>=limit;<br>    &#125;<br>    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()&#123;<br>        <span class="hljs-keyword">let</span> count=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">let</span> limit = <span class="hljs-variable language_">this</span>.<span class="hljs-property">limit</span>;<br>        <span class="hljs-keyword">return</span>&#123;<br>            <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>)&#123;<br>                <span class="hljs-keyword">if</span>(count&lt;=limit)&#123;<span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">done</span>:<span class="hljs-literal">false</span>,<span class="hljs-attr">value</span>:count++&#125;;&#125;<br>                <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">done</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">value</span>:<span class="hljs-literal">undefined</span>&#125;;&#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> c)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);&#125;<br><span class="hljs-comment">// 1 2 3</span><br></code></pre></td></tr></table></figure><h3 id="二、生成器"><a href="#二、生成器" class="headerlink" title="二、生成器"></a>二、生成器</h3><h4 id="1、生成器定义"><a href="#1、生成器定义" class="headerlink" title="1、生成器定义"></a>1、生成器定义</h4><p><strong>生成器的形式</strong>是一个函数，函数名称前面加一个星号（＊）表示它是一个生成器。（注意 箭头函数不能用来定义生成器函数）</p><p>生成器对象实现了Iterable接口，它的默认迭代器iterator是自引用的（自己就是迭代器），具有next()方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title class_">Fn</span>()&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;start&#x27;</span>);<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-keyword">let</span> g = <span class="hljs-title class_">Fn</span>();<br>g === g[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();<span class="hljs-comment">//true</span><br>g.<span class="hljs-title function_">next</span>();<span class="hljs-comment">//start   &#123;value: 1, done: false&#125;</span><br>g.<span class="hljs-title function_">next</span>();<span class="hljs-comment">//&#123;value: 3, done: true&#125;</span><br>g.<span class="hljs-title function_">next</span>();<span class="hljs-comment">//&#123;value: undefined, done: true&#125;</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> <span class="hljs-title class_">Fn</span>())&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);&#125;<span class="hljs-comment">//start 1 </span><br><span class="hljs-comment">//不输出3，只打印done为false对应的值</span><br></code></pre></td></tr></table></figure><ul><li>定义生成器时不会立即执行，调用next()时才会开始执行</li><li>生成器函数遇到yield关键字之前会正常执行，遇到yield之后，执行停止。通过调用next()可以恢复继续执行</li></ul><h4 id="2、yield关键字"><a href="#2、yield关键字" class="headerlink" title="2、yield关键字"></a>2、yield关键字</h4><p><strong>当做可迭代对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title class_">Fn</span>()&#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> <span class="hljs-title class_">Fn</span>())&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);&#125;<br><span class="hljs-comment">// 1 2 3</span><br></code></pre></td></tr></table></figure><p><strong>使用yield实现输入输出</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title class_">Fn</span>(init)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(init);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">yield</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">yield</span>);<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Ob</span> = <span class="hljs-title class_">Fn</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-title class_">Ob</span>.<span class="hljs-title function_">next</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//1，第一次调用传入next的值没有被使用，因为这一次调用是为了开始执行生成器函数</span><br><span class="hljs-title class_">Ob</span>.<span class="hljs-title function_">next</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">//3</span><br><span class="hljs-title class_">Ob</span>.<span class="hljs-title function_">next</span>(<span class="hljs-number">4</span>);<span class="hljs-comment">//4</span><br><br><span class="hljs-keyword">function</span>* <span class="hljs-title class_">Fn</span>(init)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">yield</span> init;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Ob</span> = <span class="hljs-title class_">Fn</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-title class_">Ob</span>.<span class="hljs-title function_">next</span>();<span class="hljs-comment">//&#123;value: &#x27;1&#x27;, done: false&#125;</span><br><span class="hljs-title class_">Ob</span>.<span class="hljs-title function_">next</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//&#123;value: 2, done: true&#125;</span><br></code></pre></td></tr></table></figure><p><em><em>yield</em> 产生可迭代对象</em>*。yield＊实际上只是将一个可迭代对象序列化为一连串可以单独产出的值，所以这跟把yield放到一个循环里没什么不同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title class_">Fn</span>()&#123;<br>    <span class="hljs-keyword">yield</span>* [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">yield</span> * [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> <span class="hljs-title class_">Fn</span>())&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);&#125;<br><span class="hljs-comment">//1 2 3 4</span><br></code></pre></td></tr></table></figure><h4 id="3、生成器作为默认迭代器"><a href="#3、生成器作为默认迭代器" class="headerlink" title="3、生成器作为默认迭代器"></a>3、生成器作为默认迭代器</h4><p>因为生成器函数被调用之后产生迭代器，所以可以将生成器作为默认迭代器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//这个类的默认迭代器可以用一行代码输出类的内容</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>    &#125;<br>    * [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()&#123;<br>        <span class="hljs-keyword">yield</span>* <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> f)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);&#125;<br><span class="hljs-comment">//1 2 3</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 变量和语句</title>
    <link href="/2022/05/13/%E5%89%8D%E7%AB%AF/JavaScript%E5%8F%98%E9%87%8F%E5%92%8C%E8%AF%AD%E5%8F%A5/"/>
    <url>/2022/05/13/%E5%89%8D%E7%AB%AF/JavaScript%E5%8F%98%E9%87%8F%E5%92%8C%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>基本数据类型、变量、语句、执行上下文与作用域</p><span id="more"></span> <h2 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h2><h3 id="一、基本数据类型"><a href="#一、基本数据类型" class="headerlink" title="一、基本数据类型"></a>一、基本数据类型</h3><ul><li>number（数字），包括int、float、infinite、NaN，特殊<strong>NaN</strong>值，自己不等于自己，要通过isNaN()判断</li><li>string（字符串），可以用单引号、可以用双引号</li><li>boolean（布尔值），true和false</li><li>null（空值），表示空对象指针</li><li>undefined（未定义的值），表示未初始化的变量，用let和var声明但未赋值时，就是undefined</li><li>symbol（符号），是ES6新增的，符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险</li></ul><p>以上参考自《JavaScript高级程序设计》，注意：object不归为基本数据类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-number">123</span>; <span class="hljs-comment">// &#x27;number&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// &#x27;number&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;str&#x27;</span>; <span class="hljs-comment">// &#x27;string&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// &#x27;boolean&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// &#x27;undefined&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">abs</span>; <span class="hljs-comment">// &#x27;function&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// &#x27;object&#x27;</span><br><span class="hljs-keyword">typeof</span> []; <span class="hljs-comment">// &#x27;object&#x27;</span><br><span class="hljs-keyword">typeof</span> &#123;&#125;; <span class="hljs-comment">// &#x27;object&#x27;</span><br><span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span> <span class="hljs-comment">//true</span><br><span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span><span class="hljs-comment">//false</span><br><br><span class="hljs-keyword">let</span> sym = <span class="hljs-title class_">Symbol</span>();<span class="hljs-comment">//Symbol的定义方法，不能使用new关键字</span><br></code></pre></td></tr></table></figure><ul><li><p>Object类型</p><p>每个Object都有如下属性和方法：</p><ul><li>**toLocaleString()**：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境</li><li>**toString()**：返回对象的字符串表示</li><li>**valueOf()**：返回对象对应的字符串、数值或布尔值表示。通常与toString()的返回值相同</li><li><strong>constructor</strong>：用于创建当前对象的函数</li><li>hasOwnProperty（propertyName）：用于判断当前对象实例（不是原型）上是否存在给定的属性</li><li>isPrototypeOf（object）：用于判断当前对象是否为另一个对象的原型</li><li>propertyIsEnumerable(propertyName)：用于判断给定的属性是否可以使用for-in语句枚举</li></ul><p><strong>因为Object是所有对象的基类，所以任何对象都有以上这些属性和方法</strong></p></li></ul><p><strong>在这里着重探究String的一些性质与方法</strong></p><ul><li>不限单、双引号，如果字符串内部有引号，要加转义字符\作为前缀</li><li>多行字符串，一种方式是用\n换行，另一种是<strong>ES6新加</strong>的，反引号&#96;</li><li>字符串之间可以通过+拼接，也可以通过<code>反引号 hello $&#123;name&#125; 反引号</code>的方式插入字符串变量</li><li>s[0]这种赋值方式不起作用，不会改变字符串内容</li></ul><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>s.toUpperCase()<br />s.toLowerCase()</td><td>返回全部大写、小写</td></tr><tr><td>s.substring(start,end)<br />slice(start,end)、substr(start,end)</td><td>接受两个参数，表示截取的区间 [起点，终点），第二个参数可选，缺省默认为字符串结尾<br />返回一个新的字符串，截取后的字符串。substring将负数值视为0，slice和substr将负数视为从结尾开始倒数</td></tr><tr><td>s.indexOf(字符)、s.lastIndexOf(字符)</td><td>分别从字符串开头寻找字符、从字符串末尾开始寻找字符。它们都可以接受一个或者两个参数，第一个参数是寻找的字符，第二个参数是开始寻找的起点</td></tr><tr><td>startsWith(字符串)、endsWith((字符串)、includes((字符串)</td><td>接受一个字符串参数，返回boolean值，表示是否以指定字符串开始、结尾、或包含指定字符串</td></tr><tr><td>s.trim()<br />s.trimLeft()、s.trimRight()</td><td>返回去除头尾空格后的副本</td></tr><tr><td>s.repeat(数值)</td><td>将字符串复制xx次，返回复制后的副本</td></tr><tr><td>s.padStart(数值,字符串)<br />s.padEnd(数值,字符串)</td><td>第一个参数为填充的长度；第二个参数可选，为填充的字符或字符串；返回填充后的字符串<br />如果第一个参数比实际长度短，返回原字符串</td></tr><tr><td>s.match()</td><td>与RegExp对象的exec方法一样，接受一个正则表达式或者RegExp对象，返回一个Array数组</td></tr><tr><td>s.search()</td><td>接受正则表达式，返回第一个匹配的下标</td></tr><tr><td>s.replace(字符串,字符串)</td><td>第一个参数接受字符串、或者正则表达式，表示需要被替换的字符串，如果是字符串那么只替换第一个匹配项，如果要替换所有需要使用正则表达式且加上g标记<br />第二个参数接受字符串，表示替换后的字符串。<strong>第二个参数还可以接受一个函数用于处理</strong><br />返回一个新的替换后的字符串，原来的字符串不变</td></tr><tr><td>split()</td><td>第一个参数接受一个分割字符或者正则表达式，第二个参数可选，接受一个数字，限制返回数组的大小。返回值是一个分割后的字符串数组</td></tr></tbody></table><p>需要注意：以上的这些方法并非String原始值类型本身所有，而是在调用这些方法的时候，JavaScript会在后台自动完成String包装类型的创建、方法调用、包装对象销毁的一系列操作。</p><p>补充：JS中一个字符串中只有数字，如果该字符串前面加了个加号，这个数值就变成了number类型</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">“1”<span class="hljs-string">+1</span> :“11”<br>+“1”<span class="hljs-string">+1</span> :2 (+“1” 先变成了数字类型)<br>1+“1”:“11”<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;foo&quot;</span>;<br>str.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">6</span>);<span class="hljs-comment">//&#x27;   foo&#x27;</span><br>str.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;*&#x27;</span>)<span class="hljs-comment">//&#x27;***foo&#x27;</span><br>str.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;&amp;*&#x27;</span>)<span class="hljs-comment">//&#x27;&amp;*&amp;foo&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> message = <span class="hljs-string">&#x27;abcde&#x27;</span><br>[...message]<span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h3><h4 id="1、变量声明"><a href="#1、变量声明" class="headerlink" title="1、变量声明"></a>1、变量声明</h4><table><thead><tr><th></th><th>var</th><th>let</th><th>const</th></tr></thead><tbody><tr><td>版本支持</td><td>所有ES版本</td><td>ES6之后</td><td>ES6之后</td></tr><tr><td>声明作用域</td><td>函数作用域</td><td>块作用域</td><td>块作用域</td></tr><tr><td>变量声明提升</td><td>会</td><td>不会</td><td>不会</td></tr><tr><td>同一作用域内重复声明</td><td>允许</td><td>不允许</td><td>不允许</td></tr><tr><td></td><td></td><td></td><td>必须声明的同时初始化<br />不能声明迭代变量(如：for循环的i)</td></tr></tbody></table><h4 id="2、原始值-amp-引用值"><a href="#2、原始值-amp-引用值" class="headerlink" title="2、原始值&amp;引用值"></a>2、原始值&amp;引用值</h4><p>原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象。</p><p>JavaScript有<strong>6种原始值（基本数据类型）</strong>：Number、String、Boolean、Null、Undefined、Symbol。<strong>保存原始值的变量是按值访问的</strong></p><p>JavaScript不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。<strong>保存引用值的变量是按引用访问的</strong></p><h4 id="3、判断变量类型"><a href="#3、判断变量类型" class="headerlink" title="3、判断变量类型"></a>3、判断变量类型</h4><ul><li>typeof操作符，用来区分各种原始类型（string、number、boolean、undefined）</li><li>instanceof操作符，用来区分各种引用类型</li></ul><h3 id="三、语句"><a href="#三、语句" class="headerlink" title="三、语句"></a>三、语句</h3><blockquote> JavaScript的语句包括：if语句、while语句、do-while语句、for语句、for-in语句、for-of语句、标签语句、break和continue语句、with语句、switch语句，其中大多数语句与C++中的语法和使用一致。下面详细介绍一下for-in语句、for-of语句和with语句</blockquote><h4 id="1、for-in语句"><a href="#1、for-in语句" class="headerlink" title="1、for-in语句"></a>1、for-in语句</h4><p>for-in语句是一种严格的迭代语句，用于<strong>枚举对象中的非符号键属性</strong>，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(property <span class="hljs-keyword">in</span> expression) &#123;statement;&#125;<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> a) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a[i]); <span class="hljs-comment">// &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">var</span> person = &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;xiaoming&quot;</span>,<br><span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br><span class="hljs-keyword">for</span>(cosnt item <span class="hljs-keyword">in</span> person)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);    <span class="hljs-comment">// name age 而不是”xiaoming&quot; 18</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>注意：for-in遍历的数组的下标，而不是数组元素</strong></li></ul><h4 id="2、for-of语句"><a href="#2、for-of语句" class="headerlink" title="2、for-of语句"></a>2、for-of语句</h4><p>for-of语句是一种严格的迭代语句，用于<strong>遍历可迭代对象的元素</strong>，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(property <span class="hljs-keyword">of</span> expression) &#123;statement;&#125;<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> a) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// A B C，这里不能使用const声明i，使用const声明i会报错</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> i <span class="hljs-keyword">of</span> [<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>])&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// A B C，这里使用const声明i不会报错，因为迭代的是一个const数组</span><br>&#125;<br><br><span class="hljs-keyword">var</span> person = &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;xiaoming&quot;</span>,<br><span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> person)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);    <span class="hljs-comment">//抛出语法错误，因为person对象不是iterable类型，具体原因查看《迭代器和生成器》一节</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、with语句"><a href="#3、with语句" class="headerlink" title="3、with语句"></a>3、with语句</h4><p>with语句的用途是将代码作用域设置为特定的对象，其语法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">with</span>(<span class="hljs-params">expression</span>)&#123;statement;&#125;<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> qs = location.<span class="hljs-property">search</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">let</span> hostName = location.<span class="hljs-property">hostname</span>;<br><span class="hljs-keyword">let</span> url = location.<span class="hljs-property">href</span>;<br><br>改进为：<br><br><span class="hljs-title function_">with</span>(<span class="hljs-params">location</span>)&#123;<br>    <span class="hljs-keyword">let</span> qs = search.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">let</span> hostName = hostname;<br><span class="hljs-keyword">let</span> url = href;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、执行上下文与作用域"><a href="#四、执行上下文与作用域" class="headerlink" title="四、执行上下文与作用域"></a>四、执行上下文与作用域</h3><blockquote>变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variableobject），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它</blockquote><p>执行上下文主要有<strong>全局上下文</strong>和<strong>函数上下文</strong>两种</p><p>上下文中的代码在执行的时候，会创建变量对象的一个<strong>作用域链</strong>，它决定了各级上下文中的代码在访问变量和函数时的顺序。作用域链是按照”栈“LIFO的特性添加的，如下图是一个形象的作用域链表示</p><p><img src="/JavaScript%E5%8F%98%E9%87%8F%E5%92%8C%E8%AF%AD%E5%8F%A5.assets/image-20220510164738557.png" alt="image-20220510164738557"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构——链表</title>
    <link href="/2022/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>leetcode链表题库和牛客的题库</p><span id="more"></span><h2 id="数据结构——链表"><a href="#数据结构——链表" class="headerlink" title="数据结构——链表"></a>数据结构——链表</h2><h4 id="leetcode题库"><a href="#leetcode题库" class="headerlink" title="leetcode题库"></a>leetcode题库</h4><table><thead><tr><th>题目</th><th>描述</th></tr></thead><tbody><tr><td>2.两数相加（中等）</td><td>模拟，一个链表节点存一位数，两个链表相加</td></tr><tr><td>19.删除链表的倒数第N个节点（中等）</td><td>双指针，l和r指针保持n的距离，r指向链尾时，l就是要删除的前一位<br />或者用两遍扫描也可以。最好有delete操作</td></tr><tr><td>21.合并两个有序列表（简单）</td><td>迭代，“哨兵”结点preHead，简化链表的维护（只需要维护一个pre指针）</td></tr><tr><td>23.合并k个升序链表（困难）</td><td>方案一：顺序执行，不断调用【合并两个有序列表】，时间复杂度O(nm<sup>2</sup>)，其中n为lists长度，m为每个list的平均长度。顺序执行就是先合并1、2个list然后又成为第1个list，之后又不断合并第1、2个，直到所有合并完毕，访问list元素的次数是一个等差数列<br />方案二：分治，两两链表合并为一个链表，不断重复这个过程，直到最后只剩一个链表。时间复杂度O(nmlog<sub>n</sub>)，分治一共log<sub>n</sub>层，每层都要将所有list的元素访问一次，也就是nm。<br />方案三：优先队列，利用优先队列自动排序的特点（相当于堆），时间复杂度O(nmlog<sub>n</sub>)，优先队列每次插入删除的复杂度为O(log<sub>n</sub>)，一共要插入删除nm次。</td></tr><tr><td>24.两两交换链表中的节点（中等）</td><td>考验对链表操作的熟悉程度，滑动改变链表的指针指向</td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="牛客网"><a href="#牛客网" class="headerlink" title="牛客网"></a>牛客网</h4><p><strong>题单：</strong>模板速刷TOP101</p><table><thead><tr><th>题目</th><th>描述</th></tr></thead><tbody><tr><td><strong>BM1</strong> <strong>反转链表</strong></td><td>反转整个链表，错误教训：当链头变为链尾时，一定要将链头的next指向NULL</td></tr><tr><td><strong>BM2</strong> <strong>链表内指定区间反转</strong></td><td>巧妙利用“前哨”节点，让链头永远不变，避免分情况讨论的麻烦。巧妙利用一个temp指针，在区间内转换指针方向</td></tr><tr><td><strong>BM3</strong> <strong>链表中的节点每k个一组翻转</strong></td><td>BM2的反转方法巧妙高效，但不适用于这题，因为它的使用建立在反转区间在链表长度范围内的条件上。但是这题要求，最后长度不足k的区间，保持原样。所以这就要求需要先遍历链表，获取到长度为k的区间进行反转，长度不足k的区间不做改动。</td></tr><tr><td><strong>合并两个排序的链表</strong></td><td>“前哨”，递归做法和迭代做法</td></tr><tr><td><strong>合并k个已排序的链表</strong></td><td>递归分治，优先队列两种做法</td></tr><tr><td><strong>BM6</strong> <strong>判断链表中是否有环</strong></td><td>快慢指针，如果链表有环，那么环一定出现在链尾，也就意味着链表没有NULL，只要设置一快一满两个指针，就一定会相遇（快的每次走两步，满的每次走一步）</td></tr><tr><td><strong>BM7</strong> <strong>链表中环的入口结点</strong></td><td>BM6的进阶，首先判断链表是否有环。如果有环，首先了解一个特点，快指针走的步数是慢指针的两倍。<br />假设链头到环入口的距离为x，环入口距离相遇点的距离为y，相遇点向后到环入口的距离为z，<br />且假设快指针在环里转了a圈，慢指针在环里转了b圈。那么就有 x+y+a(y+z) &#x3D; 2[x+y+b(y+z)]，<br />整理一下得到：(a-2b)(y+z)&#x3D;x+y，代表的含义是：从相遇点出发，一个指针在环里转若干圈，<br />另一个指针从头开始，最终会在原来的相遇点再次相遇；那么在相遇之前，从环入口到相遇点这段路程两个指针是重叠的，由此可以得出两个指针第一个重叠的地方就是环入口。</td></tr><tr><td><strong>BM8</strong> <strong>链表中倒数最后k个结点</strong></td><td>双指针，前后指针，间隔k步</td></tr><tr><td><strong>BM9</strong> <strong>删除链表的倒数第n个节点</strong></td><td>双指针，前后指针，“前哨”结点是处理很多链表问题的很好的技巧</td></tr><tr><td><strong>BM10</strong> <strong>两个链表的第一个公共结点</strong></td><td>双指针，获取链表长度，长的先走，让两条链距离公共点的起点相同</td></tr><tr><td><strong>BM11</strong> <strong>链表相加(二)</strong></td><td>反转链表 + 模拟加法 + 反转链表</td></tr><tr><td><strong>BM12</strong> <strong>单链表的排序</strong></td><td>BM4合并两个有序链表，链表的归并排序，左边界是链表起点，右边界是NULL<br /><strong>递归三要素：终止条件、返回值、本级任务</strong></td></tr><tr><td><strong>BM13</strong> <strong>判断一个链表是否为回文结构</strong></td><td>抓住关键：前序和后序一致即为回文，可以用头插法new一个逆序链表，可以用栈，可以保存到数组中用前后对撞指针</td></tr><tr><td><strong>BM14</strong> <strong>链表的奇偶重排</strong></td><td>一共就两种情况，奇数个节点或者偶数个节点，只要把两种情况的处理方式综合考虑进来，理清逻辑，就很容易解决了。</td></tr><tr><td><strong>BM15</strong> <strong>删除有序链表中重复的元素-I</strong></td><td>前后指针pre和cur</td></tr><tr><td><strong>BM16</strong> <strong>删除有序链表中重复的元素-II</strong></td><td>与BM15相比，难度提升在于，BM15保留了一个重复元素，而这里要把所有都删除，所以需要增加一个指针记录重复元素前一位的元素，用了三个指针pre、cur和nex，函数体里面分为两部分，一个是删除部分，与之对立的是指针前进部分<br />拓展：如果链表是无序的，则使用哈希表map，统计每个节点值出现的次数</td></tr></tbody></table><p><strong>小结</strong></p><ul><li>链表主要考察点有：一、对链表指针的修改，如反转、删除、合并、分离等等。二、对链表性质的考察，如判断链表是否有环、寻找链表环入口、寻找链表之间的公共节点等等。</li><li>链表题中常用的技巧有：双指针、前哨节点</li><li>双指针，又可以分为：快慢指针、前后指针、两条链各一个指针。指针的方向可以是同向间隔k步，同向速度不同、反向</li><li>前哨节点，涉及到链头可能变动时，增加前哨节点可以减少讨论的情况</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript异步编程</title>
    <link href="/2022/04/18/%E5%89%8D%E7%AB%AF/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/04/18/%E5%89%8D%E7%AB%AF/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>了解Promise、以及它的用法</p><span id="more"></span><h2 id="了解Promise对象"><a href="#了解Promise对象" class="headerlink" title="了解Promise对象"></a>了解Promise对象</h2><p>Promise是处理异步的对象，在正式了解Promise之前，让我们来回顾一下JS曾经的异步编程模式。在此之前，还是要先介绍一下setTimeout方法，它经常被用来模拟异步过程。</p><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>属于 window 的方法，该方法用于在指定的毫秒数后调用函数或计算表达式。</p><p><strong>语法：</strong><code>[]</code>表示可选参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> timeoutID = scope.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> [, delay, arg1, arg2, ...]);<br><span class="hljs-keyword">var</span> timeoutID = scope.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> [, delay]);<br><span class="hljs-keyword">var</span> timeoutID = scope.<span class="hljs-built_in">setTimeout</span>(code [, delay]);<br></code></pre></td></tr></table></figure><ul><li>function，想要在到期时间(<code>delay</code>毫秒)之后执行的函数</li><li>delay，延迟的毫秒数 (一秒等于1000毫秒)，如果省略，默认为0，表示“马上”执行，<strong>但实际上延迟时间可能比delay的值要长</strong></li><li>arg1, arg2, …，它们将作为参数传递给function</li><li>code，使用字符串而不是function，<strong>不推荐使用</strong></li></ul><p><strong>返回值：</strong><code>timeoutID</code>，是一个正整数，表示定时器的编号，可以传递给<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/clearTimeout"><code>clearTimeout()</code></a>来取消该定时器</p><p><strong>例子：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> timeoutID;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">delayedAlert</span>(<span class="hljs-params"></span>)&#123;timeoutID = <span class="hljs-built_in">setTimeout</span>(slowAlert,<span class="hljs-number">200</span>);&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">slowAlert</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">clearAlert</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">window</span>.<span class="hljs-built_in">clearTimeout</span>(timeoutID);&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">double</span>(<span class="hljs-params">value</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>,<span class="hljs-number">0</span>,value*<span class="hljs-number">2</span>),<span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-title function_">double</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h3 id="以往的异步编程模式"><a href="#以往的异步编程模式" class="headerlink" title="以往的异步编程模式"></a>以往的异步编程模式</h3><p>setTimeout模拟一个异步的操作，假设这个异步操作会返回一个有用的值，那么需要想办法将这个值传到需要它的地方，广泛接受的一个策略是【传入式回调】：给异步（即setTimeout）提供一个回调（callback），回调中包含要用到异步返回值的代码（value*2），作为回调的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">double</span>(<span class="hljs-params">value,callback</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">callback</span>(value*<span class="hljs-number">2</span>),<span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-title function_">double</span>(<span class="hljs-number">3</span>,<span class="hljs-function">(<span class="hljs-params">x</span>)=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x));<br><span class="hljs-comment">//6 （大约1秒后输出）</span><br></code></pre></td></tr></table></figure><p><strong>失败处理</strong>，异步操作的失败处理也要考虑在回调模型中，因此回调包括了<strong>成功回调</strong>和<strong>失败回调</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//声明：以下这种方式已经不可取了，这里只是作为展示用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">double</span>(<span class="hljs-params">value,success,failure</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">&#x27;number&#x27;</span>)&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;must provide number&#x27;</span><br>            &#125;<br>            <span class="hljs-title function_">success</span>(value*<span class="hljs-number">2</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>            <span class="hljs-title function_">failure</span>(e);<br>        &#125;<br>    &#125;,<span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">successCallback</span> = (<span class="hljs-params">x</span>)=&gt;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Success:<span class="hljs-subst">$&#123;x&#125;</span>`</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">failureCallback</span> = (<span class="hljs-params">x</span>)=&gt;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Fail:<span class="hljs-subst">$&#123;x&#125;</span>`</span>);<br><span class="hljs-title function_">double</span>(<span class="hljs-number">3</span>,successCallback,failureCallback);<br></code></pre></td></tr></table></figure><p>这种方式已经不可取了，因为它必须在初始化异步操作时定义回调。异步函数的返回值只在短时间内存在，只有预备好将这个短时间内存在的值作为参数的回调才能接收到它</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="为什么要用Promise"><a href="#为什么要用Promise" class="headerlink" title="为什么要用Promise"></a><strong>为什么要用Promise</strong></h4><ul><li><strong>用Promise指定回调函数的方式更加灵活</strong>。Promise之前必须在启动异步任务的同时指定回调函数（如上）；Promise能够先启动异步任务，然后返回Promise对象，再给这个Promise对象绑定回调函数</li><li>支持链式调用，<strong>解决“回调地狱”问题</strong></li></ul><h4 id="构造器语法"><a href="#构造器语法" class="headerlink" title="构造器语法"></a>构造器语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(executor)<br></code></pre></td></tr></table></figure><ul><li><p>executor，该函数将在构造这个新<code>Promise</code>对象过程中，被构造函数执行。<code>executor</code>的函数签名应为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolutionFunc,rejectionFunc</span>)&#123;<br>...<span class="hljs-comment">//通常是一些异步操作</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>resolutionFunc</code>和<code>rejectionFunc</code>也是函数，可以使用任何名字，这两个函数接受任何类型的单个参数。该<code>resolutionFunc</code>的<code>value</code>参数可能是另一个promise对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">resolutionFunc</span>(value)<span class="hljs-comment">//当resolved时调用</span><br><span class="hljs-title function_">rejectionFunc</span>(reason)<span class="hljs-comment">//当reject时调用</span><br></code></pre></td></tr></table></figure></li><li><p>如果在该<code>executor</code>中抛出一个错误，该promise将被拒绝</p></li><li><p>异步调用的流程可以总结如下：</p><ol><li>executor内执行异步操作，并提供一个回调</li><li>回调通过调用<code>resolutionFunc</code>终止，<code>resolutionFunc</code>的调用包含一个<code>value</code>参数</li><li>该<code>value</code>被返回到绑定的<code>Promise</code>对象上</li><li>该<code>Promise</code>对象调用<code>.then(handleResolved)</code></li><li><code>.then(handleResolved)</code>收到<code>value</code>作为参数传递给<code>handleResolved</code>进行使用</li></ol></li><li><p><strong>返回值</strong>，通过<code>new</code>调用时，<code>Promise</code>构造函数返回一个promise对象</p></li></ul><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<span class="hljs-comment">//1) 创建Promise对象，指定执行器executor函数</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">//2) 在执行器函数中，启动异步任务</span><br><span class="hljs-keyword">const</span> time = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>        <span class="hljs-keyword">if</span>(time%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//3)根据结果做不同的处理</span><br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;成功 &quot;</span>+time);<span class="hljs-comment">//成功，调用resolve()，指定成功的value，同时Promise变为resolved状态</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;失败 &quot;</span>+time);<span class="hljs-comment">//失败，调用reject(),指定失败的reason，同时Promise变为rejected状态</span><br>        &#125;<br>    &#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br>p.<span class="hljs-title function_">then</span>(<span class="hljs-comment">//指定Promise对象的回调函数，有两个参数</span><br>    <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;成功，value:&quot;</span>,value);&#125;,<span class="hljs-comment">//成功的回调函数，onResolved，得到成功返回的value</span><br>    <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;失败，reason:&quot;</span>,reason);&#125;<span class="hljs-comment">//失败的回调函数，onRejected，得到失败的reason</span><br>);<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);&#125;);<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 输出:1 3 2</span><br></code></pre></td></tr></table></figure><p><strong>从上面的例子看出，new Promise的执行器函数是立即执行的</strong></p><h4 id="Promise状态"><a href="#Promise状态" class="headerlink" title="Promise状态"></a><strong>Promise状态</strong></h4><p>有3种状态：</p><ul><li>待定，pending</li><li>解决，fulfilled（或者是 resolved）</li><li>拒绝，rejected</li></ul><p><strong>pending</strong>是初始状态，可以转换为<strong>resolved</strong>或者<strong>rejected</strong>，一旦转换就不能再改变。</p><p><strong>resolved</strong>状态表示已经完成，只要状态切换到resolved，就会有一个私有的内部值 <strong>value</strong></p><p><strong>rejected</strong>状态表示没有成功完成，只要状态切换到rejected，就会有一个私有的内部理由 <strong>reason</strong></p><h4 id="通过函数控制Promise状态"><a href="#通过函数控制Promise状态" class="headerlink" title="通过函数控制Promise状态"></a><strong>通过函数控制Promise状态</strong></h4><p>Promise的状态是私有的，只能在Promise的执行器函数中改变。执行器函数主要两项功能：<strong>初始化Promise的异步行为</strong>、<strong>控制状态的最终转换</strong>。控制转换是通过调用它的两个函数参数实现的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<span class="hljs-comment">//resolve和reject的名字是没有限制的，也可以取其它名字</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">//setTimeout模拟异步操作</span><br>        <span class="hljs-keyword">const</span> time=<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>        <span class="hljs-keyword">if</span>(time%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;成功&quot;</span>+time);&#125;<span class="hljs-comment">//resolve()将状态从pending转为resolved</span><br>        <span class="hljs-keyword">else</span> &#123;<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;失败&quot;</span>+time);&#125;<span class="hljs-comment">//reject()将状态从pending转为rejected</span><br>    &#125;,<span class="hljs-number">1000</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>状态改变是不可逆的</strong>，这意味着第一次之后（不包括第一次）调用的resolve或reject都不再改变Promise的状态。</p><h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4><p>期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用Promise.resolve()静态方法，可以实例化一个解决的期约</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span><span class="hljs-title function_">resolve</span>());<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();<br></code></pre></td></tr></table></figure><p><em>这两个Promise实例实际上状态是一样的。</em></p><p><code>Promise.resolve()</code>可以把任何值都转换为一个Promise，<strong>它只对第一个参数起作用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();<span class="hljs-comment">//Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">//Promise &#123;&lt;fulfilled&gt;: 3&#125;</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//Promise &#123;&lt;fulfilled&gt;: 4&#125;</span><br></code></pre></td></tr></table></figure><p>如果传入的参数是一个Promise，那么它相当于空包装（没有变化），因此<strong>resolve是一种幂等方法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">7</span>);<br>p === <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p)<span class="hljs-comment">//true</span><br>p === <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p))<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span><span class="hljs-title function_">reject</span>());<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>();<br></code></pre></td></tr></table></figure><p><em>这两个Promise实例实际上状态是一样的。</em></p><p><code>Promise.reject()</code>会实例化一个拒绝的Promise并抛出一个异步错误（<strong>这个错误只能通过reject处理程序捕获</strong>），<code>reject()</code>的第一个参数就是拒绝的<code>reason</code>，它会传给后续的处理程序。<code>reject</code> <strong>不是幂等的</strong>，传给它一个Promise对象，会被当成它返回的<code>reason</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-number">3</span>);<span class="hljs-comment">//报出一个 Uncaught(in promise)</span><br>p <span class="hljs-comment">//Promise &#123;&lt;rejected&gt;: 3&#125;</span><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(p);<span class="hljs-comment">//Uncaught (in promise)</span><br>p1<span class="hljs-comment">//Promise &#123;&lt;rejected&gt;: Promise&#125;</span><br></code></pre></td></tr></table></figure><p><em>p作为一个Promise对象整体 变成了reason参数</em></p><p><strong>怎么通过reject处理程序捕获？？</strong></p><h3 id="Promise的实例方法"><a href="#Promise的实例方法" class="headerlink" title="Promise的实例方法"></a>Promise的实例方法</h3><p>实例方法是连接同步代码和异步代码之间的途径，通过实例方法可以访问异步返回的数据，处理resolve或reject的结果，连续对Promise求值，添加Promise终止后的处理逻辑。<strong>实例方法包括：</strong></p><ul><li>then</li><li>catch</li><li>finally</li></ul><h4 id="then"><a href="#then" class="headerlink" title="then()"></a><strong>then()</strong></h4><p><code>Promise.prototype.then()</code>是为Promise实例添加处理程序的主要方法，它<strong>最多接受两个参数：onResolved处理程序</strong>和<strong>onRejected处理程序</strong>，这两个参数都是可选的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span><span class="hljs-built_in">setTimeout</span>(resolve,<span class="hljs-number">1000</span>));<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span><span class="hljs-built_in">setTimeout</span>(reject,<span class="hljs-number">1000</span>));<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">onResolved</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot; resolved&quot;</span>);&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">onRejected</span>(<span class="hljs-params">id</span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id+<span class="hljs-string">&quot; rejected&quot;</span>);&#125;<br><br>p1.<span class="hljs-title function_">then</span>(onResolved,<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">onRejected</span>(<span class="hljs-string">&#x27;p1&#x27;</span>));<span class="hljs-comment">//resolved</span><br>p2.<span class="hljs-title function_">then</span>(onResolved,<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">onRejected</span>(<span class="hljs-string">&#x27;p2&#x27;</span>));<span class="hljs-comment">//p2 rejected 和上面的同时输出</span><br>p1.<span class="hljs-title function_">then</span>(onResolved);<span class="hljs-comment">//resolved</span><br>p2.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>,<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">onRejected</span>(<span class="hljs-string">&#x27;p2&#x27;</span>));<span class="hljs-comment">//p2 rejected</span><br></code></pre></td></tr></table></figure><p>传给then()的任何非函数类型的参数都会被静默忽略。如果想只提供<code>onRejected</code>参数，那就要在<code>onResolved</code>参数的位置上传入<code>null</code>。</p><p><strong>then方法返回一个新的Promise实例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;);<br><span class="hljs-keyword">let</span> p2 = p1.<span class="hljs-title function_">then</span>();<br>p1 === p2<span class="hljs-comment">//false</span><br>p2<span class="hljs-comment">//Promise &lt;pending&gt; : undefined</span><br></code></pre></td></tr></table></figure><p>实际上，<strong>这个实例基于onResolved处理程序的返回值构建</strong> <em>这个onResolved处理程序指的是p.then(onResolvedFunc,onRejectedFunc)里的onResolvedFunc</em>，该处理程序的返回值会被<code>Promise.resolve()</code>包装成一个新的Promise实例，如果没有提供这个处理程序，<code>Promise.resolve()</code>会包装上一个<code>Promise</code>解决之后的值；如果没有返回语句，则会包装默认的<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<span class="hljs-comment">//Promise &#123;&lt;fulfilled&gt;: &#x27;foo&#x27;&#125;</span><br><span class="hljs-keyword">let</span> p2 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-string">&#x27;bar&#x27;</span>);<span class="hljs-comment">//Promise &#123;&lt;fulfilled&gt;: &#x27;bar&#x27;&#125;</span><br><br><span class="hljs-keyword">let</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();<span class="hljs-comment">//Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span><br><span class="hljs-keyword">let</span> p4 = p3.<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-string">&#x27;bar&#x27;</span>);<span class="hljs-comment">//Promise &#123;&lt;fulfilled&gt;: &#x27;bar&#x27;&#125;</span><br><br><span class="hljs-keyword">let</span> p5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;);<span class="hljs-comment">//Promise &#123;&lt;pending&gt;: undefined&#125;</span><br><span class="hljs-keyword">let</span> p6 = p5.<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-string">&#x27;bar&#x27;</span>);<span class="hljs-comment">//Promise &#123;&lt;pending&gt;: undefined&#125;，父Promise状态是pending，表现为对父级的传递</span><br>p5 === p6<span class="hljs-comment">//false，虽然p5和p6看起来相等，但是它们并不是同一个对象</span><br><br><span class="hljs-keyword">let</span> p7 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;err&#x27;</span>&#125;);<span class="hljs-comment">//报出：Uncaught (in promise) err</span><br>p7<span class="hljs-comment">//Promise &#123;&lt;rejected&gt;: &#x27;err&#x27;&#125;，抛出异常，会返回拒绝的Promise</span><br><br><span class="hljs-keyword">let</span> p8 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;));<span class="hljs-comment">//Promise &#123;&lt;pending&gt;: undefined&#125;</span><br><span class="hljs-keyword">let</span> p9 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>());<span class="hljs-comment">//Promise &#123;&lt;rejected&gt;: undefined&#125;</span><br></code></pre></td></tr></table></figure><p><strong>补充：</strong></p><ul><li>如果父级Promise的状态为pending，那么.then返回的新Promise实例表现为对父级的继承，值并不会改变（和父级相同）</li><li>抛出异常，会返回拒绝的Promise</li><li>上面探讨的是Resolved状态下then的返回值，下面再探讨Rejected状态下then的返回值</li></ul><p><code>onRejectedFunc</code>返回的值也会被<code>Promise.resolve()</code>包装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<span class="hljs-comment">//Promise &#123;&lt;rejected&gt;: &#x27;foo&#x27;&#125;</span><br><span class="hljs-keyword">let</span> p2 = p1.<span class="hljs-title function_">then</span>();<span class="hljs-comment">//Promise &#123;&lt;rejected&gt;: &#x27;foo&#x27;&#125;</span><br><span class="hljs-keyword">let</span> p3 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>,<span class="hljs-function">()=&gt;</span>&#123;&#125;);<span class="hljs-comment">//Promise &#123;&lt;fulfilled&gt;: undefined&#125;，注意状态的变化！！</span><br><span class="hljs-keyword">let</span> p4 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>,<span class="hljs-function">()=&gt;</span><span class="hljs-string">&#x27;bar&#x27;</span>);<span class="hljs-comment">//Promise &#123;&lt;fulfilled&gt;: &#x27;bar&#x27;&#125;</span><br><span class="hljs-keyword">let</span> p5 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>,<span class="hljs-function">()=&gt;</span><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;bar&#x27;</span>));<span class="hljs-comment">//Promise &#123;&lt;fulfilled&gt;: &#x27;bar&#x27;&#125;,和上一行代码实质上是一样的</span><br><span class="hljs-keyword">let</span> p6 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>,<span class="hljs-function">()=&gt;</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;));<span class="hljs-comment">//Promise &#123;&lt;pending&gt;: undefined&#125;</span><br><span class="hljs-keyword">let</span> p7 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>,<span class="hljs-function">()=&gt;</span><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>());<span class="hljs-comment">//Promise &#123;&lt;rejected&gt;: undefined&#125;</span><br><span class="hljs-keyword">let</span> p8 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>,<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;err&#x27;</span>&#125;);<span class="hljs-comment">//Promise &#123;&lt;rejected&gt;: &#x27;err&#x27;&#125;</span><br><span class="hljs-keyword">let</span> p9 = p1.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>,<span class="hljs-function">()=&gt;</span><span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;qux&#x27;</span>));<span class="hljs-comment">//Promise &#123;&lt;fulfilled&gt;: Error: qux</span><br></code></pre></td></tr></table></figure><p><strong>解析：</strong></p><ul><li>p3-p4，都是onRejected处理程序的返回值被Promise.resolve()包装，所以返回的Promise状态都是resolved，值是对应处理程序的返回值</li><li>p5-p7，是一个拒绝的Promise实例对象被Promise.resolve()包装，因为传入的Promise，所以resolve相当于空包装</li><li>p8，抛出异常，返回拒绝的Promise实例对象</li><li>p9，返回错误值，不会触发拒绝行为，错误对象被包装到resolved的Promise实例对象中</li></ul><h4 id="catch"><a href="#catch" class="headerlink" title="catch()"></a><strong>catch()</strong></h4><p><code>Promise.prototype.catch()</code>方法用于给期约添加拒绝处理程序。这个方法只接收一个参数：<code>onRejected处理程序</code>。事实上，这个方法就是一个语法糖，调用它就相当于调用<code>Promise.prototype. then(null, onRejected)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>();<br><span class="hljs-keyword">let</span> onRejected = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>);&#125;<br>p.<span class="hljs-title function_">catch</span>(onRejected);<span class="hljs-comment">//相当于p.then(null,onRejected);</span><br><span class="hljs-comment">//输出：rejected，它还返回一个新的Promise对象，Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span><br></code></pre></td></tr></table></figure><p><strong>返回值：</strong>在返回新Promise实例方面，<code>Promise.prototype.catch()</code>的行为与<code>Promise.prototype.then()</code>的<code>onRejected</code>处理程序是一样的</p><h4 id="finally"><a href="#finally" class="headerlink" title="finally()"></a><strong>finally()</strong></h4><p><code>Promise.prototype.finally()</code>方法用于给期约添加<code>onFinally</code>处理程序，这个处理程序在期约转换为解决或拒绝状态时都会执行。这个方法可以避免<code>onResolved</code>和<code>onRejected</code>处理程序中出现冗余代码。但<code>onFinally</code>处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用于添加清理代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>();<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">onFinally</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Finally&#x27;</span>);&#125;<br>p1.<span class="hljs-title function_">finally</span>(onFinally);<span class="hljs-comment">//输出：Finally，返回一个Promise对象：Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span><br>p2.<span class="hljs-title function_">finally</span>(onFinally);<span class="hljs-comment">//输出：Finally，返回一个Promise对象：Promise &#123;&lt;rejected&gt;: undefined&#125;</span><br></code></pre></td></tr></table></figure><p><strong>返回值：一个新的Promise实例</strong>，大多数情况下，表现为对父级Promise的传递，对于解决和拒绝状态都是，不会被改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);<br><span class="hljs-keyword">let</span> p3 = p1.<span class="hljs-title function_">finally</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-string">&#x27;qux&#x27;</span>);<span class="hljs-comment">//Promise &#123;&lt;fulfilled&gt;: &#x27;foo&#x27;&#125;</span><br><span class="hljs-keyword">let</span> p4 = p2.<span class="hljs-title function_">finally</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;err&#x27;</span>&#125;);<span class="hljs-comment">//Promise &#123;&lt;rejected&gt;: &#x27;err&#x27;&#125;看来这个不包括在“大多数情况”内</span><br><span class="hljs-keyword">let</span> p5 = p2.<span class="hljs-title function_">finally</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-string">&#x27;qux&#x27;</span>);<span class="hljs-comment">//Promise &#123;&lt;rejected&gt;: &#x27;bar&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><ul><li>同步代码  先于  异步代码，这个特性《JavaScript高级程序设计》把它叫做<strong>“非重入Promise方法”</strong>。当Promise状态转换之后，与该状态相关的处理程序只是被 <strong>排期（推进消息队列）</strong>，而非立即执行。跟在处理程序之后的同步代码一定会先被执行</li><li>异步代码之间按照插入顺序执行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();<br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;onResolved&#x27;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;then() return&#x27;</span>);<br><span class="hljs-comment">//实际输出：</span><br><span class="hljs-comment">//then() return</span><br><span class="hljs-comment">//onResolved</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Resolve</span>;<br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;<br>    <span class="hljs-title class_">Resolve</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        <span class="hljs-title function_">resolve</span>();<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>);<br>    &#125;<br>&#125;)<br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3&#x27;</span>));<br><span class="hljs-title class_">Resolve</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;4&#x27;</span>);<br><span class="hljs-comment">//输出顺序： 1 2 4 3</span><br><span class="hljs-comment">//调用Resolve()之后，p的状态由pending转为resolved，与onResolved相关的处理程序（即then()）只是被推入消息队列，等到后面的同步代码执行完毕之后，才执行。</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Resolve</span>;<br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;<br>    <span class="hljs-title class_">Resolve</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>        <span class="hljs-title function_">resolve</span>();<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>);<br>    &#125;<br>&#125;)<br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3&#x27;</span>));<br><span class="hljs-title class_">Resolve</span>();<br><span class="hljs-comment">//输出：1 2 3</span><br></code></pre></td></tr></table></figure><h4 id="传递value和reason"><a href="#传递value和reason" class="headerlink" title="传递value和reason"></a>传递value和reason</h4><p>Promise状态发生改变之后，又称为<strong>“落定 settle”</strong>，Promise会提供值（调用resolve()，pending-&gt;resolved）或拒绝理由（调用reject()，pending-&gt;rejected）给相关的处理程序。</p><p><code>value</code>或者<code>reason</code>是通过<code>resolve()</code>或<code>reject()</code>的参数传递的，这也是它们唯一的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>p1.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value));<span class="hljs-comment">//foo</span><br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span><span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;bar&#x27;</span>));<br>p2.<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason));<span class="hljs-comment">//bar</span><br></code></pre></td></tr></table></figure><h4 id="拒绝Promise与错误处理"><a href="#拒绝Promise与错误处理" class="headerlink" title="拒绝Promise与错误处理"></a>拒绝Promise与错误处理</h4><p>在Promise的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span><span class="hljs-title function_">reject</span>(<span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)));<span class="hljs-comment">//在执行函数中抛出错误</span><br><span class="hljs-keyword">let</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;foo&#x27;</span>));<span class="hljs-comment">//在执行函数中抛出错误</span><br><span class="hljs-keyword">let</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<span class="hljs-keyword">throw</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)&#125;);<span class="hljs-comment">//在执行函数中抛出错误</span><br><span class="hljs-keyword">let</span> p4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-keyword">throw</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)&#125;);<span class="hljs-comment">//在处理程序中抛出错误</span><br>p1<span class="hljs-comment">//Promise &#123;&lt;rejected&gt;: Error: foo at &lt;anonymous&gt;:1:47 at new Promise (&lt;anonymous&gt;) at &lt;anonymous&gt;:1:10&#125;</span><br>p2<span class="hljs-comment">//Promise &#123;&lt;rejected&gt;: Error: foo at &lt;anonymous&gt;:2:25&#125;</span><br>p3<span class="hljs-comment">//Promise &#123;&lt;rejected&gt;: &#x27;foo&#x27;&#125;</span><br>p4<span class="hljs-comment">//Promise &#123;&lt;rejected&gt;: &#x27;foo&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>Promise可以使用任何理由拒绝，但是最好使用统一的Error对象，因为可以捕获错误对象中的栈追踪信息，便于调试</p><h3 id="Promise组合"><a href="#Promise组合" class="headerlink" title="Promise组合"></a>Promise组合</h3><h4 id="Promise连锁"><a href="#Promise连锁" class="headerlink" title="Promise连锁"></a>Promise连锁</h4><p>Promise连锁，又可以叫做“链式调用”，指的是一个接一个Promise的拼接。可以这样实现的原理是每个Promise执行器（then、catch、finally）都返回一个Promise实例，每个实例又有自己的实例方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;p1 executor&#x27;</span>);<br>    <span class="hljs-built_in">setTimeout</span>(resolve,<span class="hljs-number">3000</span>);<br>&#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;p2 executor&#x27;</span>);<br>    <span class="hljs-built_in">setTimeout</span>(resolve,<span class="hljs-number">3000</span>);<br>&#125;)&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;p3 executor&#x27;</span>);<br>    <span class="hljs-built_in">setTimeout</span>(resolve,<span class="hljs-number">3000</span>);<br>&#125;)&#125;)<br>p1 executor<span class="hljs-comment">//立马输出</span><br>p2 executor<br>p3 executor<span class="hljs-comment">//大约3秒后两行一起输出</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">delayResolve</span>(<span class="hljs-params">str</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br>        <span class="hljs-built_in">setTimeout</span>(resolve,<span class="hljs-number">3000</span>);<br>    &#125;);<br>&#125;<br><span class="hljs-title function_">delayResolve</span>(<span class="hljs-string">&#x27;p1 executor&#x27;</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-title function_">delayResolve</span>(<span class="hljs-string">&#x27;p2 executor&#x27;</span>)&#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-title function_">delayResolve</span>(<span class="hljs-string">&#x27;p3 executor&#x27;</span>)&#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-title function_">delayResolve</span>(<span class="hljs-string">&#x27;p4 executor&#x27;</span>)&#125;)<br>p1 executor<span class="hljs-comment">//立马输出</span><br>p2 executor<br>p3 executor<br>p4 executor<span class="hljs-comment">//大约3秒后三行一起输出</span><br></code></pre></td></tr></table></figure><p>实际测试结果与《JavaScript高级程序设计》里面不一样</p><h4 id="Promise合成"><a href="#Promise合成" class="headerlink" title="Promise合成"></a>Promise合成</h4><p>Promise类提供两个将多个期约实例组合成一个期约的静态方法：<code>Promise.all()</code>和<code>Promise.race()</code></p><p><strong>Promise.all()</strong></p><p>Promise.all()静态方法创建的期约会在一组期约全部解决之后再解决。这个静态方法接收一个可迭代对象，返回一个新期约</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Promise</span>,<span class="hljs-title function_">all</span>([<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(),<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>]);<br></code></pre></td></tr></table></figure><p><strong>Promise.all()的状态覆盖</strong>：rejected &gt; pending &gt; resolved</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;),<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(),<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>])<br>p<span class="hljs-comment">//Promise &#123;&lt;rejected&gt;: undefined&#125;</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">()=&gt;</span>&#123;&#125;),<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>])<br>p<span class="hljs-comment">//Promise &#123;&lt;pending&gt;&#125;</span><br></code></pre></td></tr></table></figure><p><strong>Promise.all的返回值：</strong>前提是所有Promise都resolve，返回值是按照传入Promise顺序的一个数组。如果有reject，第一个reason成为返回Promise的reason，后面reason的不记录，不过，这并不影响所有包含期约正常的拒绝操作。合成的期约会静默处理所有包含期约的拒绝操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>),<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(),<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>)<br>])<br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">values</span>)=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values));<span class="hljs-comment">// [1, undefined, 3]</span><br></code></pre></td></tr></table></figure><p><strong>Promise.race()</strong></p><p>返回一组集合中最先落定的Promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>),<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(),<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>)<br>])<br></code></pre></td></tr></table></figure><p>不会对解决或拒绝的期约区别对待。无论是解决还是拒绝，只要是第一个落定的期约，Promise.race()就会包装其解决值或拒绝理由并返回新期约</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异步编程</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发——JS（四）</title>
    <link href="/2022/04/16/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94JS%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2022/04/16/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94JS%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>AJAX、Promise、Canvas</p><span id="more"></span><h2 id="前端开发——JS（四）"><a href="#前端开发——JS（四）" class="headerlink" title="前端开发——JS（四）"></a>前端开发——JS（四）</h2><h3 id="一、AJAX"><a href="#一、AJAX" class="headerlink" title="一、AJAX"></a>一、AJAX</h3><p>Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求</p><p><strong>Web运行的原理是：一次HTTP请求对应一个页面</strong>，所以每次提交表单都会刷新一次页面。为了实现在不刷新页面的前提下，刷新局部数据，我们通过JS来请求数据，并更新数据。这就是AJAX。<strong>在现代浏览器上写AJAX主要依靠XMLHttpRequest对象，低版本的浏览器使用ActiveXObject对象</strong></p><p>一个AJAX的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">success</span>(<span class="hljs-params">text</span>)&#123;<span class="hljs-comment">//加载成功对应的数据显示功能</span><br>    <span class="hljs-keyword">let</span> textarea = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;response-text&#x27;</span>);<br>    textarea.<span class="hljs-property">value</span> = text;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fail</span>(<span class="hljs-params">code</span>)&#123;<span class="hljs-comment">//加载失败对应的显示</span><br>    <span class="hljs-keyword">let</span> textarea = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;response-text&#x27;</span>);<br>    textarea.<span class="hljs-property">value</span> = <span class="hljs-string">&quot;Error code:&quot;</span>+code;<br>&#125;<br><span class="hljs-keyword">var</span> request;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">XMLHttpRequest</span>)&#123;request = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();&#125;<br><span class="hljs-keyword">else</span> &#123;request = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActiveXObject</span>(<span class="hljs-string">&#x27;Mircosoft.XMLHTTP&#x27;</span>);&#125;<br>request.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">//状态发生改变是，函数被回调</span><br>    <span class="hljs-keyword">if</span>(request.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>)&#123;<span class="hljs-comment">//请求成功完成</span><br>        <span class="hljs-comment">//判断响应结果</span><br>        <span class="hljs-keyword">if</span>(request.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>)&#123;<span class="hljs-comment">//响应成功，拿到响应文本</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">success</span>(request.<span class="hljs-property">responseText</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">fail</span>(request.<span class="hljs-property">status</span>);<span class="hljs-comment">//失败，根据响应码判断失败原因</span><br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// HTTP请求还在继续...</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//发送请求</span><br>request.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-string">&#x27;/api/index&#x27;</span>);<br>request.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><ul><li><strong>AJAX请求是异步执行的，要通过回调函数来获得响应</strong></li><li><strong>XMLHttpRequest对象的open()函数有3个参数，第一个是GET&#x2F;POST，第二个是URL地址，第三个指定是否异步，默认为true</strong></li><li><strong>调用send()方法之后才是真正发送请求</strong></li><li><strong>open()参数中的URL使用的是相对路径，这是由于浏览器的同源策略导致的（JS在发送AJAX请求时，URL的域名必须和当前页面完全一致）</strong>，完全一致指：域名一致、协议一致、端口号一致（有些浏览器不要求）</li></ul><p><strong>AJAX访问外域URL的方法</strong></p><ul><li><p>在同源域名下架设一个代理服务器来进行转发（AJAX访问代理服务器的URL，代理服务器根据URL再跳转指定的外域URL，代理服务器再把结果返回，需要在服务器端设置代理，这样就遵守了浏览器的同源策略）</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">&#x27;<span class="hljs-string">/proxy</span>?url=http:<span class="hljs-string">//www.sina.com.cn</span>&#x27;<br></code></pre></td></tr></table></figure></li><li><p><strong>JSONP</strong>，它有个限制，只能用GET请求，并且要求返回JavaScript、实际上是利用了跨域引用JavaScript资源</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">refreshPrice</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">var</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-jsonp&#x27;</span>);<br>    p.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;当前价格：&#x27;</span> +<br>        data[<span class="hljs-string">&#x27;0000001&#x27;</span>].<span class="hljs-property">name</span> +<span class="hljs-string">&#x27;: &#x27;</span> + <br>        data[<span class="hljs-string">&#x27;0000001&#x27;</span>].<span class="hljs-property">price</span> + <span class="hljs-string">&#x27;；&#x27;</span> +<br>        data[<span class="hljs-string">&#x27;1399001&#x27;</span>].<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;: &#x27;</span> +<br>        data[<span class="hljs-string">&#x27;1399001&#x27;</span>].<span class="hljs-property">price</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getPrice</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">var</span> js = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>    <span class="hljs-keyword">var</span> head = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;head&#x27;</span>)[<span class="hljs-number">0</span>];<br>    js.<span class="hljs-property">src</span> =  <span class="hljs-string">&#x27;http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice&#x27;</span>; <span class="hljs-comment">//指定了回调函数</span><br>    head.<span class="hljs-title function_">appendChild</span>(js);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>CORS，跨域资源请求</strong>，更详细的介绍，见另外一篇文章：<a href="http://localhost:4000/2022/04/15/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/">浏览器的同源策略 - Hexo</a></p></li></ul><h3 id="二、Promise"><a href="#二、Promise" class="headerlink" title="二、Promise"></a>二、Promise</h3><p><strong>Promise</strong> 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。可以在它上面绑定回调函数，这样就不需要在一开始把回调函数作为参数传入这个函数了。</p><p><strong>示例：</strong>假设<code>createAudioFileAsync()</code> 函数接受一些配置和两个回调函数作为参数，那么传统的写法为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">success</span>(<span class="hljs-params">result</span>)&#123;...&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fail</span>(<span class="hljs-params">error</span>)&#123;...&#125;<br><span class="hljs-title function_">createAudioFileAsync</span>(settings,success,fail);<br></code></pre></td></tr></table></figure><p>更现代的函数会返回一个Promise对象，可以讲回调函数绑定在Promise上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-title function_">createAudioFileAsync</span>(settings);<br>promise.<span class="hljs-title function_">then</span>(success, failure);<br></code></pre></td></tr></table></figure><p>我们把这个称为 <strong>异步函数调用</strong>。通过then可以添加多个回调函数，它们会按顺序执行（<strong>链式调用</strong>）</p><h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-title function_">doSomething</span>();<br><span class="hljs-keyword">const</span> promise2 = promise.<span class="hljs-title function_">then</span>(successCallback, failureCallback);<br></code></pre></td></tr></table></figure><p><code>promise2</code> 不仅表示 <code>doSomething()</code> 函数的完成，也代表了你传入的 <code>successCallback</code> 或者 <code>failureCallback</code> 的完成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">doSomething</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">doSomethingElse</span>(result);<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">newResult</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">doThirdThing</span>(newResult);<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">finalResult</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Got the final result: &#x27;</span> + finalResult);<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(failureCallback);<br></code></pre></td></tr></table></figure><p><strong>注意：一定要有返回值</strong>，否则，callback 将无法获取上一个 Promise 的结果</p><p><code>catch(failureCallback)</code> 是 <code>then(null, failureCallback)</code> 的缩略形式。一遇到异常抛出，浏览器就会顺着链寻找<code>onRejected</code> 失败回调函数或者由 <code>.catch()</code> 指定的回调函数。所以虽然只在最后声明了.catch，但它会在整个链各个then中发挥作用。</p><p><strong>catch之后也可以有链式调用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;初始化&#x27;</span>);<br>    <span class="hljs-title function_">resolve</span>();<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br>&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;B&#x27;</span>);<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;C&#x27;</span>);<br>&#125;)<br><span class="hljs-comment">// 输出：初始化 B C</span><br></code></pre></td></tr></table></figure><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h4><p>属于 window 的方法，该方法用于在指定的毫秒数后调用函数或计算表达式</p><p><strong>语法：</strong><code>[]</code>表示可选参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> timeoutID = scope.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> [, delay, arg1, arg2, ...]);<br><span class="hljs-keyword">var</span> timeoutID = scope.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> [, delay]);<br><span class="hljs-keyword">var</span> timeoutID = scope.<span class="hljs-built_in">setTimeout</span>(code [, delay]);<br></code></pre></td></tr></table></figure><ul><li>function，想要在到期时间(<code>delay</code>毫秒)之后执行的函数</li><li>delay，延迟的毫秒数 (一秒等于1000毫秒)，如果省略，默认为0，表示“马上”执行，<strong>但实际上延迟时间可能比delay的值要长</strong></li><li>arg1, arg2, …，它们将作为参数传递给function</li><li>code，使用字符串而不是function，<strong>不推荐使用</strong></li></ul><p><strong>返回值：</strong><code>timeoutID</code>，是一个正整数，表示定时器的编号，可以传递给<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/clearTimeout"><code>clearTimeout()</code></a>来取消该定时器</p><p><strong>例子：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> timeoutID;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">delayedAlert</span>(<span class="hljs-params"></span>)&#123;timeout = <span class="hljs-built_in">setTimeout</span>(slowAlert,<span class="hljs-number">200</span>);&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">slowAlert</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">clearAlert</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">window</span>.<span class="hljs-built_in">clearTimeout</span>(timeoutID);&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">double</span>(<span class="hljs-params">value</span>)&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>,<span class="hljs-number">0</span>,value*<span class="hljs-number">2</span>),<span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-title function_">double</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器的同源策略</title>
    <link href="/2022/04/15/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    <url>/2022/04/15/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p>同源的定义、浏览器的同源策略的存在意义、作用机制，以及在浏览器同源策略的前提下如何进行跨域资源请求</p><span id="more"></span><h1 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h1><h3 id="一、同源的定义"><a href="#一、同源的定义" class="headerlink" title="一、同源的定义"></a>一、同源的定义</h3><ul><li><strong>相同的协议（protocol）</strong>，http与https不同</li><li><strong>相同的域名</strong>，<a href="http://www.baidu.com/">www.baidu.com</a> 与 baidu.com不同</li><li><strong>相同的端口号</strong>（有些浏览器不要求，IE&lt;9），80与8080不同</li></ul><h3 id="二、为什么要有"><a href="#二、为什么要有" class="headerlink" title="二、为什么要有"></a>二、为什么要有</h3><p><strong>为了防止恶意网站窃取用户在浏览器上的数据</strong>（比如：通过AJAX请求用户在另一个网站，如淘宝、支付宝等，的Cookie，而Cookie里面不仅保存了用户的基本信息，还保存了登陆凭证等敏感信息）</p><h3 id="三、具体干什么"><a href="#三、具体干什么" class="headerlink" title="三、具体干什么"></a>三、具体干什么</h3><p>在浏览器中，<code>&lt;script&gt;</code> 、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;link&gt;</code>这几个标签可以跨域加载，而不受浏览器的同源策略控制，这些带<code>src</code>属性的标签实际上是通过浏览器发送<code>GET</code>请求来加载。不同于普通请求（XMLHttpRequest）的是，<strong>通过<code>src</code>加载的资源，浏览器限制了JS对它们的读写权限，使其不能读写通过<code>src</code>加载返回的内容</strong></p><p>除了上述几个标签，<strong>其它跨越请求，请求都会发送到跨域的服务器，并且服务器会返回数据，只不过浏览器“拒收”返回的数据</strong></p><h3 id="四、怎么发挥作用"><a href="#四、怎么发挥作用" class="headerlink" title="四、怎么发挥作用"></a>四、怎么发挥作用</h3><p>浏览器规定，如果<strong>不是同源</strong>的站点，将有如下操作限制：</p><ul><li><p><strong>Cookie、Local Storage、Session Storage、Cache和Index DB无法读写</strong></p><p>用户登录某个站点,站点后端服务器验证账号密码正确之后,会返回Cookie、Token 或者是用户名和密码给客户端浏览器，浏览器会将该信息保存到上述某一个当中，如果没有同源策略，恶意网站就可以通过脚本获得用户的数据</p></li><li><p><strong>DOM和JS对象无法获得</strong></p><p>来自一个源的JS只能读写自己源的DOM树。如果可跨源读写DOM的话，在页面里面使用iframe嵌入一个银行页面，就可以随意篡改银行页面的内容了。</p></li><li><p><strong>AJAX请求不能发送</strong></p><p>一般而言，JS只能向同源的接口发送请求。如果向其它源发送请求时，一方面，浏览器发现JS向其它源的接口发送请求时会自动带上Origin头来标识来源，让<strong>服务器能够根据Origin判断要不要响应</strong>；另一方面，浏览器在接收到响应后，如果没有发现Access-Control-Allow-Origin允许发送请求的域进行请求，<strong>浏览器就不允许解析</strong>。</p></li></ul><p><strong>【普及】</strong></p><ul><li><p><strong>Cookie，是服务器发送到用户浏览器并保存在本地的一小块数据</strong>，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。<strong>Cookie的作用主要有以下三方面：</strong></p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul></li><li><p><strong>Window.sessionStorage 属性</strong></p><p>sessionStorage 属性允许在浏览器中存储 key&#x2F;value 对的数据，用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br><span class="hljs-keyword">var</span> lastname = sessionStorage.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;key&quot;</span>);<br>sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&quot;key&quot;</span>);<br>sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&quot;key&quot;</span>);<span class="hljs-comment">// 删除所有数据</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Window localStorage 属性</strong>（ IE8 以上的 IE 版本才支持）</p><p>localStorage 属性允许在浏览器中存储 key&#x2F;value 对的数据，用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;lastname&quot;</span>, <span class="hljs-string">&quot;Smith&quot;</span>);<span class="hljs-comment">// 存储</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;lastname&quot;</span>);<span class="hljs-comment">// 检索</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&quot;lastname&quot;</span>);<span class="hljs-comment">// 删除</span><br></code></pre></td></tr></table></figure><p>一个应用实例：记录按钮的点击次数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-property">clickcount</span>)&#123;<br>    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-property">clickcount</span> = <span class="hljs-title class_">Number</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-property">clickcount</span>) + <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>     <span class="hljs-variable language_">localStorage</span>.<span class="hljs-property">clickcount</span> = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Index DB，浏览器提供的本地数据库</strong>，它可以被网页脚本创建和操作。 Index DB 允许储存大量数据，提供查找接口，还能建立索引。 这些都是 localStorage 所不具备的</p></li></ul><h3 id="五、跨域请求资源"><a href="#五、跨域请求资源" class="headerlink" title="五、跨域请求资源"></a>五、跨域请求资源</h3><p>不同域之间的访问就叫跨域，<strong>常用的跨域解决办法有：</strong></p><ul><li>通过jsonp跨域</li><li>跨域资源共享(CORS)</li><li>Nginx反向代理</li></ul><h4 id="JSONP跨域"><a href="#JSONP跨域" class="headerlink" title="JSONP跨域"></a>JSONP跨域</h4><p>原理是：<code>&lt;script&gt;</code>标签<code>src</code>属性中的链接却可以访问跨域的js脚本，利用这个属性，服务端不直接返回JSON格式的数据，而是返回一段调用某个函数的js代码，在<code>src</code>中进行调用，从而实现跨域。</p><p>实现过程：在前端，动态添加一个src&#x3D;指定url的<code>&lt;script&gt;</code>标签。在后端（指定url部分），声明一个请求数据并返回的函数。JSONP需要前后端一起配合实现。</p><h4 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a>CORS跨域资源共享</h4><p>Cross-Origin-Resource-Share，跨域资源共享。它是基于HTPP的一种机制，该机制允许服务器标识除了它自己以外的origin，使得浏览器允许这些origin访问加载自己（服务器）的资源。</p><p><strong>预检请求</strong>，CORS还要求，对于那些可能会对服务器数据产生副作用的HTTP请求方法（特别是除了GET以外的方法），浏览器必须首先使用一个 <strong>OPTION方法</strong>发送一个<strong>预检请求</strong>，从而获知服务端是否允许该跨源请求。服务端确认允许后才发起真正的HTTP请求。在服务端的返回中，还可以通知客户端是否需要携带身份凭证（Cookie）。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同源策略</tag>
      
      <tag>web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发——JS（三）</title>
    <link href="/2022/04/14/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94JS%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2022/04/14/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94JS%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>JS与浏览器的交互部分。了解浏览器对象、DOM、常用表单操作、文件操作</p><span id="more"></span><h2 id="前端开发——JS（三）"><a href="#前端开发——JS（三）" class="headerlink" title="前端开发——JS（三）"></a>前端开发——JS（三）</h2><h3 id="一、浏览器对象"><a href="#一、浏览器对象" class="headerlink" title="一、浏览器对象"></a>一、浏览器对象</h3><p>不同浏览器对JS支持的差异主要是，<strong>某些API接口不一样</strong>，比如AJAX、File接口，<strong>不同浏览器对ES6标准的特性支持不一样</strong></p><h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><p><strong>window不仅充当全局作用域，而且表示浏览器窗口</strong></p><ul><li>innerWidth和innerHeight，除去了菜单栏、工具栏等等的宽高</li><li>outerWidth和OuterHeight，浏览器整个窗口的高度</li></ul><br><h4 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h4><p><strong>记录浏览器的信息，常用属性如下：</strong></p><ul><li>navigator.appName，浏览器名称&#x2F;&#x2F;‘Netscape’</li><li>navigator.appVersion，浏览器版本</li><li>navigator.language，浏览器设置的语言</li><li>navigator.platform，操作系统类型   &#x2F;&#x2F;Win32</li><li>navigator.userAgent，浏览器设定的<code>User-Agent</code>字符串  &#x2F;&#x2F;“Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:99.0) Gecko&#x2F;20100101 Firefox&#x2F;99.0”</li></ul><br><h4 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h4><p><strong>表示屏幕的信息</strong></p><ul><li>screen.width，屏幕宽度</li><li>screen.height，屏幕高度</li></ul><br><h4 id="location"><a href="#location" class="headerlink" title="location"></a>location</h4><p><strong>表示当前页面的URL信息，可以用location.href获取</strong></p><ul><li>location.href，完整的URL   &#x2F;&#x2F;“<a href="https://36kr.com/&quot;">https://36kr.com/&quot;</a></li><li>location.protocol，传输协议  &#x2F;&#x2F;“https:”</li><li>location.host，域名                 &#x2F;&#x2F;“36kr.com”</li><li>location.port，端口</li><li>location.pathname，路径      &#x2F;&#x2F;“&#x2F;“</li><li>location.search，当前 URL 的查询部分（问号 ? 之后的部分）</li></ul><br><h4 id="document"><a href="#document" class="headerlink" title="document"></a>document</h4><p><strong>表示当前页面</strong></p><p>Cookie，是由服务器发送的key-value标识符，当浏览器访问网站时，会在请求头附加上这个Cookie，服务器可以根据Cookie来区分不同用户。它还可以保存一些网站的设置，如页面语言等。可以通过document.cookie来读取当前页面的Cookie</p><p>同时Cookie的功能意味着它有被窃取信息的风险，，为了解决这个安全问题，服务器在设置Cookie时可以使用<code>httpOnly</code>，这样就不能被JS读取了，这个行为由浏览器实现。</p><h3 id="二、DOM"><a href="#二、DOM" class="headerlink" title="二、DOM"></a>二、DOM</h3><h4 id="获取DOM节点"><a href="#获取DOM节点" class="headerlink" title="获取DOM节点"></a>获取DOM节点</h4><p><strong>获取DOM节点的方法</strong></p><ul><li>document.getElementById()，返回单个元素，参数为<code>name</code></li><li>.getElementsByTagName()，返回Array，参数为<code>name</code></li><li>.getElementsByClassName()，返回Array，参数为<code>name</code></li><li>.querySelector()，参数为CSS选择器的写法，返回单个节点</li><li>querySelectorAll()，参数为CSS选择器的写法，返回Array</li></ul><p><strong>拓展：CSS选择器的组合方法</strong></p><ul><li><p>多个选择器通过逗号<code>,</code>相连，表示同时选中各个选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>,<span class="hljs-selector-tag">h2</span>,<span class="hljs-selector-tag">p</span> &#123; &#125;表示同时选中<span class="hljs-selector-tag">h1</span>,<span class="hljs-selector-tag">h2</span>和<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure></li><li><p>多个类名之间没有间隔，连接在一起，表示同时具有这些类的所有元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">.class1.class2  表示选择同时具有class1和class2类的所有元素<br></code></pre></td></tr></table></figure></li><li><p>多个选择器之间用空格隔开，表示从前到后的深入关系</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">.class1 .class2 p  表示选择class1类元素里面的 class2类元素里面的 所有p标签<br></code></pre></td></tr></table></figure></li></ul><h4 id="更新DOM"><a href="#更新DOM" class="headerlink" title="更新DOM"></a>更新DOM</h4><p><strong>修改DOM节点文本的两种方式</strong></p><ul><li><p>修改<code>innerHTML</code>属性，这种方式很强大，可以直接修改DOM节点内部的子树（直接替换掉原来的HTML）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-p&#x27;</span>)<br>p.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;C++&#x27;</span><br>p.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;&lt;h1&gt; JS &lt;/h1&gt;&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>修改<code>innerText</code>或<code>textContent</code>属性，可以自动对字符串进行HTML编码，但无法设置HTML标签</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-p&#x27;</span>)<br>p.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;JS&#x27;</span><span class="hljs-comment">// 返回所有文本，IE&lt;9不支持textContent</span><br>p.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;JavaScript&#x27;</span>  <span class="hljs-comment">// 不返回隐藏元素的文本</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>修改节点的CSS样式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-p&#x27;</span>)<br>p.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&quot;yellow&quot;</span><br></code></pre></td></tr></table></figure><p>CSS中的样式属性存在<code>font-size</code>这样的类型，但它不是JS里面有效的变量，需要改写为对应的驼峰命名，<code>fontSize</code></p><h4 id="插入DOM"><a href="#插入DOM" class="headerlink" title="插入DOM"></a>插入DOM</h4><p><strong>插入DOM节点的两种方式</strong></p><ul><li><p>使用<code>appendChild</code>，把子节点添加到父节点的最后一个子节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;js&#x27;</span>)<br><span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>)<br>div.<span class="hljs-title function_">appendChild</span>(p)<br><br><span class="hljs-keyword">var</span> n = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>)<br>n.<span class="hljs-property">innerText</span> = <span class="hljs-string">&quot;C++&quot;</span><br>div.<span class="hljs-title function_">appendChild</span>(n)<br></code></pre></td></tr></table></figure></li><li><p>使用<code>insertBefore</code>，把子节点插入到指定位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> n2 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>)<br>n2.<span class="hljs-property">innerText</span> = <span class="hljs-string">&quot;Haskell&quot;</span><br>div.<span class="hljs-title function_">insertBefore</span>(n2,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;python&#x27;</span>))<br></code></pre></td></tr></table></figure></li></ul><h4 id="删除DOM"><a href="#删除DOM" class="headerlink" title="删除DOM"></a>删除DOM</h4><p>要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的<code>removeChild</code>把自己删掉</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-list&#x27;</span>)<br>list.<span class="hljs-title function_">removeChild</span>(list.<span class="hljs-property">lastElementChild</span>)<br>list.<span class="hljs-title function_">removeChild</span>(list.<span class="hljs-property">children</span>[<span class="hljs-number">3</span>])<br>list.<span class="hljs-title function_">removeChild</span>(list.<span class="hljs-property">children</span>[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p><strong>当你遍历一个父节点的子节点并进行删除操作时，要注意，<code>children</code>属性是一个只读属性，并且它在子节点变化时会实时更新</strong></p><p>最好的处理是，从后往前进行删除。</p><h3 id="三、操作表单"><a href="#三、操作表单" class="headerlink" title="三、操作表单"></a>三、操作表单</h3><h4 id="常用表单控件"><a href="#常用表单控件" class="headerlink" title="常用表单控件"></a>常用表单控件</h4><ul><li>文本框，<code>&lt;input type=&quot;text&quot; &gt;</code></li><li>口令框，<code>&lt;input type=&quot;password&quot; &gt;</code></li><li>单选框，<code>&lt;input type=&quot;radio&quot; &gt;</code></li><li>复选框，<code>&lt;input type=&quot;checkbox&quot; &gt;</code></li><li>下拉框，<code>&lt;input type=&quot;select&quot; &gt;</code></li><li>隐藏文本，<code>&lt;input type=&quot;hidden&quot; &gt;</code></li></ul><h4 id="控件值"><a href="#控件值" class="headerlink" title="控件值"></a>控件值</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>用户名：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;用户名&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>性别：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;female&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cbox1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ck&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;first checkbox&quot;</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">&quot;checked&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;cbox1&quot;</span>&gt;</span>This is the first checkbox<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cbox2&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ck&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;second checkbox&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;cbox2&quot;</span>&gt;</span>Second checkbox<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>密码：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pwd&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pwd&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>form表单里面的控件必须要有name属性，它的值才会被form提交</strong></li><li><strong>单选框，同一组单选框的name应该一致</strong>，用div容器将同一组radio包裹起来可读性会更好</li><li>**label标签，for&#x3D;”input控件的id值”**，这样点击label时，会选中或跳转到对应的input中</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> username = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;username&#x27;</span>)<br>username.<span class="hljs-property">value</span><span class="hljs-comment">//获取值</span><br>username.<span class="hljs-property">value</span> = <span class="hljs-number">123</span><span class="hljs-comment">//设置值</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> male = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;male&#x27;</span>)<br><span class="hljs-keyword">var</span> female = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;female&#x27;</span>)<br>male.<span class="hljs-property">value</span><span class="hljs-comment">//&quot;男&quot;，初始值，可以通过JS赋值改变</span><br>female.<span class="hljs-property">value</span><br>male.<span class="hljs-property">checked</span><span class="hljs-comment">//true或false</span><br>female.<span class="hljs-property">checked</span><br></code></pre></td></tr></table></figure><h4 id="表单的form属性"><a href="#表单的form属性" class="headerlink" title="表单的form属性"></a>表单的form属性</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>accept-charset</td><td>提交表单中使用的字符集（默认：页面字符集）</td></tr><tr><td>action</td><td>提交表单的地址（URL）</td></tr><tr><td>autocomplete</td><td>浏览器自动完成表单（默认：开启）</td></tr><tr><td>enctype</td><td>提交数据的编码（默认：url-encoded），<strong>提交文件时：multipart&#x2F;form-data</strong></td></tr><tr><td>method</td><td>提交表单时所用的 HTTP 方法（默认：GET）</td></tr><tr><td>name</td><td>表单的名称（对于 DOM 使用：document.forms.name）<br />比如要外置表单提交按钮是，就需要用form的name属性来匹配</td></tr><tr><td>novalidate</td><td>规定浏览器不验证表单</td></tr><tr><td>target</td><td>action 属性中地址的目标（默认：_self）</td></tr></tbody></table><h3 id="四、操作文件"><a href="#四、操作文件" class="headerlink" title="四、操作文件"></a>四、操作文件</h3><p><code>&lt;input type=&quot;file&quot; enctype=&quot;multipart/form-data&quot;&gt;</code>，当input的<code>type</code>为<code>file</code>时，<code>enctype</code>必须为<code>multipart/form-data</code>,<code>method</code>必须为PSOT</p><p>出于安全考虑，<strong>浏览器只允许用户点击<code>&lt;input type=&quot;file&quot;&gt;</code>来选择本地文件</strong>，用JavaScript对<code>&lt;input type=&quot;file&quot;&gt;</code>的<code>value</code>赋值是没有任何效果的</p><p>H5之前，JS对于文件能够操作的内容很少。<strong>H5新增了File API允许JS读取文件的内容</strong></p><h4 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h4><p><strong>H5的File API提供了File和FileReader两个主要对象，可以获取并读取文件</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>  <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pic-window&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:300px;hegiht:300px;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;image&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pic&quot;</span> <span class="hljs-attr">accept</span>=<span class="hljs-string">&quot;.png,.jpeg,.jpg,.gif&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pic-info&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;pic&#x27;</span>);<br><span class="hljs-keyword">let</span> preview = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;pic-window&#x27;</span>);<br><span class="hljs-keyword">let</span> info = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;pic-info&#x27;</span>);<br><br>fileInput.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;change&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    preview.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;&#x27;</span>;<span class="hljs-comment">//清除背景</span><br>    <span class="hljs-keyword">if</span>(!fileInput.<span class="hljs-property">value</span>)&#123;<br>        info.<span class="hljs-property">innerText</span> = <span class="hljs-string">&quot;没有选择文件&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">var</span> file = fileInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];<span class="hljs-comment">//获取File引用</span><br>    info.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;文件：&#x27;</span>+file.<span class="hljs-property">name</span> +<span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> +<br>        <span class="hljs-string">&#x27;大小：&#x27;</span>+file.<span class="hljs-property">size</span> + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>+<span class="hljs-string">&#x27;修改：&#x27;</span>+file.<span class="hljs-property">lastModified</span>;<br>    <span class="hljs-comment">//读取文件</span><br>    <span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();<br>    reader.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">cb</span>)&#123;<span class="hljs-comment">//读取完成的回调函数</span><br>        <span class="hljs-keyword">let</span> data = cb.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>;<br>        preview.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;url(&#x27;</span>+data+<span class="hljs-string">&#x27;)&#x27;</span>;<br>    &#125;<br>    reader.<span class="hljs-title function_">readAsDataURL</span>(file);<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nodejs使用笔记</title>
    <link href="/2022/04/12/%E5%90%8E%E7%AB%AF/nodejs%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/12/%E5%90%8E%E7%AB%AF/nodejs%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>Node.js使用过程</p><p>记录一些Node.js使用过程中遇到的问题，和常用命令</p><span id="more"></span><h1 id="Nodejs使用笔记"><a href="#Nodejs使用笔记" class="headerlink" title="Nodejs使用笔记"></a>Nodejs使用笔记</h1><h2 id="一、npm"><a href="#一、npm" class="headerlink" title="一、npm"></a>一、npm</h2><h3 id="1-npm查看及换源"><a href="#1-npm查看及换源" class="headerlink" title="1.npm查看及换源"></a>1.npm查看及换源</h3><p>查看源地址：npm config get registry</p><p>设置源地址：npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org/</a></p><p>淘宝镜像源地址：<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org/</a></p><h3 id="2-npm常用包管理命令"><a href="#2-npm常用包管理命令" class="headerlink" title="2.npm常用包管理命令"></a>2.npm常用包管理命令</h3><ul><li><strong>查看</strong></li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>npm list -g –dept 0</td><td>查看全局安装过的包</td></tr><tr><td>npm ls –dept 0</td><td>查看当前项目下安装的包， –dept 0表示查看深度为0，否则会显示一大串详细的分支</td></tr></tbody></table><ul><li><strong>安装</strong></li></ul><table><thead><tr><th>npm [install&#x2F;i] [package_name]</th><th>使用 npm 安装包的命令</th></tr></thead><tbody><tr><td>npm install -g [package_name]</td><td>在全局模式下安装指定包，（注册PATH，不需要require）</td></tr><tr><td>npm install  [package_name]</td><td>在当前项目下安装指定包，（需要通过require来使用）</td></tr><tr><td>npm install [Github 代码库地址]</td><td>直接通过github地址安装</td></tr><tr><td>npm install [packge_name]@版本号</td><td>安装指定版本的包</td></tr><tr><td>npm install [package_name] –save</td><td>模块名将被添加到 dependencies，可以简化为参数-S</td></tr><tr><td>npm install [package_name] –save-dev</td><td>模块名将被添加到 devDependencies，可以简化为参数-D</td></tr></tbody></table><p><em>dependencies 依赖，这个对象里面的内容就是我们这个项目所依赖的 js 模块包</em></p><p><em>devDependencies 开发依赖，只是在开发环境中需要用到，但是在别人引用我们包的时候，不会用到这些内容</em></p><ul><li><strong>卸载</strong></li></ul><table><thead><tr><th>npm uninstall [package_name]</th><th>卸载指定的包（会在node_modules目录中删除包对应的文件夹）</th></tr></thead><tbody><tr><td>npm uninstall –save [package_name]</td><td>卸载包的同时，去除package.json的依赖关系</td></tr><tr><td>npm uninstall -g [package_name]</td><td>卸载全局包</td></tr></tbody></table><ul><li><strong>更新包</strong></li></ul><table><thead><tr><th>npm update -g</th><th>更新所有全局包</th></tr></thead><tbody><tr><td>npm install -g [package_name]</td><td>更新指定的全局包</td></tr><tr><td>npm outdated -g –depth&#x3D;0</td><td>查找过期的包</td></tr><tr><td>npm update</td><td>更新本地包</td></tr><tr><td>npm update –save&#x2F;–dev</td><td>更新本地包，同时把更新情况同步到package.json&#x2F;devDependencies</td></tr><tr><td>npm outdated</td><td>查看本地过期包</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>了解HTTP代理</title>
    <link href="/2022/04/12/%E5%90%8E%E7%AB%AF/%E4%BA%86%E8%A7%A3HTTP%E4%BB%A3%E7%90%86/"/>
    <url>/2022/04/12/%E5%90%8E%E7%AB%AF/%E4%BA%86%E8%A7%A3HTTP%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>HTTP代理是什么？</p><p>我们又常见“正向代理”和“方向代理”这两个名词，两者又有什么区别？</p><span id="more"></span><h2 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理</h2><p>HTTP代理是什么？</p><p>我们又常见“正向代理”和“方向代理”这两个名词，两者又有什么区别？</p><p><strong>正向代理</strong></p><p>一般我们常说的代理，指的就是正向代理。</p><p>正向代理的过程，就是通过一个代理方（软件、或者代理服务器），来帮我们作为中间方传递请求和服务器返回的数据。它隐藏了真实的请求客户端，服务端不知道真正的客户端是谁。一些科学上网工具扮演的就是正向代理的角色。</p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/v2-07ededff1d415c1fa2db3fd89378eda0_720w.jpg" alt="img"></p><p><strong>反向代理</strong></p><p>反向代理隐藏了真实的服务端</p><p>事实上当我们访问一个网址的时候，可能有成千上万台服务器在后面服务，但真正给我们返回数据的只是其中一部分，是哪部分我们并不知道。我们只需要知道反向代理服务器就好，反向代理服务器会帮我们把真实的请求转发到真实服务器上。</p><p>从介绍上不难发现，反向代理服务器可以实现负载均衡的功能。</p><p>除此之外，在一个网站服务器下面可能存在多个端口对应不同的服务，如果要通过端口号来区分的话，难免显得不够优雅，这时候反向代理服务器就可以帮我解决这个问题了。</p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/v2-816f7595d80b7ef36bf958764a873cba_720w.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Express项目部署到云服务器</title>
    <link href="/2022/04/11/Express%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/04/11/Express%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>将Window10本地开发的Express项目迁移至阿里云服务器的过程记录与总结</p><span id="more"></span><h2 id="Express项目部署到云服务器"><a href="#Express项目部署到云服务器" class="headerlink" title="Express项目部署到云服务器"></a>Express项目部署到云服务器</h2><p>前期使用 Express + MongoDB 在本地开发了一个图文博客网站的小项目，为了能够实现在线演示，现在准备把项目部署到云服务器上。</p><p><strong>已经完成的内容</strong></p><ul><li>项目的基本功能已经开发完成</li><li>已经购买了一台阿里云服务器（服务器上已经安装过了Apache）</li></ul><h3 id="一、服务器上安装所需环境"><a href="#一、服务器上安装所需环境" class="headerlink" title="一、服务器上安装所需环境"></a>一、服务器上安装所需环境</h3><h4 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h4><ol><li><p>安装源</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">curl</span> -<span class="hljs-built_in">sL</span> https:<span class="hljs-comment">//rpm.nodesource.com/setup_12.x | bash -</span><br></code></pre></td></tr></table></figure><p>在Linux中<strong>curl</strong>是一个利用URL规则在命令行下工作的文件传输工具</p></li><li><p>开始安装</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum -y <span class="hljs-keyword">install</span> nodejs<br></code></pre></td></tr></table></figure></li><li><p>查看安装结果</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br>npm -v<br></code></pre></td></tr></table></figure></li><li><p><strong>替换镜像</strong>，默认的镜像为：<code>https:*//registry.npmjs.org/*</code>，国内下载可能受限，更换为淘宝镜像</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">npm config <span class="hljs-keyword">set</span> <span class="hljs-keyword">registry</span> <span class="hljs-keyword">http</span>://<span class="hljs-keyword">registry</span>.npm.taobao.org/<br></code></pre></td></tr></table></figure><p>如果想恢复原来的镜像地址：npm config set registry <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a></p></li></ol><h4 id="安装Express"><a href="#安装Express" class="headerlink" title="安装Express"></a>安装Express</h4><p>使用glocal安装，Express是Nodejs下的一个框架</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm -g <span class="hljs-keyword">install</span> express<br></code></pre></td></tr></table></figure><h4 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h4><ol><li><p>下载安装包</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//</span>repo.mongodb.org<span class="hljs-regexp">/yum/</span>redhat<span class="hljs-regexp">/7/m</span>ongodb-org<span class="hljs-regexp">/testing/</span>x86_64<span class="hljs-regexp">/RPMS/m</span>ongodb-org-server-<span class="hljs-number">5.0</span>.<span class="hljs-number">7</span>-<span class="hljs-number">0.1</span>.rc1.el7.x86_64.rpm<br></code></pre></td></tr></table></figure><p>具体的url应该参考[MongoDB官网](<a href="https://www.mongodb.com/try/download/community">MongoDB Community Download | MongoDB</a>)给出的链接为准，Package选择rpm，Platform选择自己对应的版本，我这里是RedHat&#x2F;CentOS 7</p></li><li><p>安装配置</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rpm</span> -ivh mongodb-org-server-<span class="hljs-number">5</span>.<span class="hljs-number">0</span>.<span class="hljs-number">7</span>-<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.rc1.el7.x86_64.rpm<br></code></pre></td></tr></table></figure><p><strong>rpm命令</strong> 是RPM软件包的管理工具</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">-<span class="hljs-selector-tag">i</span>：显示套件的相关信息；-v：显示指令执行过程；-h或<span class="hljs-attr">--hash</span>：套件安装时列出标记；<br></code></pre></td></tr></table></figure><p> 从安装信息可以看出，mongodb安装完成后已经自动开机启动项中</p></li><li><p>查看启动项文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/systemd/</span>system/mongod.service<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/465051-20210727182418375-774943240.png" alt="img"></p></li><li><p>查看配置文件</p><p>从上图可以看到配置文件在&#x2F;etc&#x2F;mongod.conf中</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/etc/m</span>ongod.conf<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/20210727171833476-369942151-16496819084402.png" alt="img"></p><ul><li>数据库目录：&#x2F;var&#x2F;lib&#x2F;mongo</li><li>日志目录：&#x2F;var&#x2F;log&#x2F;mongodb&#x2F;mongod.log</li><li>端口号：27017</li></ul></li><li><p>修改配置文件</p><ul><li>访问IP改为：0.0.0.0（即不限制访问IP）</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vi <span class="hljs-regexp">/etc/m</span>ongod.conf<br></code></pre></td></tr></table></figure></li><li><p>重载系统服务, 启动</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl daemon-reload<br><span class="hljs-params">system</span>ctl start mongod<br></code></pre></td></tr></table></figure><p><strong>启动失败！经过多番查找，发现问题出在文件权限上，解决过程见文章末尾</strong></p></li><li><p>查看启动状态</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl status mongod</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220411224726165.png" alt="image-20220411224726165"></p></li></ol><h3 id="二、服务器端口设置"><a href="#二、服务器端口设置" class="headerlink" title="二、服务器端口设置"></a>二、服务器端口设置</h3><p>开放云服务器的27017端口，并重启服务器</p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-0411231918871.png" alt="image-20220411231918871" style="zoom: 33%;" /><p>在浏览器中输入<code>服务器IP:27017</code>，成功访问到数据库</p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220411232018995.png" alt="image-20220411232018995" style="zoom:50%;" /><h3 id="三、设置HTTP代理"><a href="#三、设置HTTP代理" class="headerlink" title="三、设置HTTP代理"></a>三、设置HTTP代理</h3><p>何为代理？可以参见我另外一篇文章：了解HTTP代理</p><p>由于上一次已经安装过Apache（见这篇文章：[阿里云发布网页Apache](<a href="https://qiuzcc.github.io/2022/03/12/%E9%98%BF%E9%87%8C%E4%BA%91%E5%8F%91%E5%B8%83%E7%BD%91%E9%A1%B5Apache/">阿里云发布网页Apache - Hexo (qiuzcc.github.io)</a>)），所以直接使用Apache的代理</p><p>网上关于Apache设置http代理的文章质量参差不齐，解释不清楚。</p><p>最后发现其实只需要在<strong>httpd.conf</strong>末尾加上两句就可以了。<strong>在CentOS 7中，Apache有另外一个名称，叫httpd</strong></p><p>httpd的配置文件所在目录：<code>/etc/httpd/</code></p><p>打开<code>/etc/httpd/conf/httpd.conf</code>，在末尾添加</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ProxyPass</span> <span class="hljs-string">&quot;/&quot;</span>  <span class="hljs-string">&quot;http://127.0.0.1:3000&quot;</span>         将所有请求（<span class="hljs-string">&quot;/&quot;</span>）代理到一个后端：<br>ProxyPassReverse <span class="hljs-string">&quot;/&quot;</span>  <span class="hljs-string">&quot;http://127.0.0.1:3000&quot;</span>  为了确保Location:将从后端生成的和标头修改为指向反向代理，而不是返回自身<br></code></pre></td></tr></table></figure><p>即可！</p><p>官方文档：<a href="https://www.apachehttpd.com/howto/reverse_proxy.html">反向代理设置指南_Apache中文文档 (apachehttpd.com)</a></p><h3 id="四、上传项目代码"><a href="#四、上传项目代码" class="headerlink" title="四、上传项目代码"></a>四、上传项目代码</h3><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>CentOS 7安装git，通过git从github克隆项目仓库。这样做的好处是：本地所做的更改可以方便地通过git命令同步到服务器上。</p><p>通过yum命令直接安装，方法简单，并且会自动安装依赖的包，而且会从源里安装最新的版本（不过不一定是最新的git）。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> git<br></code></pre></td></tr></table></figure><p>查看git版本</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p>配置name和email</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;timegogo&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>创建SSH Key</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ssh-keygen -t rsa</span><br></code></pre></td></tr></table></figure><p>根据提示，可以看到在&#x2F;root&#x2F;.ssh&#x2F;目录下新增了id_rsa和id_rsa.pub两个文件。登陆github，打开Account Settings 打开SSH Keys页面，添加SSH Key，把id_rsa.pub里面的内容复制进去，保存</p><h4 id="clone项目"><a href="#clone项目" class="headerlink" title="clone项目"></a>clone项目</h4><p>在&#x2F;home下新建&#x2F;node目录，</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">地址</span><br></code></pre></td></tr></table></figure><p><strong>完善数据</strong>，因为是从本地项目移植到服务器上的，所以数据库并不是同一个，需要把数据库的数据同步，或者说重新初始化一份数据。</p><p>这里尝试把本地数据库的数据移植到云上的数据库。</p><h3 id="五、启动Express服务"><a href="#五、启动Express服务" class="headerlink" title="五、启动Express服务"></a>五、启动Express服务</h3><p><strong>安装pm2</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g pm2<br></code></pre></td></tr></table></figure><p><strong>pm2是一个进程管理工具,可以用它来管理你的node进程，并查看node进程的状态，当然也支持性能监控，进程守护，负载均衡等功能</strong></p><p>通过pm2可以让node项目在服务器上永久运行，而且不会一包错就把express服务挂掉，而且运行中还可以进行其它操作。</p><p>切换到Express项目根目录下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">pm2 start .<span class="hljs-regexp">/bin/</span>www<br></code></pre></td></tr></table></figure><p><strong>至此，直接输入域名就可以访问到我们部署的Express项目啦！</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>将一个本地开发好的项目移植到云服务上，主要步骤依次为：搭建项目运行环境、安装并测试数据库连接、安装必要的包、安装git并从github克隆项目、开放服务器的端口、设置服务端的http代理、安装pm2永远运行项目。</p><p>在设置服务端http代理这一步，卡了大量的时间，原因在于对于Apache不熟悉，不知道如何设置反向代理，网上的经验贴质量也参次不齐。最后靠看官网文档 + 大胆尝试 实现了。（官方文档永远都是最靠谱的）</p><p>整个过程下来，熟悉了一遍上线项目的流程，其实理解之后会发现上线的原理很简单，并没有想象的那么难，就是在服务器上创建一个一模一样的环境，让项目运行在上面，同时设置一下访问代理，通过代理访问到项目服务器。中间了解到了一个关键的知识点，就是 <strong>代理</strong>，包括正向代理和反向代理。然后学习了如何通过Apache（在CentOS上httpd）来设置反向代理。</p><p>但是我知道其实还存在很多问题没有解决，比如没有将node的项目环境修改为生产环境，没有做任何性能优化等等。</p><p>路漫漫其修远兮……</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="bug1：无法启动mongod服务"><a href="#bug1：无法启动mongod服务" class="headerlink" title="bug1：无法启动mongod服务"></a>bug1：无法启动mongod服务</h4><p>安装配置好mongodb server之后，使用<code>systemctl start mongod</code>作为系统服务启动，但是失败了，报了下面的错误</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Job <span class="hljs-keyword">for</span> mongod.service failed because <span class="hljs-keyword">the</span> control <span class="hljs-built_in">process</span> exited <span class="hljs-keyword">with</span> error code. See <span class="hljs-string">&quot;systemctl status mongod.service&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;journalctl -xe&quot;</span> <span class="hljs-keyword">for</span> details.<br></code></pre></td></tr></table></figure><p>输入<code>systemctl status mongod.service</code>查看输出如下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk">● mongod.service - MongoDB Database Server<br>   Loaded: loaded (<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/systemd/</span>system/mongod.service; enabled; vendor preset: disabled)<br>   Active: failed (Result: <span class="hljs-keyword">exit</span>-code) since Mon <span class="hljs-number">2022</span>-<span class="hljs-number">04</span>-<span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">49</span> CST; <span class="hljs-number">23</span>min ago<br>     Docs: https:<span class="hljs-regexp">//</span>docs.mongodb.org/manual<br>  Process: <span class="hljs-number">24833</span> ExecStart=<span class="hljs-regexp">/usr/</span>bin/mongod <span class="hljs-variable">$OPTIONS</span> (code=exited, status=<span class="hljs-number">14</span>)<br>  Process: <span class="hljs-number">24830</span> ExecStartPre=<span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/chmod 0755 /</span>var<span class="hljs-regexp">/run/m</span>ongodb (code=exited, status=<span class="hljs-number">0</span>/SUCCESS)<br>  Process: <span class="hljs-number">24826</span> ExecStartPre=<span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/chown mongod:mongod /</span>var<span class="hljs-regexp">/run/m</span>ongodb (code=exited, status=<span class="hljs-number">0</span>/SUCCESS)<br>  Process: <span class="hljs-number">24824</span> ExecStartPre=<span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/mkdir -p /</span>var<span class="hljs-regexp">/run/m</span>ongodb (code=exited, status=<span class="hljs-number">0</span>/SUCCESS)<br><br>Apr <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">48</span> iZwz913vjju8a7uxhrlugnZ systemd[<span class="hljs-number">1</span>]: Starting MongoDB Database Server...<br>Apr <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">48</span> iZwz913vjju8a7uxhrlugnZ mongod[<span class="hljs-number">24833</span>]: about to fork child process, waiting until...s.<br>Apr <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">48</span> iZwz913vjju8a7uxhrlugnZ mongod[<span class="hljs-number">24833</span>]: forked process: <span class="hljs-number">24836</span><br>Apr <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">49</span> iZwz913vjju8a7uxhrlugnZ mongod[<span class="hljs-number">24833</span>]: ERROR: child process failed, exited with <span class="hljs-number">14</span><br>Apr <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">49</span> iZwz913vjju8a7uxhrlugnZ mongod[<span class="hljs-number">24833</span>]: To see additional information <span class="hljs-keyword">in</span> this outp...n.<br>Apr <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">49</span> iZwz913vjju8a7uxhrlugnZ systemd[<span class="hljs-number">1</span>]: mongod.service: control process exited, code=...<span class="hljs-number">14</span><br>Apr <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">49</span> iZwz913vjju8a7uxhrlugnZ systemd[<span class="hljs-number">1</span>]: Failed to start MongoDB Database Server.<br>Apr <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">49</span> iZwz913vjju8a7uxhrlugnZ systemd[<span class="hljs-number">1</span>]: Unit mongod.service entered failed state.<br>Apr <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">49</span> iZwz913vjju8a7uxhrlugnZ systemd[<span class="hljs-number">1</span>]: mongod.service failed.<br></code></pre></td></tr></table></figure><p>百度查找，说是文件权限的原因，一开始以为是<code>数据库/var/lib/mongo</code>和<code>日志/var/log/mongodb/mongod.log</code>这两个目录的权限问题，但是发现并没有问题，属主和数组都是mongod（因为是使用rpm安装mongodb server过程中自动创建的）</p><p>再查百度，发现了真正的问题所在，是<code>/tmp/mongodb-27017.sock</code>这个文件的问题，它的属主为root，mongod没有足够的权限</p><p>解决方案：修改<code>/tmp/mongodb-27017.sock</code>的属主为mongod</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">chown mongod:mongod <span class="hljs-regexp">/tmp/m</span>ongodb-<span class="hljs-number">27017</span>.sock<br></code></pre></td></tr></table></figure><p>然后重新启动，即可</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> mongod<br></code></pre></td></tr></table></figure><h4 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h4><p><a href="https://cloud.tencent.com/developer/article/1538014?from=article.detail.1494192">服务器小白的我,是如何将 node+mongodb 项目部署在服务器上并进行性能优化的 - 云+社区 - 腾讯云 (tencent.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>了解Express框架</title>
    <link href="/2022/04/11/%E5%89%8D%E7%AB%AF/%E4%BA%86%E8%A7%A3Express%E6%A1%86%E6%9E%B6/"/>
    <url>/2022/04/11/%E5%89%8D%E7%AB%AF/%E4%BA%86%E8%A7%A3Express%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>Express是node.js运行环境中，一款最受欢迎的后端开发框架</p><span id="more"></span><h1 id="Express框架"><a href="#Express框架" class="headerlink" title="Express框架"></a>Express框架</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>Node.js 已经成为 Web 后台开发圈一股不容忽视的力量，凭借其良好的异步性能、丰富的 npm 库以及 JavaScript 语言方面的优势，已经成为了很多大公司开发其后台架构的重要技术之一，而 Express 框架则是其中知名度最高、也是最受欢迎的后端开发框架。</p><p>接下来，我们将了解Express在Node内置的http模块上做了怎样的封装，并掌握<strong>路由</strong>和<strong>中间件</strong>这两个关键概念，学习如何使用 <strong>模板引擎</strong>、<strong>静态文件服务</strong>、<strong>错误处理</strong>和 <strong>JSON API</strong></p><h3 id="二、用Express搭建服务器"><a href="#二、用Express搭建服务器" class="headerlink" title="二、用Express搭建服务器"></a>二、用Express搭建服务器</h3><h4 id="强大的Request和Respose对象"><a href="#强大的Request和Respose对象" class="headerlink" title="强大的Request和Respose对象"></a>强大的Request和Respose对象</h4><ul><li><code>req.body</code>：客户端请求体的数据，可能是表单或 JSON 数据</li><li><code>req.params</code>：请求 URI 中的路径参数</li><li><code>req.query</code>：请求 URI 中的查询参数</li><li><code>req.cookies</code>：客户端的 cookies</li></ul><h4 id="路由机制"><a href="#路由机制" class="headerlink" title="路由机制"></a>路由机制</h4><p>客户端向服务器发送请求包含两部分：路径（Url）和请求方法（POST、GET），合起来统称<strong>API端点</strong></p><p>服务器根据客户端访问的端点选择对应的处理逻辑的机制就叫做<strong>路由</strong></p><p>定义方式：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">app.<span class="hljs-keyword">METHOD</span>(<span class="hljs-type">PATH</span>, <span class="hljs-keyword">HANDLER</span>)<br></code></pre></td></tr></table></figure><ul><li><code>app</code> 就是一个 <code>express</code> 服务器对象</li><li><code>METHOD</code> 可以是任何<strong>小写</strong>的 HTTP 请求方法，包括 <code>get</code>、<code>post</code>、<code>put</code>、<code>delete</code> 等等</li><li><code>PATH</code> 是客户端访问的 URI，例如 <code>/</code> 或 <code>/about</code></li><li><code>HANDLER</code> 是路由被触发时的回调函数，在函数中可以执行相应的业务逻辑</li></ul><h4 id="nodemon热加载"><a href="#nodemon热加载" class="headerlink" title="nodemon热加载"></a>nodemon热加载</h4><p>Nodemon 是一款颇受欢迎的开发服务器，能够<strong>检测工作区代码的变化，并自动重启</strong>。通过以下命令安装 nodemon：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">npm install nodemon --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>这里我们将 nodemon 安装为开发依赖 <code>devDependencies</code>，因为仅仅只有在开发时才需要用到。同时我们在 package.json 中加入 <code>start</code> 命令，代码如下：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stata">package.json查看完整代码<br>&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;express_resume&quot;</span>,<br>  <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;main&quot;</span>: <span class="hljs-string">&quot;index.js&quot;</span>,<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;nodemon server.js&quot;</span>,<br>    <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;</span><span class="hljs-keyword">Error</span>: <span class="hljs-keyword">no</span> <span class="hljs-keyword">test</span> specified\<span class="hljs-string">&quot; &amp;&amp; exit 1&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;license&quot;</span>: <span class="hljs-string">&quot;ISC&quot;</span>,<br>  <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;express&quot;</span>: <span class="hljs-string">&quot;^4.17.1&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;devDependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;nodemon&quot;</span>: <span class="hljs-string">&quot;^2.0.2&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、编写中间件"><a href="#三、编写中间件" class="headerlink" title="三、编写中间件"></a>三、编写中间件</h3><p><strong>理解中间件</strong>，不是Express独有的概念，是指<strong>将具体的业务逻辑和底层逻辑解耦的组件</strong>。换句话说，中间件就是能够适用多个应用场景、可复用性良好的代码。</p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/middleware.png" alt="img"></p><p>例如博客网站项目里面，用于上传文件的multer中间件，添加在路由参数当中。</p><p><strong>Express里的中间件</strong>，就是函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> some<span class="hljs-constructor">Middleware(<span class="hljs-params">req</span>, <span class="hljs-params">res</span>, <span class="hljs-params">next</span>)</span> &#123;  <span class="hljs-comment">// 自定义逻辑  next();&#125;</span><br></code></pre></td></tr></table></figure><p>三个参数中，<code>req</code> 和 <code>res</code> 就是前面提到的 Request 请求对象和 Response 响应对象；而 <code>next</code> 函数则用来触发下一个中间件的执行。</p><p>在 Express 使用中间件有两种方式：<strong>全局中间件</strong>和<strong>路由中间件</strong>。</p><p>通过 <code>app.use</code> 函数就可以注册中间件，并且此中间件会在用户发起<strong>任何请求</strong>都可能会执行，例如：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">app</span>.<span class="hljs-keyword">use</span>(someMiddleware);<br></code></pre></td></tr></table></figure><h4 id="路由中间件"><a href="#路由中间件" class="headerlink" title="路由中间件"></a>路由中间件</h4><p>通过在路由定义时注册中间件，此中间件只会在用户访问该路由对应的 URI 时执行，例如：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">app.get(<span class="hljs-string">&#x27;/middleware&#x27;</span>, someMiddleware, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;Hello World&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="四、模板引擎"><a href="#四、模板引擎" class="headerlink" title="四、模板引擎"></a>四、模板引擎</h3><p>设置模板引擎</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">app.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;views&#x27;</span>, <span class="hljs-string">&#x27;views&#x27;</span>);    指定模板文件的目录，即第二个参数<br>app.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;hbs&#x27;</span>);指定模板引擎为hbs<br></code></pre></td></tr></table></figure><p>在views文件夹下创建页面文件</p><p>在路由函数中调用res.render即可进行渲染</p><h3 id="五、静态文件服务"><a href="#五、静态文件服务" class="headerlink" title="五、静态文件服务"></a>五、静态文件服务</h3><p>通常网站需要提供静态文件服务，例如图片、CSS 文件、JS 文件等等，而 Express 已经自带了静态文件服务中间件 <code>express.static</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">app.<span class="hljs-keyword">use</span>(express.<span class="hljs-built_in">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>));<br></code></pre></td></tr></table></figure><p>通过以上代码来添加静态文件目录</p><p>可以通过url访问，<code>http://localhost:3000/css/style.css</code>，不必添加public</p><p>也可以在&#x2F;views下的文件引用静态资源，src为<code>/css/style.css</code></p><h3 id="六、处理404和服务器错误"><a href="#六、处理404和服务器错误" class="headerlink" title="六、处理404和服务器错误"></a>六、处理404和服务器错误</h3><ul><li>客户端方面的错误（状态码 4xx），例如访问了不存在的页面（404）、权限不够（403）等等</li><li>服务器方面的错误（状态码 5xx），例如服务器内部出现错误（500）或网关错误（503）等等</li></ul><p>完善一下 Express 中间件的运作流程，如下图所示：</p><p><img src="https://static.powerformer.com/c/cd5b993/middleware-new.png"></p><p>从图中可以看到，中间件和路由是从前往后执行的，当路由匹配到对应的url时，直接返回响应；不匹配则继续检查下一个路由。</p><p>中间件不仅可以调用next函数向下传递、还可以直接抛出异常</p><ul><li><p>404的处理，需要在所有路由后面再加一个中间件，用来接收所有路由均匹配失败的请求</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">app.use(<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>  <span class="hljs-regexp">//</span> ...<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>错误处理，前面所有中间件抛出异常时都会进入错误处理函数</p></li></ul><p><strong>处理内部错误</strong></p><p>Express 的默认错误处理机制可以通过设置 <code>NODE_ENV</code> 来进行切换。我们将其设置为生产环境 <code>production</code>，再开启服务器。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> <span class="hljs-attribute">NODE_ENV</span>=production<br>node server.js<br></code></pre></td></tr></table></figure><p>这样做的目的是，访问出错时，会直接返回 Internal Server Error（服务器内部错误），不会显示任何错误信息，这样避免了被攻击的风险！</p><p><strong>自定义错误处理逻辑</strong></p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">app.use(<span class="hljs-string">&#x27;/&#x27;</span>, indexRouter);  指定到一个正常处理路由的文件<br>app.use(<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-function"><span class="hljs-params">(req,res)</span>=&gt;</span>&#123;<br>res.status(<span class="hljs-number">404</span>).reder(<span class="hljs-string">&#x27;404&#x27;</span>,&#123;<span class="hljs-name">url</span>:req.originalUrl&#125;)  设置状态码<span class="hljs-number">404</span>，显示输入的url<br>&#125;)<br>app.use(<span class="hljs-function"><span class="hljs-params">(err,req,res,<span class="hljs-built_in">next</span>)</span>=&gt;</span>&#123;<br>console.<span class="hljs-built_in">error</span>(err.stack);<br>res.status(<span class="hljs-number">500</span>).render(<span class="hljs-string">&#x27;500&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="七、子路由"><a href="#七、子路由" class="headerlink" title="七、子路由"></a>七、子路由</h3><p>使用子路由拆分逻辑，但项目越大时，全部路由写在server.js或者app.js里面会显得很臃肿。可以通过子路由 <code>Router</code> 来实现逻辑拆分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>();<br></code></pre></td></tr></table></figure><p><code>express.Router</code> 可以理解为一个迷你版的 <code>app</code> 对象，但是它功能完备，同样支持注册中间件和路由：</p><p><strong>使用方法</strong></p><p>在app.js（或server.js）中</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">var</span> express = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> app = <span class="hljs-title function_ invoke__">express</span>();<br><span class="hljs-keyword">var</span> indexRouter = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;./routes/index&#x27;</span>);<br>app.<span class="hljs-keyword">use</span>(<span class="hljs-string">&#x27;/&#x27;</span>, indexRouter);<br></code></pre></td></tr></table></figure><p>在index文件中，也可以正常添加中间件</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> <span class="hljs-built_in">express</span> = require(&#x27;<span class="hljs-built_in">express</span>&#x27;);<br><span class="hljs-built_in">var</span> router = <span class="hljs-built_in">express</span>.Router();<br>router.<span class="hljs-built_in">get</span>(&#x27;/&#x27;, home.home);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发——性能优化</title>
    <link href="/2022/04/11/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2022/04/11/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>性能优化具有很强的实际意义，所以也是面试中常考的点</p><span id="more"></span><h2 id="前端开发——性能优化"><a href="#前端开发——性能优化" class="headerlink" title="前端开发——性能优化"></a>前端开发——性能优化</h2><p>性能优化的目的一在于为企业节省流量成本，二在于提高用户的使用体验</p><p><strong>分模块论述</strong></p><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><ul><li><strong>减少HTTP请求</strong>，即减少html里面css&#x2F;js等资源的数量</li><li><strong>使用HTTP2.0</strong>，建立在https的基础上（更安全），采用二进制个数传输数据（1.0是文本格式），消息头采用压缩传输可以节省流量</li><li><strong>白屏时间作为加载动画</strong>，优化用户体验</li></ul><h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><ul><li><strong>静态资源做CDN缓存</strong></li><li><strong>把css放在文件头部，js放在底部</strong>，css异步同时开始加载，js会阻塞html的解析</li><li><strong>gzip压缩</strong>，服务器配置gzip压缩传输方式（如nginx可以配置），如果浏览器支持gzip解析，服务器就可以推送gzip资源</li><li><strong>做服务端渲染（ssr）</strong>，在服务侧完成html的拼接，发送到浏览器，然后为其绑定状态和事件，成为一个可交互页面</li></ul><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><ul><li><strong>字体图标代替图片图标</strong>，可以减少对图片资源的请求</li><li><strong>使用精灵图</strong>，把众多的较小的装饰图片合成到一张大图里面，减少加载图片的次数，缺点是精灵图维护比较麻烦</li><li><strong>图片懒加载</strong>，浏览器优先加载可视范围内的图片，其它部分等进入可视区域再加载，实现原理：先给所有img的src赋予一个loading图，图片没有进入可视区域时，赋予真正的src</li><li><strong>使用png格式</strong>，是web图像中最通用的无损压缩格式</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><strong>减少重绘回流</strong>，回流就是当元素尺寸布局发生变化时，DOM需要重新构建。元素更新外观样式时需要重绘</li><li><strong>慎用全局变量</strong>，全局变量定义在全局执行上下文，是所有作用域链的顶端。局部找不到就会一直往上找，影响性能</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客网站demo</title>
    <link href="/2022/04/10/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99demo/"/>
    <url>/2022/04/10/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99demo/</url>
    
    <content type="html"><![CDATA[<p>一个使用 Express框架 + bootstrap框架 + mongoDB数据库 搭建的图文博客网站demo，出于个人兴趣的练习项目</p><span id="more"></span><h1 id="个人博客网站"><a href="#个人博客网站" class="headerlink" title="个人博客网站"></a>个人博客网站</h1><h3 id="一、项目简介"><a href="#一、项目简介" class="headerlink" title="一、项目简介"></a>一、项目简介</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>学习计算机专业多年，从来没有自己做过网站，觉得是一个遗憾。今年开年的学期，没有课程了，所以决定自己动手造一个网站，由于自己平时喜欢拍拍照片、出去游玩，所以就决定造一个图文类的博客网站。但是之前没有学过前端的技术，几乎从零开始，边学边做。前一周学和练HTML和CSS，但是只能做静态网页。后面找到了Express框架，终于可以搭建一个能够和服务端数据库交互的真正意义上的网站（而不只是网页）。话不多说，直接上实现后的界面效果图</p><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><strong>主页</strong></p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220410200144622-16495968830811.png" alt="image-20220410200442015"></p><p><strong>分类页</strong></p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220410200248757.png" alt="image-20220410200248757"></p><p><strong>照片页</strong></p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220410200335584.png" alt="image-20220410200335584"></p><p><strong>后台管理页</strong></p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220410200442015-16495968946153.png" alt="image-20220410200144622"></p><p><strong>由于一些突发原因，项目没有上线到服务器</strong>，所以目前停留在本地运行的阶段，没有办法提供链接进行访问（只能在本地运行）。</p><h3 id="二、项目规划"><a href="#二、项目规划" class="headerlink" title="二、项目规划"></a>二、项目规划</h3><p>实际项目搭建花了两次，第一次是刚接触Express框架，作为熟悉入门，但是后面文件越建越多的时候，明显感觉到项目极不规范，</p><p>所以这时重头搭建了一次，从项目的全局规划开始，</p><p><strong>第一步</strong>，设计全局的路由规划、数据Model、资源目录的分组、项目文件的分组；</p><p><strong>第二步</strong>，学习git版本管理，按项目进度阶段保存项目的版本（所以也是git管理的练手项目）；</p><p><strong>第三步</strong>，就是分页面进行UI设计、功能实现。</p><p>下面是具体的规划设计（实际项目过程中有一些变动，另外增加了一个Model）</p><h4 id="路由规划"><a href="#路由规划" class="headerlink" title="路由规划"></a><strong>路由规划</strong></h4><table><thead><tr><th>地址</th><th>页面</th><th>控制器、方法</th><th>view</th></tr></thead><tbody><tr><td>&#x2F;</td><td>首页</td><td>homeController.home</td><td>home</td></tr><tr><td>&#x2F;article&#x2F;:id</td><td>文章详情页</td><td>articleController.detail</td><td>article_detail</td></tr><tr><td>&#x2F;article&#x2F;classifier</td><td>文章分类页</td><td>articleController.classifier</td><td>classifier</td></tr><tr><td>&#x2F;article&#x2F;classifier&#x2F;study</td><td>文章分类页（学习笔记）</td><td>articleController.classifier_study</td><td>classifier_study</td></tr><tr><td>&#x2F;article&#x2F;classifier&#x2F;life</td><td>文章分类页（生活感悟）</td><td>articleController.classifier_life</td><td>classifier_life</td></tr><tr><td>&#x2F;article&#x2F;classifier&#x2F;other</td><td>文章分类页（其它）</td><td>articleController.classifier_other</td><td>classifier_other</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>&#x2F;photos</td><td>照片展示页</td><td>photoController.home</td><td>photos</td></tr><tr><td>&#x2F;photos&#x2F;:id</td><td>照片详情页</td><td>photoController.detail</td><td>photo_detail</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>&#x2F;manage&#x2F;article&#x2F;all</td><td>文章管理页（全部分类）<br />后台管理默认页面</td><td>articleController.manage_list</td><td>manage_article</td></tr><tr><td>&#x2F;manage&#x2F;article&#x2F;study</td><td>文章管理页（学习笔记）</td><td>articleController.manage_study</td><td>manage_article_study</td></tr><tr><td>&#x2F;manage&#x2F;article&#x2F;life</td><td>文章管理页（生活感悟）</td><td>articleController.manage_life</td><td>manage_article_life</td></tr><tr><td>&#x2F;manage&#x2F;article&#x2F;other</td><td>文章管理页（其它）</td><td>articleController.manage_other</td><td>manage_article_other</td></tr><tr><td>&#x2F;manage&#x2F;article&#x2F;:id</td><td>文章详情管理页</td><td>articleController.manage_detail</td><td>manage_article_detail</td></tr><tr><td>&#x2F;manage&#x2F;article&#x2F;:id&#x2F;update</td><td>无页面（提交文章修改post）</td><td>articleController.manage_detail_update</td><td>重定向到文章详情页</td></tr><tr><td>&#x2F;manage&#x2F;article&#x2F;:id&#x2F;remove</td><td>无页面（提交文章删除请求）</td><td>articleController.manage_detail_remove</td><td>重定向到文章管理页（全部）</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>&#x2F;manage&#x2F;photos</td><td>照片管理页</td><td>photoController.manage_list</td><td>manage_photos</td></tr><tr><td>&#x2F;manage&#x2F;photos&#x2F;:id</td><td>照片详情管理页</td><td>photoController.manage_detail</td><td>manage_photos_detail</td></tr><tr><td>&#x2F;manage&#x2F;photos&#x2F;:id&#x2F;update</td><td>无（提交照片修改post）</td><td>photoController.manage_detail_update</td><td>重定向到照片详情页</td></tr><tr><td>&#x2F;manage&#x2F;photos&#x2F;:id&#x2F;remove</td><td>无（提交照片remove）</td><td>photoController.manage_detail_remove</td><td>重定向到照片管理页</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>&#x2F;manage&#x2F;people</td><td>个人信息管理页</td><td>peopleController.manage</td><td>manage_people</td></tr><tr><td>&#x2F;manage&#x2F;people&#x2F;update</td><td>无页面（提交修改表单）</td><td>peopleController.update</td><td>重定向到manage_people</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>&#x2F;manage&#x2F;new&#x2F;article</td><td>文章发布页</td><td>articleController.manage_new</td><td>manage_new_article</td></tr><tr><td>&#x2F;manage&#x2F;new&#x2F;article&#x2F;create</td><td>无页面（提交文章新建的post）</td><td>articleController.manage_new_create</td><td>重定向到文章详情页</td></tr><tr><td>&#x2F;manage&#x2F;new&#x2F;photo</td><td>照片上传页</td><td>photoController.manage_new</td><td>manage_new_photo</td></tr><tr><td>&#x2F;manage&#x2F;new&#x2F;photo&#x2F;upload</td><td>无页面（照片上传的post）</td><td>photoController.manage_new_upload</td><td>重定向到照片详情页</td></tr></tbody></table><h4 id="数据Model"><a href="#数据Model" class="headerlink" title="数据Model"></a><strong>数据Model</strong></h4><ul><li>Article</li></ul><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td>String</td><td>文章标题 required:true</td></tr><tr><td>classification</td><td>String</td><td>文章分类 required: true, default: “其它”</td></tr><tr><td>abstract</td><td>String</td><td>文章摘要</td></tr><tr><td>content</td><td>String</td><td>文章内容</td></tr><tr><td>picture</td><td>String</td><td>配图的路径+文件名</td></tr><tr><td>timestamp</td><td>Date</td><td>创建时间 default: Date.now()</td></tr><tr><td>url</td><td>virtual</td><td>&#x2F;article&#x2F;this.id</td></tr><tr><td>date</td><td>virtual</td><td>moment(this.timestamp).format(“YYYY MMMM Do”)</td></tr></tbody></table><ul><li>People</li></ul><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>String</td><td>昵称</td></tr><tr><td>description</td><td>String</td><td>简介</td></tr><tr><td>photo</td><td>String</td><td>头像的路径+文件名</td></tr><tr><td>github</td><td>String</td><td>github链接（需要添加前缀https:&#x2F;&#x2F;)</td></tr><tr><td>wechat</td><td>String</td><td>微信名片图片的路径+文件名</td></tr><tr><td>weibo</td><td>String</td><td>微博首页链接（需要添加前缀https:&#x2F;&#x2F;)</td></tr></tbody></table><ul><li>Photos</li></ul><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td>String</td><td>照片标题</td></tr><tr><td>description</td><td>String</td><td>照片简介</td></tr><tr><td>file</td><td>String</td><td>照片保存的路径+文件名</td></tr><tr><td>timestamp</td><td>Date</td><td>照片上传的时间 default:Date.now()</td></tr><tr><td>views</td><td>Number</td><td>点击量 default:0</td></tr><tr><td>url</td><td>virtual</td><td>&#x2F;photos&#x2F;this.id</td></tr><tr><td>date</td><td>virtual</td><td>moment(this.timestamp).format(“YYYY MMMM Do”)</td></tr></tbody></table><h4 id="public目录"><a href="#public目录" class="headerlink" title="public目录"></a><strong>public目录</strong></h4><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>…</td><td>其它自带的目录</td></tr><tr><td>&#x2F;images&#x2F;article</td><td>保存所有的文章配图</td></tr><tr><td>&#x2F;images&#x2F;people</td><td>保存个人头像、微信名片</td></tr><tr><td>&#x2F;images&#x2F;photos</td><td>保存所有上传的照片</td></tr></tbody></table><h3 id="三、项目收获"><a href="#三、项目收获" class="headerlink" title="三、项目收获"></a>三、项目收获</h3><h4 id="项目亮点"><a href="#项目亮点" class="headerlink" title="项目亮点"></a>项目亮点</h4><p>外观设计比较整洁美观，页面做了响应式设计，具有交互性的动效</p><p>功能比较完整，能够在网页上实现增删改的操作</p><h4 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h4><p><strong>富文本编辑器的应用</strong></p><p>这是目前为止，没有解决的问题。文章管理那一部分，我本来是想通过一个富文本编辑器的插件来实现编辑和修改的。可用的富文本编辑器插件有很多，原理基本都是把编辑器的内容保存为html文件，存放到服务器上，访问文章的时候返回html文件。这里涉及到一个冲突，因为文章页我自己设计的是有一个导航栏+页头背景图的，所以已经需要有一个jade文件来渲染了，所以没有办法直接返回只有文章内容的html（学习了html之后，发现可能可以通过iframe实现html的嵌入）。另外文章图片的插入预想也比较麻烦，文章里面（或者说html里面）不可能直接放置照片，只能放置照片的url，所以照片的保存需要另外处理。文章的修改也比较麻烦，预想方案是文章纯文本和html各自保存一份，修改直接在纯文本上做，改完覆盖掉原来的html。</p><p><strong>文章分类数量的管理</strong></p><p>算不上难点，但也能算是一个技术点，涉及到数据库的操作思路。在首页放置了一个分类的卡片标签，左侧为分类名字，右侧为该分类下的文章数量。一开始规划的时候之后Article一个数据模型，里面保存了文章的详细信息和分类信息，但是如果只有这个Model的话，每次加载首页的时候，都要把Article 集合（Collection）里面所有记录遍历一遍，所以明显不够合理。为此，增加了一个Classifier的数据Model，专门用来记录分类的数量信息。这样做的优势在于：查询效率很高；缺点在于：文章做增删改查时多了一个要维护的数据Model，增加了文章增删改查的工作量。</p><h4 id="实践经验"><a href="#实践经验" class="headerlink" title="实践经验"></a>实践经验</h4><p>通过这次项目，上手练习了多项技术，有<strong>Express框架、bootstrap框架、MongoDB数据库、Node.js服务器、jade语言，还有git版本管理工具</strong>。</p><p>以上列举的，都是第一次使用的框架和工具。</p><p><strong>Express框架</strong>是通过另外一个教程接触的，但是在搭建本项目的过程中，才更深刻地了解到里面的一些原理，如它的路由机制是怎样一条链路（网页的链接url——router文件——Controller管理器的具体函数——[渲染的新页面]）。</p><p>为了高效的管理页面样式，在编辑页面UI之前，特定花了一两天时间，阅读了一边<strong>bootstrap5</strong>的参考文档，在设计页面的时候尽量使用了bootstrap的元素和组件，比如所有的卡片、照片页的轮播图、表单、侧边导航栏。</p><p>为了实现开发过程中的版本管理，花了半天的时间学习<strong>git如何使用</strong>，并记录了阅读笔记，在开发过程中，通过tag和分支保存并同步到github多个版本。</p><p>页面采用<strong>jade语言</strong>写的（问为什么选jade，因为express默认采用了jade模板引擎），这个语言也是之前完全陌生的，所以写的时候遇到很多不知道解决的问题，尽管它确实有很多优势（语法糖、书写简洁、可以嵌套、可以复用等），但是配套的教程文档太少，有时一些特别的问题无从解决。</p><p>在开发过程中，也深切感受到了Express的一些局限（也有可能是我还没有发掘出Express对应的用法）</p><p>比如Express使用jade模板引擎，有一个好处就是每次可以传入不同的数据从而渲染出不同的页面。但是也有一个弊端，就是jade没有办法像html一样嵌入javasript代码或文件，所以想要实现涉及到数据方面的交互很困难（一般都交互还是可以的，把javasript文件放到public目录下就可以引用了）。当时想要在页面里面做一个分类管理的时候，发现没有办法通过js交互来改变显示的数据。</p><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><p>这个项目是在零星学了一些HTML和CSS的基础上开始的，在做这个项目之前没有比较体系化地接受到前端知识的培训，所以在实际做的过程中存在着挺多局限。在写此文的时候，笔者已经较为系统地学习了HTML和CSS的入门知识，就已经发现了一个很不规范的地方，就是页面书写的时候没有结构化的意识，大量使用了div这种无语义的元素（知识局限、不知道有那么多的语义元素），所以写出来的文件可读性较差。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发——JS（一）</title>
    <link href="/2022/04/10/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94JS%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2022/04/10/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94JS%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>6种基本数据类型、判断语句、循环语句、iterable类型、函数的相关知识、高阶函数、闭包……</p><span id="more"></span><h2 id="前端开发——JavaScript"><a href="#前端开发——JavaScript" class="headerlink" title="前端开发——JavaScript"></a>前端开发——JavaScript</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p><strong>在HTML中加载JS</strong></p><ol><li><p><strong>方式一</strong>，在ＨＴＭＬ中通过script标签，将JS代码包裹在内，推荐在外层包裹一层，确保HTML先加载完毕</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim">document.addEventListener(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, function() <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>方式二</strong>，通过script标签引入外部js文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>async关键字</strong>，如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 <code>async</code></p><p><strong>defer关键字</strong>，如果脚本需要等待页面解析，且依赖于其它脚本，调用这些脚本时应使用 <code>defer</code>，将关联的脚本按所需顺序置于 HTML 中</p></li></ol><h3 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li><p>有名函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">abs</span>(<span class="hljs-params">x</span>)&#123;...&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> abs = <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)&#123;...&#125;;<br><span class="hljs-title function_">abs</span>(-<span class="hljs-number">1</span>);  调用<br></code></pre></td></tr></table></figure></li></ul><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>JS允许传入任意参数，可以多、可以少</p><ul><li><p>传入参数为空</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">abs</span>(<span class="hljs-params">x</span>)&#123; <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> x;&#125; <span class="hljs-keyword">return</span> -x;&#125;<br><span class="hljs-title function_">abs</span>();<br></code></pre></td></tr></table></figure><p>这种情况，参数x将收到undefined，返回值为NaN。为了避免收到undefined空参，可以在函数内部进行检查</p></li><li><p>传入参数有多</p><p><strong>arguments</strong>，函数内部可用，指向传入的所有参数，类似Array但不是Array。即使函数不定义任何形参，也可以拿到传入的参数值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">abs</span>(<span class="hljs-params">x</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>;i++)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[i]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>rest参数，ES6标准新引入的</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a,b,...rest</span>)&#123;...&#125;<br></code></pre></td></tr></table></figure><p>rest前面用<code>...</code>标识，以数组的形式保存，b后面的参数，如果没有，那么rest为空数组。可以用来接受数量不固定的参数</p></li></ul><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><ul><li><p>变量在函数内部用<code>var</code>声明，作用域为整个函数体</p></li><li><p>由于函数可以嵌套，所以内部函数可以使用外部函数的变量。如果同名变量，内部变量覆盖外部变量</p></li><li><p>一种特殊情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;...&#125;<br>i++;<span class="hljs-comment">//i=12</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为var声明的变量范围为整个函数体，避免这种情况可以使用<code>let</code>来声明变量 <strong>（ES6新增加，let是定义的变量是块级作用域）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;...&#125;<br>i++;   <span class="hljs-comment">//报错</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>“变量提升”</strong>，JS有一个特性，它会先扫描整个函数体的语句，把变量的声明提升到函数顶部（但是定义并没有提升）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span> + y;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<span class="hljs-comment">//结果为NaN</span><br><span class="hljs-keyword">var</span> y=<span class="hljs-number">2</span>;<span class="hljs-comment">//如果没有这句，将报错</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>全局作用域</strong>，JS有一个默认的全局对象<code>window</code>，所有全局变量绑定为它的一个属性。</p></li><li><p><strong>命名空间</strong>，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突。为了解决这个问题，可以把所有全局变量和顶层函数绑定到一个全局变量中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-variable constant_">MYAPP</span> = &#123;&#125;;<br><span class="hljs-variable constant_">MYAPP</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;app&quot;</span>;<br><span class="hljs-variable constant_">MYAPP</span>.<span class="hljs-property">foo</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;...&#125;;<br></code></pre></td></tr></table></figure></li></ul><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p><strong>从ES6开始</strong>，JavaScript引入了解构赋值，可以同时对一组变量进行赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> [x,y,z] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];  同时给x、y、z赋值，变量要用[..]括起来<br><span class="hljs-keyword">var</span> [x,[y,z]] = [<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]];  结构对应即可<br><span class="hljs-keyword">var</span> [,,z] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];    可以忽略一些元素<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span>,<br>    <span class="hljs-attr">passport</span>: <span class="hljs-string">&#x27;G-12345678&#x27;</span>,<br>    <span class="hljs-attr">school</span>: <span class="hljs-string">&#x27;No.4 middle school&#x27;</span>,<br>    <span class="hljs-attr">address</span>: &#123;<br>        <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>,<br>        <span class="hljs-attr">street</span>: <span class="hljs-string">&#x27;No.1 Road&#x27;</span>,<br>        <span class="hljs-attr">zipcode</span>: <span class="hljs-string">&#x27;100001&#x27;</span><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">var</span> &#123;name,<span class="hljs-attr">address</span>:&#123;city,zip&#125;&#125; = person;  可以直接获取对应的属性，要保证名字和结构对应，zip为<span class="hljs-literal">undefined</span>，因为名字对不上<br></code></pre></td></tr></table></figure><p>如果要使用不一样的变量名字，可以使用下面这种方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> &#123;name,<span class="hljs-attr">passport</span>:id&#125; = person;<br>id  <span class="hljs-comment">//&#x27;G-12345678&#x27;</span><br></code></pre></td></tr></table></figure><p>解构赋值还可以定义默认值，这样可以避免undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> &#123;name,single=<span class="hljs-literal">true</span>&#125; = person;<br>single  <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>注意写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> &#123;x,y&#125; = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">2</span>&#125; 正确<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x,y;<br>&#123;x,y&#125; = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">2</span>&#125;;   报错！<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x,y;<br>(&#123;x,y&#125; = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">2</span>&#125;;)  正确<br></code></pre></td></tr></table></figure><p><strong>使用场景</strong></p><p>如果函数接受一个对象作为参数，那么可以直接用解构赋值的方式把对象的属性写在参数里面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">buildDate</span>(<span class="hljs-params">&#123;year,month,day,hour=<span class="hljs-number">0</span>,minute=<span class="hljs-number">0</span>,second=<span class="hljs-number">0</span>&#125;</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(year + <span class="hljs-string">&#x27; -&#x27;</span> + month + <span class="hljs-string">&#x27;-&#x27;</span> + day + <span class="hljs-string">&#x27; &#x27;</span> + hour + <span class="hljs-string">&#x27;:&#x27;</span> + minute + <span class="hljs-string">&#x27;:&#x27;</span> + second);<br>&#125;<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Date</span> = &#123;<span class="hljs-attr">year</span>:<span class="hljs-number">2022</span>,<span class="hljs-attr">month</span>:<span class="hljs-number">4</span>,<span class="hljs-attr">day</span>:<span class="hljs-number">13</span>&#125;;<br><span class="hljs-title function_">buildDate</span>(<span class="hljs-title class_">Date</span>);<br></code></pre></td></tr></table></figure><h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><p>在一个对象中绑定函数，称为这个对象的方法</p><p><strong>定义方式一：</strong>普遍的定义和使用方式，将函数写在对象内部，用对象.函数()调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xiaoming = &#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&quot;小明&quot;</span>,<br>    <span class="hljs-attr">birth</span>:<span class="hljs-number">1998</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">var</span> y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>();<br>        <span class="hljs-keyword">return</span> y-<span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>;              <span class="hljs-comment">//这里的this指向对象xiaoming</span><br>    &#125; <span class="hljs-comment">//这样定义的好处是明显的，可以随时获得真实的年龄，而不是一个固定不变的数字</span><br>&#125;<br>xiaoming.<span class="hljs-title function_">age</span>(); <br>xiaoming.<span class="hljs-property">age</span>;<span class="hljs-comment">//返回一个function对象</span><br></code></pre></td></tr></table></figure><p><strong>定义方式二：</strong>函数写在外面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAge</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">var</span> y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>();<br>    <span class="hljs-keyword">return</span> y-<span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>;<br>&#125;<br><span class="hljs-keyword">var</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;小明&quot;</span>,<br>    <span class="hljs-attr">birth</span>:<span class="hljs-number">1998</span>,<br>    <span class="hljs-attr">age</span>:getAge<br>&#125;<br>xiaoming.<span class="hljs-title function_">age</span>(); <span class="hljs-comment">//返回正确结果</span><br><span class="hljs-title function_">getAge</span>();       <span class="hljs-comment">//NaN,此时this指向window</span><br><span class="hljs-keyword">var</span> fn = xiaoming.<span class="hljs-property">age</span>;<br><span class="hljs-title function_">fn</span>();           <span class="hljs-comment">//报错，要保证this的指向正确，必须用obj.xxx()的调用方式才行！！</span><br></code></pre></td></tr></table></figure><p><strong>定义方式三：</strong>对象方法内部再定义函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;小明&quot;</span>,<br>    <span class="hljs-attr">birth</span>:<span class="hljs-number">1998</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">getAge</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">var</span> y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>();<br>        <span class="hljs-keyword">return</span> y-<span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>;   <span class="hljs-comment">//这里的this指向了window</span><br>        &#125;     <br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">getAge</span>();<br>    &#125;<br>&#125;<br>xiaoming.<span class="hljs-title function_">age</span>();<span class="hljs-comment">//返回NaN，age方法内部定义的函数，this没有指向对象本身。只有在age方法的函数内才指向对象本身</span><br><br>正确的写法：<br><span class="hljs-keyword">var</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;小明&quot;</span>,<br>    <span class="hljs-attr">birth</span>:<span class="hljs-number">1998</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">var</span> that = <span class="hljs-variable language_">this</span>;<span class="hljs-comment">//关键一步，获取到对象的this</span><br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">getAge</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">var</span> y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>();<br>        <span class="hljs-keyword">return</span> y-that.<span class="hljs-property">birth</span>;   <br>        &#125;     <br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">getAge</span>();<br>    &#125;<br>&#125;<br>xiaoming.<span class="hljs-title function_">age</span>(); <span class="hljs-comment">//返回正确答案</span><br></code></pre></td></tr></table></figure><br><p><strong>apply方法</strong>，要指定函数的this指向哪个对象，可以使用函数自带的apply方法。</p><p>接受参数：参数一：函数要绑定的this变量，参数二：函数本身的参数（一个Array）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAge</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>();<br>    <span class="hljs-keyword">return</span> y - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>;<br>&#125;<br><span class="hljs-keyword">var</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1998</span>,<br>    <span class="hljs-attr">age</span>: getAge<br>&#125;;<br>getAge.<span class="hljs-title function_">apply</span>(xiaoming,[]);<br>getAge.<span class="hljs-title function_">apply</span>(xiaoming);<br></code></pre></td></tr></table></figure><p>普通函数不需要绑定特殊的this变量是，用<code>null</code>代替</p><br><p><strong>call方法</strong>，与apply方法类似</p><ul><li><code>apply()</code>把参数打包成<code>Array</code>再传入；</li><li><code>call()</code>把参数按顺序传入。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>]); <span class="hljs-comment">// 5</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><br><p><strong>装饰器</strong></p><p><strong>利用apply，可以动态改变函数的行为</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> oldParseInt = <span class="hljs-built_in">parseInt</span>;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">parese</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    count+=<span class="hljs-number">1</span>;<br>    oldParseInt.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>,<span class="hljs-variable language_">arguments</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以在不修改源码的基础上，增加函数的功能</p><h3 id="三、高阶函数"><a href="#三、高阶函数" class="headerlink" title="三、高阶函数"></a>三、高阶函数</h3><h4 id="闭包-难点"><a href="#闭包-难点" class="headerlink" title="闭包(难点)"></a>闭包(难点)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">lazy_sum</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">var</span> sum = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">//不能有参数形参，否则会报错</span><br>        <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">x,y</span>)=&gt;</span>x+y);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-keyword">var</span> f = <span class="hljs-title function_">lazy_sum</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);  <span class="hljs-comment">// f获得的是一个已经传入了参数，但是还没有执行的函数</span><br><span class="hljs-title function_">f</span>();<span class="hljs-comment">// 调用f，才会执行函数</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们在函数lazy_sum(arr)中由定义了一个函数sum()，sum()可以使用前者的参数和局部变量，当lazy_sum返回函数时，相关参数和局部变量都保存在了返回的函数中。f变量接收的是一个求和函数，并不是结果。调用f才能获得结果。</p><p>每次调用lazy_sum()都返回一个新的函数（即使传入相同的参数）</p><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> arr = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>        arr.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> i*i;<br>        &#125;)<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-keyword">var</span> results = <span class="hljs-title function_">count</span>();<br><span class="hljs-keyword">var</span> f1 = results[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">var</span> f2 = results[<span class="hljs-number">1</span>];<br><span class="hljs-title function_">f1</span>();<span class="hljs-comment">//9</span><br><span class="hljs-title function_">f2</span>();<span class="hljs-comment">//9</span><br></code></pre></td></tr></table></figure><p>期望的结果应该是1，4。但是实际结果为9，9。这是因为返回的函数引用了变量i，但是没有立即执行，等到执行的时候，i已经变成3了。<strong>返回的闭包不应该使用循环变量、或者后续会发生变化的变量</strong>，如果一定要引用循环变量，方法是再创建一个函数，用该函数的参数绑定循环变量当前的值。对上面代码的修改如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> arr = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>        arr.<span class="hljs-title function_">push</span>((<span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                <span class="hljs-keyword">return</span> n*n;<br>            &#125;<br>        &#125;)(i));<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-keyword">var</span> results = <span class="hljs-title function_">count</span>();<br><span class="hljs-keyword">var</span> f1 = results[<span class="hljs-number">0</span>];<br><span class="hljs-title function_">f1</span>();<br></code></pre></td></tr></table></figure><p><strong>返回的那个函数变量的形参对应的是f1()的实参，外层函数的形参对应的是count()的实参！</strong></p><p>在push里面定义了一个匿名函数，然后在外层在用一对括号包裹起来，直接调用</p><p><code>(function(n)&#123;return function()&#123;return n*n;&#125;&#125;)(i);</code></p><blockquote>通常，一个立即执行的匿名函数可以把函数体拆开     <p>(function (x) {return x * x;})(3);</p></blockquote><br><p><strong>闭包有非常强大的功能</strong>。举个栗子：</p><p>在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用<code>private</code>修饰一个成员变量。</p><p>在没有<code>class</code>机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">create_counter</span>(<span class="hljs-params">inital</span>)&#123;<br>    <span class="hljs-keyword">var</span> x = inital || <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>        inc : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            x += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> c1 = <span class="hljs-title function_">create_counter</span>();<br>c1.<span class="hljs-title function_">inc</span>();<span class="hljs-comment">//1</span><br>c1.<span class="hljs-title function_">inc</span>();<span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> x++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> f = <span class="hljs-title function_">count</span>();<br><span class="hljs-title function_">f</span>();<span class="hljs-comment">//0</span><br><span class="hljs-title function_">f</span>();<span class="hljs-comment">//1，因为使用的是同一个变量</span><br><span class="hljs-keyword">var</span> f1 = <span class="hljs-title function_">count</span>();<br><span class="hljs-title function_">f1</span>();<span class="hljs-comment">//0，重新定义后，生成了一组新的变量</span><br></code></pre></td></tr></table></figure><p>现在我还不知道闭包的实现原理是怎么样的，但是通过实践可以发现，闭包引用的是函数内部的变量，每定义一次，就会生成一组变量，这个变量会一直被记录。而且这组变量是外部访问不到的，就达到了C++类私有变量的效果。</p><br><p>还可以将多参数的函数变成单参数的函数，如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">make_pow</span>(<span class="hljs-params">n</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)&#123;<span class="hljs-comment">//这个是返回的函数，和它所带的参数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(x,n);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> pow2 = <span class="hljs-title function_">make_pow</span>(<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">pow2</span>(<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><h4 id="箭头函数（ES6）"><a href="#箭头函数（ES6）" class="headerlink" title="箭头函数（ES6）"></a>箭头函数（ES6）</h4><p>箭头函数有两种形式</p><p>一种是省略了<code>&#123;...&#125;</code>和<code>return</code>。一种是不能省略<code>&#123;...&#125;</code>和<code>return</code>的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)&#123;<span class="hljs-keyword">return</span> x*x;&#125; <br>相当于：<br>x =&gt; x*x<br>x =&gt; &#123;<br>    <span class="hljs-keyword">return</span> x*x;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果函数参数有多个，需要用<code>()</code>括起来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(x,y) =&gt; x*y<br></code></pre></td></tr></table></figure><p>如果要返回一个对象，也要特别注意</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">x =&gt; &#123;<span class="hljs-attr">foo</span>:x&#125;<span class="hljs-comment">//报语法错误</span><br>x =&gt; ( &#123;<span class="hljs-attr">foo</span>:x&#125; )<br></code></pre></td></tr></table></figure><br><p><strong>this，箭头函数内部的<code>this</code>是词法作用域，由上下文确定</strong>。this总是指向词法作用域，也就是外层调用者obj</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;小明&quot;</span>,<br>    <span class="hljs-attr">birth</span>:<span class="hljs-number">1998</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">var</span> <span class="hljs-title function_">getAge</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>()-<span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>; <br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">getAge</span>();<br>    &#125;<br>&#125;<br>xiaoming.<span class="hljs-title function_">age</span>();<br></code></pre></td></tr></table></figure><p>由于this已经按照词法作用域进行绑定了，所以<code>call</code>和<code>apply</code>也没有办法修改this指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">getAge</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">year</span>)&#123;<br>      <span class="hljs-keyword">var</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">y</span>) =&gt; y-<span class="hljs-variable language_">this</span>.<span class="hljs-property">year</span>;<br>        fn.<span class="hljs-title function_">call</span>(&#123;<span class="hljs-attr">birth</span>:<span class="hljs-number">2000</span>&#125;,year);<span class="hljs-variable language_">this</span>已经按照词法作用域绑定，call指定失效。<br>    &#125;<br>&#125;<br>obj.<span class="hljs-title function_">getAge</span>(<span class="hljs-number">2022</span>);<span class="hljs-comment">//32</span><br></code></pre></td></tr></table></figure><h3 id="四、疑问"><a href="#四、疑问" class="headerlink" title="四、疑问"></a>四、疑问</h3><h4 id="iterator和iterable的区别"><a href="#iterator和iterable的区别" class="headerlink" title="iterator和iterable的区别"></a>iterator和iterable的区别</h4><h4 id="JacaScript内部的属性"><a href="#JacaScript内部的属性" class="headerlink" title="JacaScript内部的属性"></a>JacaScript内部的属性</h4><p>prototype属性、</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// yield可以返回值，第一次调用就返回了</span><br><span class="hljs-comment">// yield关键字还可以作为函数的中间参数使用，但是第一次调用next()传入的值不会被使用，因为这一次调用是为了开始执行生成器函数</span><br><span class="hljs-keyword">function</span>* <span class="hljs-title class_">Fn</span>(init)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">yield</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">yield</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">yield</span>);<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Ob</span> = <span class="hljs-title class_">Fn</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-title class_">Ob</span>.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);<span class="hljs-comment">//&#123;value: undefined, done: false&#125;</span><br><span class="hljs-title class_">Ob</span>.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;baz&#x27;</span>);<span class="hljs-comment">//&#123;value: undefined, done: false&#125;</span><br><span class="hljs-title class_">Ob</span>.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;qux&#x27;</span>);<br><span class="hljs-title class_">Ob</span>.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;end&#x27;</span>);<span class="hljs-comment">//&#123;value: undefined, done: true&#125;</span><br><span class="hljs-title class_">Ob</span>.<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;outer&#x27;</span>);<span class="hljs-comment">//&#123;value: undefined, done: true&#125;</span><br><br><span class="hljs-keyword">function</span>* <span class="hljs-title class_">Fn2</span>()&#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Ob2</span> = <span class="hljs-title class_">Fn2</span>();<br><span class="hljs-title class_">Ob2</span>.<span class="hljs-title function_">next</span>();<span class="hljs-comment">//&#123;value: 1, done: false&#125;</span><br></code></pre></td></tr></table></figure><h4 id="对象的定义方式v-s字面量表达式"><a href="#对象的定义方式v-s字面量表达式" class="headerlink" title="对象的定义方式v.s字面量表达式"></a>对象的定义方式v.s字面量表达式</h4>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构——队列</title>
    <link href="/2022/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/"/>
    <url>/2022/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>FIFO，先进先出</p><span id="more"></span><h2 id="数据结构——队列"><a href="#数据结构——队列" class="headerlink" title="数据结构——队列"></a>数据结构——队列</h2><p><strong>语法：</strong><code>template&lt;class T, class Container = deque&lt;T&gt; &gt; class queue</code></p><p><strong>特性：FIFO</strong>，先进先出，队尾插入、队头删除</p><p><strong>引用：</strong><code>include&lt;queue&gt;</code></p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><table><thead><tr><th>empty</th><th>如果队列为空，则该函数返回true，否则返回false</th></tr></thead><tbody><tr><td><strong>size</strong></td><td>返回队列中元素的个数</td></tr><tr><td><strong>push</strong></td><td>在末尾插入一个新元素，返回值为void</td></tr><tr><td><strong>pop</strong></td><td>删除第一个元素，返回值为void</td></tr><tr><td><strong>front</strong></td><td>返回第一个元素</td></tr><tr><td><strong>back</strong></td><td>返回最后一个元素</td></tr></tbody></table><h4 id="leetcode题库"><a href="#leetcode题库" class="headerlink" title="leetcode题库"></a>leetcode题库</h4><table><thead><tr><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>225.用队列实现栈</td><td>双队列，push时不断交换，让栈顶始终在队头</td></tr><tr><td>232.用栈实现队列</td><td>双栈，push时不断倒换，让队头始终在栈顶</td></tr><tr><td>341.扁平化嵌套列表迭代器</td><td>深度优先遍历 + 队列的应用 + 现学接口如何使用</td></tr><tr><td>387.第一个唯一字符</td><td>两次遍历字符串，用map或者int数组保存字符出现次数，简单题</td></tr><tr><td>239.滑动窗口最大值</td><td>双向队列deque，保存数组指针（而非数组值），队头到队尾单调递减。空间换时间，困难题<br />拓展：滑动窗口平均值</td></tr></tbody></table><h2 id="双向队列，deque"><a href="#双向队列，deque" class="headerlink" title="双向队列，deque"></a>双向队列，deque</h2><p><strong>引用：</strong><code>include&lt;deque&gt;</code></p><h4 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h4><table><thead><tr><th><strong>push_back</strong></th><th>插入队尾</th></tr></thead><tbody><tr><td><strong>push_front</strong></td><td>插入队头</td></tr><tr><td><strong>pop_back</strong></td><td>从队尾删除</td></tr><tr><td><strong>pop_front</strong></td><td>从队头删除</td></tr><tr><td><strong>front</strong></td><td>返回队头元素</td></tr><tr><td><strong>back</strong></td><td>返回队尾元素</td></tr><tr><td><strong>insert</strong></td><td>insert (iterator position, const value_type&amp; val)，指定位置插入值<br />void insert (iterator position, size_type n, const value_type&amp; val)，指定位置插入值，重复插入n个<br />void insert (iterator position, InputIterator first, InputIterator last)，指定位置插入另外一个容器的值列表</td></tr><tr><td><strong>erase</strong></td><td>两种参数，<br />erase (iterator position);<br />erase (iterator first, iterator last);</td></tr><tr><td><strong>size</strong></td><td></td></tr></tbody></table><h3 id="优先队列，priority-queue"><a href="#优先队列，priority-queue" class="headerlink" title="优先队列，priority_queue"></a>优先队列，priority_queue</h3><p><strong>引用：</strong><code>include&lt;queue&gt;</code></p><p><strong>特性：</strong>优先队列类似于堆，其中优先级最高的元素会被最先pop()弹出，或者用top()访问优先级最高的元素。</p><p><strong>语法：priority_queue&lt;Type, Container, Functional&gt;</strong></p><ul><li><p>其中type为数据类型，Container为容器类型，Functional是比较方式</p></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//升序队列</span><br>priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt; q;<br><span class="hljs-comment">//降序队列</span><br>priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,less&lt;<span class="hljs-type">int</span>&gt; &gt;q;<br><span class="hljs-comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span><br><br><span class="hljs-comment">//对于基础类型 默认是大顶堆</span><br>priority_queue&lt;<span class="hljs-type">int</span>&gt; a; <br><span class="hljs-comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span><br><br><span class="hljs-comment">//结构体自定义排序方法</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tmp1</span> <span class="hljs-comment">//运算符重载&lt;</span><br>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">tmp1</span>(<span class="hljs-type">int</span> a) &#123;x = a;&#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> tmp1&amp; a) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> x &lt; a.x; <span class="hljs-comment">//大顶堆</span><br>    &#125;<br>&#125;;<br>priority_queue&lt;tmp1&gt; pq;<br></code></pre></td></tr></table></figure></li></ul><h4 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h4><table><thead><tr><th><strong>push()</strong></th><th>它将新元素插入优先队列。</th></tr></thead><tbody><tr><td><strong>pop()</strong></td><td>它将优先级最高的元素从队列中删除。</td></tr><tr><td><strong>top()</strong></td><td>此函数用于寻址优先队列的最顶层元素。</td></tr><tr><td><strong>swap()</strong></td><td>它将优先队列的元素与具有相同类型和大小的另一个队列交换。</td></tr><tr><td><strong>size()</strong></td><td>返回优先队列的大小。</td></tr><tr><td><strong>empty()</strong></td><td>它验证队列是否为空。基于验证，它返回队列的状态。</td></tr><tr><td><strong>emplace()</strong></td><td>它在优先队列的顶部插入一个新元素。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发——JavaScript</title>
    <link href="/2022/04/02/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94JavaScript/"/>
    <url>/2022/04/02/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94JavaScript/</url>
    
    <content type="html"><![CDATA[<p>JavaScript是异步的</p><span id="more"></span><h3 id="一、Callback-回调机制"><a href="#一、Callback-回调机制" class="headerlink" title="一、Callback(回调机制)"></a>一、Callback(回调机制)</h3><p>JavaScript是异步执行的，看以下例子</p><ul><li>例一，</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">first</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">second</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-title function_">first</span>();<br><span class="hljs-title function_">second</span>();<br>输出结果为:<span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><ul><li>例二</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">first</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    &#125;,<span class="hljs-number">500</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">second</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-title function_">first</span>();<br><span class="hljs-title function_">second</span>();<br>输出结果为:<span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>解释：JavaScript是异步的，所有延迟处理会被放到循环队列里</p><p><strong>简单的定义：</strong>回调就是一个在另外一个函数执行完后要执行的函数</p><p><strong>定义方式：</strong>在函数定义时，加入一个callback参数</p><p><strong>调用方式：</strong>调用函数时，直接在callback参数位置定义回调执行的函数体（例一）；在callback参数位置传入另外一个函数名作为回调函数执行（例二）</p><p>见下面例子：</p><ul><li>例一</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doHomework</span>(<span class="hljs-params">subject,callback</span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;do $&#123;subject&#125; homework&#x27;</span>);<br>&#125;;<br><br><span class="hljs-title function_">doHomework</span>(<span class="hljs-string">&#x27;math&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finish math homework&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>例二</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doHomework</span>(<span class="hljs-params">subject,callback</span>)&#123;<br>conse.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;do $&#123;subject&#125; homework&#x27;</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">finishHomework</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finish homework&#x27;</span>);<br>&#125;;<br><br><span class="hljs-title function_">doHomework</span>(<span class="hljs-string">&#x27;math&#x27;</span>,finishHomework);<br></code></pre></td></tr></table></figure><h3 id="二、Async"><a href="#二、Async" class="headerlink" title="二、Async"></a>二、Async</h3><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><p>作为一个关键字放到函数前面，用于表示函数是一个异步函数，异步函数也就意味着该函数的执行不会阻塞后面代码的执行。</p><p>实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">timeout</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;)<br>&#125;<br><span class="hljs-title function_">timeout</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello2&#x27;</span>)<br>输出结果：<br>hello2<br>hello<br></code></pre></td></tr></table></figure><p>async 函数返回的是一个promise 对象，如果要获取到promise 返回值，我们应该用then 方法</p><h4 id="await关键字"><a href="#await关键字" class="headerlink" title="await关键字"></a>await关键字</h4><p><strong>await 关键字只能放到async 函数里面</strong></p><p>await后面可以放任何表达式，更多的是放一个返回promise 对象的表达式，使用await关键字之后，表示等待异步函数执行完成之后，才继续执行后面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doubleAfter2seconds</span>(<span class="hljs-params">num</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-title function_">resovle</span>(<span class="hljs-number">2</span> * num)<br>        &#125;,<span class="hljs-number">2000</span>);<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testResult</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> result1= <span class="hljs-keyword">await</span> <span class="hljs-title function_">doubleAfter2seconds</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">let</span> result2= <span class="hljs-keyword">await</span> <span class="hljs-title function_">doubleAfter2seconds</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1+result2);<br>&#125;<br><span class="hljs-title function_">testResult</span>();<br><span class="hljs-number">4</span>秒后，输出结果:<br><span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><p><strong>捕获错误，使用try-catch的方式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testResult</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-keyword">let</span> result1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">doubleAfter2seconds</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">let</span> result2= <span class="hljs-keyword">await</span> <span class="hljs-title function_">doubleAfter2seconds</span>(<span class="hljs-number">20</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1+result2);<br>&#125;<span class="hljs-keyword">catch</span>(err)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解决“回调地狱”问题"><a href="#解决“回调地狱”问题" class="headerlink" title="解决“回调地狱”问题"></a>解决“回调地狱”问题</h4><p>Async.js可将一系列函数粘连起来，既可以是串行，也可以是并行。</p><p>使用之前需要先安装async包，</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install <span class="hljs-keyword">async</span> —-save<br></code></pre></td></tr></table></figure><p>场景实例：先后读取两个文本数据，按顺序展示文本</p><ul><li>使用callback回调的方式，嵌套读取</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs  = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">readFile</span>(<br>    <span class="hljs-string">&#x27;a-text-file.txt&#x27;</span>,      <span class="hljs-comment">//读取第一个文本</span><br>    <span class="hljs-string">&#x27;utf8&#x27;</span>,                <br>    <span class="hljs-keyword">function</span>(<span class="hljs-params">err,text</span>) &#123;    <span class="hljs-comment">//读取完成，回调</span><br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);           <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;First text file:&#x27;</span>,text);    <span class="hljs-comment">//显示第一段文本</span><br>            fs.<span class="hljs-title function_">readFile</span>(<br>                <span class="hljs-string">&#x27;another-text-file.txt&#x27;</span>,  <span class="hljs-comment">//读取第二个文本</span><br>                <span class="hljs-string">&#x27;utf8&#x27;</span>,                   <br>                <span class="hljs-keyword">function</span>(<span class="hljs-params">err,text</span>) &#123;      <span class="hljs-comment">//读取完成，回调</span><br>                    <span class="hljs-keyword">if</span> (err) &#123;<br>                        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);                      <br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Second text file:&#x27;</span>,text);    <span class="hljs-comment">//显示第二段文本</span><br>                    &#125;<br>                &#125;<br>            );<br>        &#125;<br>    &#125;<br>); <br></code></pre></td></tr></table></figure><p>缺点：嵌套使得可读性、可维护性变差，串行加载，时间效率低</p><ul><li>使用async的方式（简洁、高效）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs  = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">var</span> <span class="hljs-keyword">async</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;async&#x27;</span>);<br><br><span class="hljs-keyword">async</span>.<span class="hljs-title function_">series</span>([<br><br><span class="hljs-keyword">function</span>(<span class="hljs-params">cb</span>)&#123;<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;a-text-file.txt&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,cb);<br>&#125;,<br><br><span class="hljs-keyword">function</span>(<span class="hljs-params">cb</span>)&#123;<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;another-text-file.txt&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,cb);<br>&#125;<br><br>],<span class="hljs-keyword">function</span>(<span class="hljs-params">err,value</span>)&#123;<br><span class="hljs-keyword">if</span>(err) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;File 1:&#x27;</span>,values[<span class="hljs-number">0</span>]);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;File 2:&#x27;</span>,values[<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p> async.series取一个函数数组作为参数，并串行执行它们；</p><p>每个函数只能有一个参数，即回调（cb）。cb执行时应该与其他任意回调一样具有相同类型的参数，所以我们将其传入为fs.readFile的参数；</p><p>最后，它们的结果被发送到最后的回调，即async.series的第二个参数。 这些结果被存在一个数组中，它们按async.series第一个参数中的函数的顺序而排列。</p><p>通过async.js，错误处理被简化了，因为如果遇到一个错误，它会返回错误到最后一个回调中，并且不在执行任何其他异步函数。</p><h3 id="三、条件判断"><a href="#三、条件判断" class="headerlink" title="三、条件判断"></a>三、条件判断</h3><p><strong>判等</strong></p><img src="前端开发——JavaScript.assets/image-20220326212616410.png" alt="image-20220326212616410" style="zoom:50%;" /><p><strong>判断空数组</strong></p><p>通过array.length 判断，如果array.length&#x3D;&#x3D;&#x3D;0 ，数组为空</p><p><strong>判断空集合</strong></p><p>通过keys的长度判断，如果Object.keys(obj).length&#x3D;&#x3D;&#x3D;0，集合为空</p><h3 id="四、数组"><a href="#四、数组" class="headerlink" title="四、数组"></a>四、数组</h3><p><strong>插入</strong></p><p>头插入：<code>数组.unshift(元素)</code></p><p>尾插入：<code>数组.push(元素)</code></p><h3 id="五、script设置点击事件"><a href="#五、script设置点击事件" class="headerlink" title="五、script设置点击事件"></a>五、script设置点击事件</h3><p><strong>方式一：通过addEventListener方法添加</strong></p><ul><li>参数一：执行的事件</li><li>参数二：事件发生后的回调方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">666</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>或者把函数体写在外面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">666</span>);<br>&#125;<br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>,test);<br></code></pre></td></tr></table></figure><p><strong>方式二：通过元素属性添加</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">btn.onclick = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">666</span>);&#125;<br>或者<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">666</span>);<br>&#125;<br>btn.onclick = test;<br></code></pre></td></tr></table></figure><h3 id="六、script获取控件元素"><a href="#六、script获取控件元素" class="headerlink" title="六、script获取控件元素"></a>六、script获取控件元素</h3><p><strong>方式一：通过document.getElementById(“id”)获取</strong></p><p><strong>方式二：通过css选择器，document.querySelector(#id)获取</strong></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记——bootstrap框架</title>
    <link href="/2022/04/02/%E5%89%8D%E7%AB%AF/%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94bootstrap%E6%A1%86%E6%9E%B6/"/>
    <url>/2022/04/02/%E5%89%8D%E7%AB%AF/%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94bootstrap%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>bootstrap框架一些常用元素的笔记</p><span id="more"></span><h3 id="一、布局"><a href="#一、布局" class="headerlink" title="一、布局"></a>一、布局</h3><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220321223711524.png" alt="image-20220321223711524"></p><h4 id="列布局"><a href="#列布局" class="headerlink" title="列布局"></a>列布局</h4><p>相当于flex布局</p><table><thead><tr><th>属性</th><th>css</th><th>bootstrap</th></tr></thead><tbody><tr><td>主轴对齐方式</td><td>justify-content: space-between</td><td><br />justify-content-center</td></tr><tr><td>交叉轴对齐方式</td><td>align-items: flex-start</td><td>align-items-start</td></tr><tr><td>子元素交叉轴对齐</td><td>align-self: start</td><td>align-self-start</td></tr></tbody></table><h4 id="间隙"><a href="#间隙" class="headerlink" title="间隙"></a>间隙</h4><table><thead><tr><th>属性</th><th>css</th><th>bootstrap</th></tr></thead><tbody><tr><td>内边距</td><td>padding&#x3D;**</td><td>p-5（水平+垂直）  px-5（水平内边距）  py-5（垂直内边距）</td></tr><tr><td>外边距</td><td>margin &#x3D; **</td><td>g-5（水平+垂直）  gx-5（水平外边距）  gy-5（垂直外边距）</td></tr></tbody></table><p>建议在父级容器中添加 overflow-hidden 的类属性</p><h4 id="边界border"><a href="#边界border" class="headerlink" title="边界border"></a>边界border</h4><p>通过添加 border类名 为容器添加边界</p><h3 id="二、文本"><a href="#二、文本" class="headerlink" title="二、文本"></a>二、文本</h3><h4 id="文本对齐"><a href="#文本对齐" class="headerlink" title="文本对齐"></a>文本对齐</h4><table><thead><tr><th>.text-center</th><th>居中</th></tr></thead><tbody><tr><td>.text-start</td><td>居左</td></tr><tr><td>.text-end</td><td>居右</td></tr><tr><td>.text-sm-center</td><td>响应式的对齐方式</td></tr></tbody></table><h4 id="自动换行"><a href="#自动换行" class="headerlink" title="自动换行"></a>自动换行</h4><table><thead><tr><th>.text-wrap</th><th>自动换行</th></tr></thead><tbody><tr><td>.text-nowrap</td><td>不换行</td></tr><tr><td>.text-break</td><td>文本断行（防止长单词溢出）</td></tr></tbody></table><h4 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h4><table><thead><tr><th>.text-lowercase</th><th>全部转为小写</th></tr></thead><tbody><tr><td>.text-uppercase</td><td>全部转为大写</td></tr></tbody></table><h4 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h4><p>.fs-1  .fs-2 …</p><h4 id="字体粗细和斜体"><a href="#字体粗细和斜体" class="headerlink" title="字体粗细和斜体"></a>字体粗细和斜体</h4><p>font-weight通用类别的缩写为.fw-* </p><p>font-style通用类别的缩写为.fst-*</p><table><thead><tr><th>fw-bold</th><th>加粗</th></tr></thead><tbody><tr><td>fw-bolder</td><td>再加粗</td></tr><tr><td>fw-light</td><td>浅色</td></tr><tr><td>fw-lighter</td><td>再浅色</td></tr><tr><td>fst-italic</td><td>斜体</td></tr></tbody></table><h4 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h4><p>使用.lh-*通用类别来改变行高</p><table><thead><tr><th>lh-base</th><th>1.5倍行高</th></tr></thead><tbody><tr><td>lh-lg</td><td>2倍行高</td></tr></tbody></table><h4 id="旁注小文本"><a href="#旁注小文本" class="headerlink" title="旁注小文本"></a>旁注小文本</h4><p>内联文本元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">figure</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;blockquote&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A well-known quote, contained in a blockquote element.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">figcaption</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;blockquote-footer&quot;</span>&gt;</span><br>Someone famous in <span class="hljs-tag">&lt;<span class="hljs-name">cite</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Source Title&quot;</span>&gt;</span>Source Title<span class="hljs-tag">&lt;/<span class="hljs-name">cite</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">figcaption</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220328181502807.png" alt="image-20220322150011313"></p><h3 id="三、列表"><a href="#三、列表" class="headerlink" title="三、列表"></a>三、列表</h3><h4 id="无样式"><a href="#无样式" class="headerlink" title="无样式"></a>无样式</h4><p>*注意：只对直接子元素生效</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-unstyled&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="内联子元素"><a href="#内联子元素" class="headerlink" title="内联子元素"></a>内联子元素</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-inline-item&quot;</span>&gt;</span>This is a list item.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="dl-amp-dt-amp-dd"><a href="#dl-amp-dt-amp-dd" class="headerlink" title="dl &amp; dt &amp; dd"></a>dl &amp; dt &amp; dd</h4><p>描述型列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-3&quot;</span>&gt;</span>Description lists<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dd</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-9&quot;</span>&gt;</span>A description list is perfect for defining terms.<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-3&quot;</span>&gt;</span>Term<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dd</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-9&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Definition for the term.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And some more placeholder definition text.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-3&quot;</span>&gt;</span>Another term<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dd</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-9&quot;</span>&gt;</span>This definition is short, so no extra paragraphs or anything.<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-3 text-truncate&quot;</span>&gt;</span>Truncated term is truncated<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dd</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-9&quot;</span>&gt;</span>This can be useful when space is tight. Adds an ellipsis at the end.<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-3&quot;</span>&gt;</span>Nesting<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dd</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-9&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dl</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-4&quot;</span>&gt;</span>Nested definition list<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dd</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-8&quot;</span>&gt;</span>I heard you like definition lists. Let me put a definition list inside your definition list.<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220322150011313.png" alt="image-20220322150543976"></p><h3 id="四、图片"><a href="#四、图片" class="headerlink" title="四、图片"></a>四、图片</h3><h4 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h4><p>通过 Bootstrap 所提供的<code>.img-fluid</code> 类让图片支持响应式布局。其原理是将<code>max-width: 100%;</code> 和 <code>height: auto;</code> 赋予图片，以便随父元素一起缩放。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-fluid&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="缩略图"><a href="#缩略图" class="headerlink" title="缩略图"></a>缩略图</h4><p>200 x 200 尺寸，带有1px宽度的圆形边框</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-thumbnail&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h4><p>.rounded 是一个200 x 200的 img元素</p><ul><li>靠左&#x2F;靠右对齐</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rounded float-start&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rounded float-end&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>居中对齐</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">方式一：<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rounded mx-auto d-block&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>方式二：<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-center&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rounded&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="五、轮廓-Figures"><a href="#五、轮廓-Figures" class="headerlink" title="五、轮廓 Figures"></a>五、轮廓 Figures</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">figure</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;figure&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;figure-img img-fluid rounded&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">figcaption</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;figure-caption text-end&quot;</span>&gt;</span>A caption for the above image.<span class="hljs-tag">&lt;/<span class="hljs-name">figcaption</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220322150543976.png" alt="image-20220322152325398"></p><h3 id="六、表单"><a href="#六、表单" class="headerlink" title="六、表单"></a>六、表单</h3><p><strong>禁用控件：</strong>在属性中添加disabled</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;disabledInput&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Disabled input here...&quot;</span> <span class="hljs-attr">disabled</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>只读文本：</strong>在属性中添加readonly</p><h3 id="七、颜色"><a href="#七、颜色" class="headerlink" title="七、颜色"></a>七、颜色</h3><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220322152325398.png" alt="image-20220328181502807" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bootstrap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习笔记</title>
    <link href="/2022/04/02/Git/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/02/Git/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>学习使用Git过程的一些笔记，方便日常使用查询</p><span id="more"></span><h2 id="Git学习笔记"><a href="#Git学习笔记" class="headerlink" title="Git学习笔记"></a>Git学习笔记</h2><h3 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h3><ol><li><p>初始化仓库</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure></li><li><p>把文件添加到暂存区</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">git <span class="hljs-built_in">add</span> <span class="hljs-built_in">file</span>.txt<br></code></pre></td></tr></table></figure></li><li><p>把暂存区的所有文件提交到仓库的当前分支</p><p>一次可以commit多个add的文件，创建仓库时，默认创建一个master分支</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;提交时的描述&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>查看仓库当前状态</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git status</span><br></code></pre></td></tr></table></figure></li><li><p>查看修改内容</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git diff <span class="hljs-built_in">file</span>.txt<br>可以查看 <span class="hljs-built_in">file</span>.txt 与上次提交相比，更改了哪些内容<br></code></pre></td></tr></table></figure></li></ol><h3 id="二、全局配置"><a href="#二、全局配置" class="headerlink" title="二、全局配置"></a>二、全局配置</h3><p>查看</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--list</span><br></code></pre></td></tr></table></figure><p>设置</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;Your Name&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>删除配置</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">git config</span> <span class="hljs-literal">--</span><span class="hljs-comment">global</span> <span class="hljs-literal">--</span><span class="hljs-comment">unset user</span><span class="hljs-string">.</span><span class="hljs-comment">name</span><br></code></pre></td></tr></table></figure><h3 id="三、版本回退"><a href="#三、版本回退" class="headerlink" title="三、版本回退"></a>三、版本回退</h3><ol><li><p>查看历史提交记录</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git <span class="hljs-built_in">log</span> [<span class="hljs-comment">--pretty=oneline]</span><br></code></pre></td></tr></table></figure><p>显示从最近到最远的提交日志，添加参数可以精简打印的内容</p></li><li><p>版本回退</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^</span><br></code></pre></td></tr></table></figure><p>HEAD^ 表示上一个版本，</p><p>也可以通过commit id来更改版本，下面介绍</p></li><li><p>查找commit id ，等同于查阅历史命令</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">git <span class="hljs-built_in">ref</span>log<br></code></pre></td></tr></table></figure><p>将输出类似于下面的东西</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">e475afc HEAD@&#123;<span class="hljs-number">1</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> HEAD^<br><span class="hljs-number">1094</span>adb (HEAD -&gt; master) HEAD@&#123;<span class="hljs-number">2</span>&#125;: <span class="hljs-keyword">commit</span>: append GPL<br>e475afc HEAD@&#123;<span class="hljs-number">3</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">add</span> distributed<br></code></pre></td></tr></table></figure><p>每行第一个就是commit id</p><p>可以通过下面的命令，<strong>更改到指定版本</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard 1094a</span><br></code></pre></td></tr></table></figure><p>*注：1094a为版本号的前几位</p></li></ol><h3 id="四、撤销修改"><a href="#四、撤销修改" class="headerlink" title="四、撤销修改"></a>四、撤销修改</h3><ul><li><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git checkout <span class="hljs-comment">-- file</span><br></code></pre></td></tr></table></figure><p>两种情况：</p><ul><li><p>文件修改后，没有<code>git add file</code>到暂存区：</p><p>那么将恢复到上一次commit的状态</p></li></ul></li><li><p>文件<code>git add file</code>添加到暂存区之后：</p><p>不管有没有做修改，都将恢复到添加到暂存区时的状态</p></li><li><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，把暂存区的修改也丢掉</p><p>第一步：把暂存区的修改退回工作区</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">git <span class="hljs-keyword">reset</span> HEAD <span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><p>第二步：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git checkout <span class="hljs-comment">-- file</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="五、删除文件"><a href="#五、删除文件" class="headerlink" title="五、删除文件"></a>五、删除文件</h3><ul><li><p>删除本地和版本库两个地方的文件</p><p>本地使用本地的删除方法，</p><p>这里介绍git的删除方法：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">git <span class="hljs-keyword">rm</span> <span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><p>删除后需要commit才能生效</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;remove file&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>误删本地文件，从版本库恢复</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git checkout <span class="hljs-comment">-- file</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="六、分支管理"><a href="#六、分支管理" class="headerlink" title="六、分支管理"></a>六、分支管理</h3><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>创建一个名为dev的分支</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch dev</span><br></code></pre></td></tr></table></figure><p>创建的新分支，建立在当前分支的基础上</p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220323103134658.png" alt="image-20220323103134658" style="zoom:50%;" /><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><p>从当前分支切换到dev分支</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">git <span class="hljs-keyword">switch</span> dev<br></code></pre></td></tr></table></figure><p>创建并切换分支</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">git <span class="hljs-keyword">switch</span> -<span class="hljs-keyword">c</span> dev<br></code></pre></td></tr></table></figure><h4 id="查看当前分支"><a href="#查看当前分支" class="headerlink" title="查看当前分支"></a>查看当前分支</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span><br></code></pre></td></tr></table></figure><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><p>将指定分支合并到当前分支，例如：当前分支为master，下面命令将dev分支合并到master分支上</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">git <span class="hljs-keyword">merge</span> dev  这种方式删除分支后，会丢掉分支信息<br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">git <span class="hljs-built_in">merge</span> <span class="hljs-comment">--no-ff dev   这种方式从分支历史上就可以看出分支信息</span><br></code></pre></td></tr></table></figure><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><p>删除dev分支</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch -d dev</span><br></code></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">git</span> <span class="hljs-variable">branch</span> <span class="hljs-operator">-</span><span class="hljs-built_in">D</span> <span class="hljs-variable">dev</span>  强行删除一个没有被合并过的新分支<br></code></pre></td></tr></table></figure><h4 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h4><ul><li>分工合作策略</li></ul><table><thead><tr><th>master</th><th>稳定版本的分支</th></tr></thead><tbody><tr><td>dev</td><td>实际工作过程中使用的主分支，dev完成阶段任务时，才把dev分支合并到master上</td></tr><tr><td>user1</td><td>工作分支一，在dev分支的基础上创建，完成任务后，合并到dev分支</td></tr><tr><td>user2</td><td>工作分支二</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220323104839946-16488933038285.png" alt="image-20220323104839946"></p><ul><li>依赖分支实现的版本管理策略（串行策略）</li></ul><table><thead><tr><th>master</th><th>最新分支</th></tr></thead><tbody><tr><td>dev1</td><td>工作阶段一分支，完成后在此分支上创建dev2，合并dev1到master，切换都dev2继续工作</td></tr><tr><td>dev2</td><td>工作阶段二分支，同上</td></tr><tr><td>…</td><td></td></tr><tr><td>dev9</td><td>最后一个工作阶段，完成后，合并dev9到master，不必再创建新分支</td></tr></tbody></table><p>这样就实现了一个分支一个版本</p><h3 id="七、远程仓库"><a href="#七、远程仓库" class="headerlink" title="七、远程仓库"></a>七、远程仓库</h3><p><strong>由于本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要设置SSH Key</strong></p><p><strong>创建SSH Key</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥</p><p><strong>登陆GitHub，打开“Account settings”，“SSH Keys”页面</strong></p><p><strong>点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容</strong></p><p><strong>点“Add Key”</strong></p><p><strong>查看远程仓库信息</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git remote -v</span><br></code></pre></td></tr></table></figure><p><strong>推送分支</strong></p><p>推送时，要指定本地分支（如：master），git会把该分支推送到远程库的对应分支上</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><p>如果是在远程仓库新建分支，可以加上-u参数，这样可以把本地分支和远程分支关联起来，下次push就可以省略远程分支名</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><p><strong>抓取分支</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">克隆链接</span><br></code></pre></td></tr></table></figure><p>默认只能抓取master分支</p><p><strong>多人协作</strong></p><p>抓取了master分支后，在本地创建dev分支，在dev分支修改；</p><p>创建本地dev分支与远程&#x2F;origin&#x2F;dev分支点链接</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">git branch --<span class="hljs-built_in">set</span>-upstream-to=origin/<span class="hljs-built_in">dev</span> <span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>要推送到远程库时，先git pull 把最新的提交从origin&#x2F;dev抓取下来，在本地合并（git pull自动完成）</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git pull</span><br></code></pre></td></tr></table></figure><p>解决冲突（如果有需要的话）</p><p>最后<code>git push</code></p><h3 id="八、标签tag"><a href="#八、标签tag" class="headerlink" title="八、标签tag"></a>八、标签tag</h3><p>标签是版本库的一个快照，是指向某个commit的指针</p><h4 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h4><p><strong>在当前分支当前commit打上标签v1.0</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>对指定的commit打标签</strong></p><p>v1.0是标签，  f52c633是commit id，可以通过git log查找</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.<span class="hljs-number">0</span> f52c633<br></code></pre></td></tr></table></figure><p>创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> v1.<span class="hljs-number">0</span> -m <span class="hljs-string">&quot;version 1.0 released&quot;</span> <span class="hljs-number">1094</span>adb<br></code></pre></td></tr></table></figure><h4 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h4><p><strong>查看所有标签</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title"></span><br></code></pre></td></tr></table></figure><p><strong>查看指定标签信息</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">show </span><span class="hljs-built_in">v1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> v1.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="推送标签"><a href="#推送标签" class="headerlink" title="推送标签"></a>推送标签</h4><p>将本地标签推送到远程库</p><p><strong>推送指定标签</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> origin <span class="hljs-built_in">v1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>推送所有未推送的标签</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --tags<br></code></pre></td></tr></table></figure><p><strong>删除远程标签</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">git push origin <span class="hljs-symbol">:refs/tags/v1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="九、-gitignore"><a href="#九、-gitignore" class="headerlink" title="九、.gitignore"></a>九、.gitignore</h3><p>在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件</p><p>例如：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs clean"># Windows:<br>Thumbs.db<br>ehthumbs.db<br>Desktop.ini<br><br># My configurations:<br>db.ini<br>deploy_key_rsa<br><br># 排除所有.开头的隐藏文件:<br>.*<br># 排除所有.<span class="hljs-keyword">class</span>文件:<br>*.<span class="hljs-keyword">class</span><br><br># 不排除.gitignore和App.<span class="hljs-keyword">class</span>:<br>!.gitignore<br>!App.<span class="hljs-keyword">class</span><br></code></pre></td></tr></table></figure><h3 id="十、查看提交历史"><a href="#十、查看提交历史" class="headerlink" title="十、查看提交历史"></a>十、查看提交历史</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">git log</span> <span class="hljs-literal">--</span><span class="hljs-comment">graph</span> <span class="hljs-literal">--</span><span class="hljs-comment">pretty=oneline</span> <span class="hljs-literal">--</span><span class="hljs-comment">abbrev</span><span class="hljs-literal">-</span><span class="hljs-comment">commit</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构——栈</title>
    <link href="/2022/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/"/>
    <url>/2022/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>STL 栈的常用函数、算法题</p><span id="more"></span><h1 id="C-Stack（栈）"><a href="#C-Stack（栈）" class="headerlink" title="C++ Stack（栈）"></a>C++ Stack（栈）</h1><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><table><thead><tr><th><a href="https://www.cainiaojc.com/cpp/cpp-stack-empty-function.html">empty</a></th><th>该函数用于测试堆栈是否为空。如果堆栈为空，则该函数返回true，否则返回false。</th></tr></thead><tbody><tr><td><a href="https://www.cainiaojc.com/cpp/cpp-stack-size-function.html">size</a></td><td>该函数返回堆栈容器的大小，该大小是堆栈中存储的元素数量的度量。</td></tr><tr><td><a href="https://www.cainiaojc.com/cpp/cpp-stack-top-function.html">top</a></td><td>该函数用于访问堆栈的顶部元素。该元素起着非常重要的作用，因为所有插入和删除操作都是在顶部元素上执行的。</td></tr><tr><td><a href="https://www.cainiaojc.com/cpp/cpp-stack-push-function.html">push</a></td><td>该函数用于在堆栈顶部插入新元素。</td></tr><tr><td><a href="https://www.cainiaojc.com/cpp/cpp-stack-pop-function.html">pop</a></td><td>该函数用于删除元素，堆栈中的元素从顶部删除。</td></tr><tr><td>swap</td><td>该函数用于交换引用的两个容器的内容。</td></tr></tbody></table><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p>Q1：栈空的时候，使用top访问，或者使用pop会发生什么？</p><p>A1：栈空的时候，使用top和使用pop都会发生访问错误，程序会报错终止。</p><h4 id="leetcode题库"><a href="#leetcode题库" class="headerlink" title="leetcode题库"></a>leetcode题库</h4><table><thead><tr><th>题目</th><th>备注</th></tr></thead><tbody><tr><td>20.有效的括号（简单）</td><td>简单的匹配前后括号(),{},[]</td></tr><tr><td>32.最长的括号（困难）</td><td>计算最长有效括号，分两种情况：()()和(())，巧妙地利用栈和右括号下标</td></tr><tr><td>42.接雨水（困难）</td><td>做了两次，第二次还做了两个小时，把问题想复杂化了，虽然细节很多，但是也没有那么多，没有把握住分析思路。</td></tr><tr><td>71.简化路径（中等）</td><td>标准化输入路径的题目，借鉴编译原理gettoken函数，难点在于需要考虑的情况和细节比较多</td></tr><tr><td>84.柱状图中最大的矩形（困难）</td><td>单调栈+哨兵（边界加一个特殊值，称为“哨兵”），单调栈常用来求左右边界的问题，分为递增、递减栈，具体选哪个取决于详细情况</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发——CSS</title>
    <link href="/2022/04/02/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94CSS/"/>
    <url>/2022/04/02/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94CSS/</url>
    
    <content type="html"><![CDATA[<p>CSS，级联样式表</p><span id="more"></span><h2 id="CSS-（Cascading-Style-Sheets-，级联样式表）"><a href="#CSS-（Cascading-Style-Sheets-，级联样式表）" class="headerlink" title="CSS  （Cascading Style Sheets ，级联样式表）"></a>CSS  （Cascading Style Sheets ，级联样式表）</h2><h3 id="一、选择器概述"><a href="#一、选择器概述" class="headerlink" title="一、选择器概述"></a>一、选择器概述</h3><p><strong>选择符号</strong></p><ul><li><p><strong>包含选择符</strong>，单纯地在两个选择器之间加一个空格，如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">em</span> &#123;<br>  <span class="hljs-attribute">color</span>: rebeccapurple;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在两个选择器之间加了逗号分割，表示选择了多个元素</p></li><li><p><strong>相邻选择符 +</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> + <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">200%</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>直接子级选择符 &gt;</strong></p></li></ul><br><p><strong>选择器列表</strong></p><p>通过逗号，将几个将应用同样样式的选择器合并在一起。</p><br><p><strong>元素、类名、ID选择器</strong></p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">h1 </span><span class="hljs-template-variable">&#123; &#125;</span><span class="language-xml"></span><br><span class="language-xml">.box </span><span class="hljs-template-variable">&#123; &#125;</span><span class="language-xml"></span><br><span class="language-xml">#unique </span><span class="hljs-template-variable">&#123; &#125;</span><br></code></pre></td></tr></table></figure><br><p><strong>标签属性选择器</strong></p><p>根据标签属性来选择元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[title]</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>根据特定值的标签属性选择</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href=<span class="hljs-string">&quot;https://example.com&quot;</span>]</span> &#123; &#125;<br></code></pre></td></tr></table></figure><br><p><strong>伪类、伪元素</strong></p><p>通过伪类来样式化元素的特定状态</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123; &#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span><span class="hljs-selector-tag">-child</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>通过伪元素选择元素的一部分，而不是元素全部</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123; &#125;<br></code></pre></td></tr></table></figure><br><p><strong>如何在HTML中添加css</strong></p><p><strong>方式一</strong>，在head头部中，用style标签包裹css代码</p><p><strong>方式二</strong>，在head头部中，用link标签引入外部css文件，<code>&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;</code></p><br><br><h3 id="二、构建CSS"><a href="#二、构建CSS" class="headerlink" title="二、构建CSS"></a>二、构建CSS</h3><p><strong>函数</strong></p><p>如<code>width: calc(90% - 30px)</code></p><p>还可以定义一些变量 ，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">定义：<span class="hljs-attr">--banner-height</span>:<span class="hljs-number">100vh</span>;<br>使用：<span class="hljs-selector-tag">var</span>(<span class="hljs-attr">--banner-height</span>)<br></code></pre></td></tr></table></figure><br><p><strong>媒体查询</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">body &#123;<br>  background-color: pink;<br>&#125;<br><br>@media (min-width: 30em) &#123;<br>  body &#123;<br>    background-color: blue;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>速记属性，如font、background、margin、border等</strong></p><p><strong>注释：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*css的注释*/</span><br></code></pre></td></tr></table></figure><h3 id="三、CSS工作原理"><a href="#三、CSS工作原理" class="headerlink" title="三、CSS工作原理"></a>三、CSS工作原理</h3><p><strong>浏览器加载网页流程</strong></p><ol><li>浏览器载入HTML文件</li><li>Parse（解析）HTML文件，转化成DOM（Doucument Object Model）</li><li>载入相关资源，图片、视频、样式</li><li>解析CSS，根据选择器的不同分到不同的“桶”中，将不同的规则应用到对应的DOM节点中</li><li>渲染DOM，展示</li></ol><img src="https://mdn.mozillademos.org/files/11781/rendering.svg" style="zoom: 25%;" /><h3 id="四、层叠与继承"><a href="#四、层叠与继承" class="headerlink" title="四、层叠与继承"></a>四、层叠与继承</h3><p><strong>继承</strong></p><p>哪些属性属于默认继承很大程度上是由常识决定的</p><p>三个通用的属性值</p><ul><li><strong>inherit</strong>，子元素属性上声明，表示与父元素相同</li><li><strong>initial</strong>，与浏览器默认样式相同，如果浏览器没有该属性，且该属性是自然继承的，那么会设置为inherit</li><li><strong>unset</strong>，重置为自然值，如果是自然继承的，就是inherit，否则就是initial。可以在样式表中声明<code>all:unset</code>，将重置所有属性</li></ul><br><p><strong>层叠</strong></p><p>考虑层叠从三个方面出发，根据重要性依次为：<strong>重要程度</strong>、<strong>优先级</strong>、<strong>资源顺序</strong></p><ul><li><p><strong>资源顺序</strong></p><p>后面的规则覆盖前面的规则</p></li><li><p><strong>优先级</strong></p><p>html中的style属性  &gt;  ID选择器  &gt;  类选择器、属性选择器、伪类  &gt;  元素、伪元素选择器</p><p>【千位】【百位】【十位】【个位】</p><p><strong>!important</strong>，可以覆盖所有优先级，它会使调试 CSS 问题非常困难，谨慎使用！使用方式：<code>border: none !important;</code></p></li></ul><h3 id="五、选择器"><a href="#五、选择器" class="headerlink" title="五、选择器"></a>五、选择器</h3><h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><ol><li><p><strong>类型选择器</strong>，又叫标签选择器、元素选择器</p></li><li><p><strong>全局选择器</strong>，由一个*号代指，选中了文档中所有内容</p><p>有时会使用全局选择器来使选择器更易读，比如<code>article :first-child</code>和<code>article *:first-child</code>都表示article元素的第一个子元素，但是前者容易和<code>article:first-child</code>混淆，后者表示作为第一个子元素的artcle标签</p></li><li><p><strong>类选择器</strong>，以.号开头。同时也有另外一种方式缩小范围，如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.brimary</span>&#123;&#125;<br><span class="hljs-selector-tag">h1</span><span class="hljs-selector-class">.highlight</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>中间没有空格，代表 <strong>指向特定元素的类</strong></p><p>当<strong>几个类不加空格连成一串</strong>时，匹配的是同时具有这些类的元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.notebox</span><span class="hljs-selector-class">.danger</span> &#123;<br>  <span class="hljs-attribute">border-color</span>: red;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure><p>当<strong>几个类用空格连在一起</strong>时，表示的是后代选择器</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.notebox</span> <span class="hljs-string">.danger</span> &#123;&#125;  选择的是<span class="hljs-string">.notebox</span>下面的<span class="hljs-string">.danger</span><br></code></pre></td></tr></table></figure></li><li><p><strong>ID选择器</strong>，以#开头</p></li></ol><br><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a><strong>属性选择器</strong></h4><ol><li><p><strong>属性值选择器</strong></p><table><thead><tr><th align="left">示例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>a[title]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素——方括号里的值。</td></tr><tr><td align="left"><code>a[href=&quot;https://example.com&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值正为<em>value</em>——引号中的字符串。</td></tr><tr><td align="left"><code>p[class~=&quot;special&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素 ，其值正为<em>value</em>，或者匹配带有一个<em>attr</em>属性的元素，其值有一个或者更多，至少有一个和<em>value</em>匹配。注意，在一列中的好几个值，是用空格隔开的。</td></tr><tr><td align="left">&#96;div[lang</td><td align="left">&#x3D;”zh”]&#96;</td></tr></tbody></table><p>强调，<code>li[class=&#39;a&#39;]</code>匹配的元素，其class属性里面只能有a，不能有其它类名</p></li><li><p><strong>子字符串选择器</strong></p><table><thead><tr><th align="left">选择器</th><th align="left">示例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>[*attr*^=*value*]</code></td><td align="left"><code>li[class^=&quot;box-&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值开头为<em>value</em>子字符串。</td></tr><tr><td align="left"><code>[*attr*$=*value*]</code></td><td align="left"><code>li[class$=&quot;-box&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值结尾为<em>value</em>子字符串</td></tr><tr><td align="left"><code>[*attr**=*value*]</code></td><td align="left"><code>li[class*=&quot;box&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值的字符串中的任何地方，至少出现了一次<em>value</em>子字符串。</td></tr></tbody></table></li><li><p><strong>大小写敏感</strong>，后面加一个<code>i</code>，使大小写不敏感</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">只能匹配以<span class="hljs-selector-tag">a</span>开头的<br><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class^=<span class="hljs-string">&quot;a&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>&#125;<br><br>可以匹配以 <span class="hljs-selector-tag">a</span>或者<span class="hljs-selector-tag">A</span>开头的<br><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class^=<span class="hljs-string">&quot;a&quot;</span> i]</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h4><p><strong>伪类</strong>，是选择器的一种，是开头写着<code>:</code>冒号的关键字，它的作用是帮助减少标记文本中多余的类，让代码更易于维护</p><p>举例：</p><p>简单伪类，<code>:first-child</code>、<code>last-child</code>、<code>:invalid</code>（任意内容未通过验证的 input或其他form元素）</p><p>用户行为伪类，<code>:hover</code>、<code>:hover</code></p><p><strong>伪元素</strong>，以<code>::</code>双冒号开头的关键字，表现出来更像是在HTML上加了新元素，而不是在已有元素上应用样式。</p><p>例如：<code>::first-line</code>将始终选中第一行，不管宽度怎么变化</p><p><strong>::before和::after</strong></p><p>必须添加的属性<code>content</code>，可以用来在元素前后添加文件（但不建议这么做），更多的用法是添加一些图标，屏幕阅读器不会发现它们。也可以将它声明为<code>diaplay:block</code>这样就可以用<code>width</code>和<code>height</code>在它上面应用样式，比如结合绝对布局添加背景图片。</p><h3 id="六、盒模型"><a href="#六、盒模型" class="headerlink" title="六、盒模型"></a>六、盒模型</h3><p><strong>块级盒子（block box）</strong></p><ul><li>在内联方向（通常是横向）上占据父容器的所有宽度</li><li>每个盒子会换行</li><li>width和height可以发挥作用</li><li>内外边距、border会将其它元素推开</li></ul><br><p><strong>内联盒子（inline box）</strong></p><ul><li>不换行</li><li>width和hegiht不起作用</li><li>垂直方向的边距会被应用，但不会把其它inline box推开</li><li>水平方向的边距会把其它inline box推开</li></ul><img src="前端开发——CSS.assets/image-20220407164132124.png" alt="image-20220407164132124" style="zoom:50%;" /><br><p><strong>block和inline是元素的外部显示类型，还有内部显示类型</strong>，内部显示类型决定了元素内部的布局流，例如flex，gird</p><br><p><strong>盒模型</strong>，包含四个元素<code>content box</code>、<code>padding box</code>、 <code>border box</code>、<code>margin box</code></p><p><strong>标准盒模型</strong>的尺寸计算，等于<code>content box</code>+<code>padding box</code>+ <code>border box</code>，margin不算入盒子范围</p><p><strong>替代盒模型</strong>的尺寸为实际盒子尺寸（content加padding加border），实际的content尺寸需要减去padding和border，<strong>声明的方式为：</strong><code>box-sizing: border-box;</code></p><br><p><strong>inline-block</strong>，介于block和inline之间的选项，width和height可以生效，不换行，会推开其它元素。将一些默认的inline元素声明为inline-block是有意义的。</p><img src="前端开发——CSS.assets/image-20220407164335987.png" alt="image-20220407164335987" style="zoom: 25%;" /><h3 id="七、背景与边框"><a href="#七、背景与边框" class="headerlink" title="七、背景与边框"></a>七、背景与边框</h3><p><strong>background</strong>，简写属性，可以一次性声明多个属性值</p><ul><li>background-color，颜色，不会覆盖图像</li><li>background-image</li><li>background-repeat，背景图片的重复方式 <code>no-repeat</code>、<code>repeat-x</code>、<code>repeat-y</code>、<code>repeat</code></li><li>background-size，图像大小，<code>cover</code>等比例缩放填充整个容器，<code>contain</code>图像大小适应容器（可能出现间隙）</li><li>background-position，两个值（也可以4个值），空格隔开，分别表示x轴y轴，可以用<code>长度值</code>、<code>百分比</code>、<code>关键字</code>，如<code>top</code>、<code>center</code></li></ul><p><strong>多个背景图像</strong>，background-image可以有多个url，前面的url将显示在顶部。对应的，其余属性也可以有多组，如果组数不够，将循环使用</p><p><strong>边框，border</strong>，简写属性</p><ul><li>border-width</li><li>border-style，<code>solid</code>、<code>double</code>、<code>dotted</code>、</li><li>border-color</li><li>border-radius，1个值或4个值</li></ul><h3 id="八、竖向文本（块）"><a href="#八、竖向文本（块）" class="headerlink" title="八、竖向文本（块）"></a>八、竖向文本（块）</h3><p><strong>书写模式，writing-mode</strong></p><ul><li><code>horizontal-tb</code>: 块流向从上至下。对应的文本方向是横向的。</li><li><code>vertical-rl</code>: 块流向从右向左。对应的文本方向是纵向的。</li><li><code>vertical-lr</code>: 块流向从左向右。对应的文本方向是纵向的。</li></ul><p><strong>逻辑属性与逻辑值</strong>，当改变文本方向后，width的方向并没有改变（特指纵向），需要通过逻辑值<code>inline-size</code>来映射到width，才能正确控制盒子宽度</p><p>具体可参考：（<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties">Logical Properties and Values</a>）</p><p><strong>块维度：</strong>块的布局流方向</p><p><strong>内联维度：</strong>文本方向</p><h3 id="九、处理溢出"><a href="#九、处理溢出" class="headerlink" title="九、处理溢出"></a>九、处理溢出</h3><p><strong>overflow属性</strong></p><ul><li>visible（默认）</li><li>hidden，隐藏</li><li>scroll，（总是）显示滚动条，包括x轴和y轴两个方向的滚动条，可以通过overflow-x或y来设置单独的滚动条</li><li>auto，文本将溢出时，增加滚动条</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发——HTML</title>
    <link href="/2022/04/02/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94HTML/"/>
    <url>/2022/04/02/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94HTML/</url>
    
    <content type="html"><![CDATA[<p>HyperText Markup Language 不是一门编程语言，而是一种用来告知浏览器如何组织页面的<strong>标记语言</strong></p><span id="more"></span><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>HyperText Markup Language 不是一门编程语言，而是一种用来告知浏览器如何组织页面的<strong>标记语言</strong></p><p><strong>（注：以下所有html标签，都在&lt; 后面增加了一个空格，以避免被编辑器识别为html元素）</strong></p><p><strong>元素（Element）</strong></p><p>标签+内容，组成了元素，HTML就是由一系列元素组成的。<strong>注意：HTML 标签不区分大小写</strong></p><p><strong>属性（Attribute）</strong></p><h3 id="一、剖析元素"><a href="#一、剖析元素" class="headerlink" title="一、剖析元素"></a>一、剖析元素</h3><p><strong>文字样式的元素</strong></p><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt; i&gt;&lt; &#x2F;i&gt;</td><td>斜体，行内元素</td></tr><tr><td>&lt; strong&gt;&lt; &#x2F;strong&gt;</td><td>加粗，表示重要性</td></tr><tr><td>&lt; del&gt;&lt; &#x2F;del&gt;</td><td>删除线</td></tr><tr><td>&lt; u&gt;&lt; &#x2F;u&gt;</td><td>下划线</td></tr></tbody></table><p><strong>文字排版的元素</strong></p><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt; p&gt; &lt; &#x2F;p&gt;</td><td>段落</td></tr><tr><td>&lt; br&gt;</td><td>换行</td></tr><tr><td>&lt; hr&gt;</td><td>水平线</td></tr></tbody></table><p><strong>块级元素 &amp; 内联元素</strong></p><ul><li><p><strong>块级元素</strong>在页面中以块的形式展现，会换行</p></li><li><p><strong>内联元素</strong>出现在<strong>块级元素</strong>里面，不换行</p><p>常见的内联元素：</p><table><thead><tr><th>标签</th><th>描述</th><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt; a&gt;&lt; &#x2F;a&gt;</td><td>超链接</td><td>&lt; br&gt;</td><td>换行符号</td></tr><tr><td>&lt; audio&gt;</td><td>在文档中嵌入音频</td><td>&lt; button&gt;</td><td>按钮</td></tr><tr><td>&lt; canvas&gt;</td><td>被用来通过 JavaScript绘制图形及图形动画</td><td>&lt; code&gt;&lt; &#x2F;code&gt;</td><td>代码块</td></tr><tr><td>&lt; i&gt;&lt; &#x2F;i&gt;</td><td>用于表现因某些原因需要区分普通文本的一系列文本</td><td>&lt; iframe&gt;</td><td><strong>内联框架元素</strong></td></tr><tr><td>……</td><td></td><td></td><td></td></tr></tbody></table></li></ul><h4 id="语义元素"><a href="#语义元素" class="headerlink" title="语义元素"></a><strong>语义元素</strong></h4><p>HTML，有很多标签的原因之一在于，每种标签都有对应的语义，尽管它们在样式上的表现可能相差无几，我想这么做的原因应该是为了方便读取数据，比如爬取数据时，可以通过标签的名字来获取到对应所需要的内容，而且使用对应语义的元素标签也会使得HTML的可读性更强</p><table><thead><tr><th>标签</th><th>含义</th></tr></thead><tbody><tr><td>&lt; footer&gt;</td><td>定义文档或节的页脚。</td></tr><tr><td>&lt; header&gt;</td><td>规定文档或节的页眉。</td></tr><tr><td>&lt; main&gt;</td><td>规定文档的主内容。</td></tr><tr><td>&lt; nav&gt;</td><td>定义导航链接。</td></tr><tr><td>&lt; aside&gt;</td><td>定义页面内容以外的内容。</td></tr><tr><td>&lt; article&gt;</td><td>定义文章。</td></tr><tr><td>&lt; section&gt;</td><td>定义文档中的节。</td></tr><tr><td>&lt; time&gt;</td><td>定义日期&#x2F;时间。</td></tr><tr><td>&lt; figure&gt;</td><td>定义媒介内容的分组，以及它们的标题。</td></tr><tr><td>&lt; figcation&gt;</td><td>定义 figure 元素的标题。</td></tr><tr><td>&lt; mark&gt;</td><td>定义重要的或强调的文本。</td></tr><tr><td>&lt; dialog&gt;</td><td>对话框盒子</td></tr><tr><td>&lt; address&gt;</td><td>地址</td></tr><tr><td>&lt; cite&gt;</td><td>标记著<strong>作者</strong></td></tr><tr><td>&lt; dfn&gt;</td><td>标记术语的定义实例</td></tr><tr><td>&lt; abbr&gt;</td><td>定义缩写</td></tr><tr><td>&lt; blockquote&gt;</td><td>定义长的引用。</td></tr><tr><td>&lt; q&gt;</td><td>定义行内引用</td></tr></tbody></table><p>**[点击](<a href="https://www.w3school.com.cn/tags/html_ref_byfunc.asp">HTML 标签参考手册 - 功能排序 (w3school.com.cn)</a>)**查看更多元素</p><p><strong>空元素</strong></p><p>一个元素只有一个标签，没有结束标签的元素，如&lt; img&gt; ，通常用来插入一些东西</p><h3 id="二、剖析HTML文档"><a href="#二、剖析HTML文档" class="headerlink" title="二、剖析HTML文档"></a>二、剖析HTML文档</h3><p><strong>（以下所有的标签，在&lt; 后面都多加了一个空格，以避免被编辑器识别为html文本，实际使用时需要去掉那个空格）</strong></p><br><p><strong>&lt; !DOCTYPE html&gt;</strong></p><p>是现在是最短有效的文档声明</p><br><p><strong>&lt; html&gt;&lt; &#x2F;html&gt;</strong></p><p>包裹了整个完整的页面，是一个根元素</p><br><p><strong><!-- -->注释</strong></p><br><h4 id="head-元数据"><a href="#head-元数据" class="headerlink" title="head 元数据"></a>head 元数据</h4><p><strong>&lt; head&gt;&lt; &#x2F;head&gt;</strong></p><p>包含了所有你想包含在HTML页面中但不想在HTML页面中显示的内容</p><p>包括你想在搜索结果中出现的关键字和页面描述，CSS样式，字符集声明等等</p><br><p><strong>&lt; title&gt;&lt; &#x2F;title&gt;</strong></p><p> 设置页面标题，出现在浏览器标签上，当你标记&#x2F;收藏页面时它可用来描述页面</p><br><p><strong>&lt; meta charset&#x3D;”utf-8”&gt;</strong></p><p>设置文档使用utf-8字符集编码</p><br><p><strong>meta 添加元数据</strong></p><ul><li><code>name</code> 指定了meta 元素的类型； 说明该元素包含了什么类型的信息。</li><li><code>content</code> 指定了实际的元数据内容</li></ul><p>description也被使用在<strong>搜索引擎显示的结果</strong>页中，如下，content的内容将显示在搜索页面中</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;The MDN Web Docs site</span><br><span class="hljs-string">    provides information about Open Web technologies</span><br><span class="hljs-string">    including HTML, CSS, and APIs for both Web sites and</span><br><span class="hljs-string">    progressive web apps.&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>添加自定义图标</strong>，显示在标签页标题左边的小图标，设置方法，在head中添加如下代码，大多数浏览器都可以支持.gif和.png格式了</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;shortcut icon&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;favicon.ico&quot;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;image/x-icon&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>添加CSS</strong>，属性：<code>rel:&quot;stylesheet&quot; href:文件路径</code></p><br><h4 id="body-主体"><a href="#body-主体" class="headerlink" title="body 主体"></a>body 主体</h4><p><strong>&lt; body&gt;&lt; &#x2F;body&gt;</strong></p><p>页面上显示的所有元素，script标签可以添加到body内，<strong>事实上，把script放在文档尾部是一个更好的选择</strong>，这样可以确保先解析html内容之后才加载脚本，避免因为脚本找不到某个元素而出错，<strong>script需要开始和结束标签</strong>，因为它既可以引用外部标签，也可以把脚本写在script元素内</p><h3 id="三、实体引用"><a href="#三、实体引用" class="headerlink" title="三、实体引用"></a>三、实体引用</h3><table><thead><tr><th align="left">原义字符</th><th align="left">等价字符引用</th></tr></thead><tbody><tr><td align="left">&lt;</td><td align="left">&amp;lt ;</td></tr><tr><td align="left">&gt;</td><td align="left">&amp;gt ;</td></tr><tr><td align="left">“</td><td align="left">&amp;quot ;</td></tr><tr><td align="left">‘</td><td align="left">&amp;apos ;</td></tr><tr><td align="left">&amp;</td><td align="left">&amp;amp ;</td></tr><tr><td align="left">空格</td><td align="left">&amp;nbsp ;</td></tr></tbody></table><p><strong>注：等价字符的字符与分号;之间并没有空格，这里为了能够显示出来，多加了空格</strong></p><p>以上仅列出一些常用的引用，更多可参考<a href="http://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references">XML和HTML字符实体引用列表</a></p><h3 id="四、常用元素"><a href="#四、常用元素" class="headerlink" title="四、常用元素"></a>四、常用元素</h3><h4 id="lt-a-gt-链接"><a href="#lt-a-gt-链接" class="headerlink" title="&lt; a&gt; 链接"></a>&lt; a&gt; 链接</h4><table><thead><tr><th>href</th><th>链接地址</th></tr></thead><tbody><tr><td>title</td><td>鼠标悬停时，以工具提示显示的信息</td></tr><tr><td>target</td><td>跳转链接的方式，如”_blank”为打开新标签页</td></tr><tr><td>download</td><td>当链接是下载资源时，使用download属性提供一个默认的保存文件名，仅适用于<strong>同源URL</strong>（host相同）</td></tr></tbody></table><br><h4 id="iframe内联框架"><a href="#iframe内联框架" class="headerlink" title="iframe内联框架"></a>iframe内联框架</h4><p><strong>HTML 内联框架元素 (<code>&lt;iframe&gt;</code>)</strong> 表示嵌套的<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Browsing_context">browsing context</a>。它能够将另一个 HTML 页面嵌入到当前页面中。</p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220401171641215.png" alt="image-20220401171641215"></p><h3 id="五、文字基础"><a href="#五、文字基础" class="headerlink" title="五、文字基础"></a>五、文字基础</h3><p><strong>标题和段落</strong></p><ul><li>您应该最好只对每个页面使用一次&lt; h1&gt; — 这是顶级标题，所有其他标题位于层次结构中的下方</li><li>在可用的六个标题级别中，您应该只在每页使用不超过三个</li></ul><p><strong>语义标签</strong></p><p>我们可以通过css样式让任何一个标签达到我们想要的外形效果，但是在别人阅读这份html时可能很难理解该部分属于哪一个结构。所以使用语义化标签是必要的，也是html存在那么多标签的意义。</p><p>我之前使用类名或id的方式来标注每个标签代表的含义，但是这样仍然不够直观，不能够让人一眼就看出来每个标签所代表的结构内容 </p><p><strong>高级文字排版</strong></p><ol><li><p><strong>引用</strong>，引用会有默认的缩进，<strong>cite属性</strong>可以添加引用的链接，但是要使用JS或者CSS，浏览器才会显示cite的内容</p><p><strong>行内引用 &lt; q&gt;</strong> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 这是引文：<span class="hljs-tag">&lt;<span class="hljs-name">q</span> <span class="hljs-attr">cite</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span> 水调歌头——苏轼 <span class="hljs-tag">&lt;/<span class="hljs-name">q</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这是引文：<q cite=""> 水调歌头——苏轼</q></p><p><strong>块引用 &lt; blockquote cite&#x3D;””&gt;</strong> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段引用：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span> <span class="hljs-attr">cite</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>水调歌头——苏轼<span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这是一段引用：</p><blockquote cite="">水调歌头——苏轼</blockquote></li><li><p><strong>描述列表 &lt; dl&gt;</strong></p><dl>    <dt>小标题一</dt>    <dd>        描述一    </dd>    <dt>小标题二</dt>    <dd>        描述二    </dd></dl></li><li><p><strong>缩略语 &lt; abbr&gt;</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我们使用 <span class="hljs-tag">&lt;<span class="hljs-name">abbr</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;超文本标记语言（Hyper text Markup Language）&quot;</span>&gt;</span>HTML<span class="hljs-tag">&lt;/<span class="hljs-name">abbr</span>&gt;</span> 来组织网页文档。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们使用 <abbr title="超文本标记语言（Hyper text Markup Language）">HTML</abbr> 来组织网页文档。</p></li><li><p>**上标 &lt; sup&gt;  下标 &lt; sub&gt; **</p><p>x<sup>2</sup>  x<sub>2</sub></p></li><li><p><strong>代码块</strong></p><ul><li>&lt; code&gt;: 用于标记计算机通用代码。</li><li>&lt; pre&gt;: 用于保留空白字符（通常用于代码块）——如果您在文本中使用缩进或多余的空白，浏览器将忽略它，您将不会在呈现的页面上看到它。但是，如果您将文本包含在<code>&lt;pre&gt;&lt;/pre&gt;</code>标签中，那么空白将会以与你在文本编辑器中看到的相同的方式渲染出来。</li><li>&lt; kbd&gt;: 用于标记输入电脑的键盘（或其他类型）输入。</li><li>&lt; samp&gt;: 用于标记计算机程序的输出。</li></ul><p>请不要使用 <code>&lt;font&gt;</code> 、 <code>&lt;center&gt;</code> 等表象元素。</p><p>在上述的 JavaScript 示例中，<var>para</var> 表示一个段落元素。</p><p>按 <kbd>Ctrl</kbd>/<kbd>Cmd</kbd> + <kbd>A</kbd> 选择全部内容。</p><pre>$ <kbd>ping mozilla.org</kbd><samp>PING mozilla.org (63.245.215.20): 56 data bytes64 bytes from 63.245.215.20: icmp_seq=0 ttl=40 time=158.233 ms</samp></pre></li><li><p><strong>时间和日期 &lt; time datetime&#x3D;””&gt;</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;time datetime=<span class="hljs-string">&quot;2016-01-20&quot;</span>&gt;</span><span class="hljs-attribute">2016</span>年<span class="hljs-number">1</span>月<span class="hljs-number">20</span>日&lt;/time&gt;<br></code></pre></td></tr></table></figure><p><time datetime="2016-01-20">2016年1月20日</time></p></li></ol><h3 id="六、网页架构"><a href="#六、网页架构" class="headerlink" title="六、网页架构"></a>六、网页架构</h3><p>一般都网页布局包含了以下5个部分</p><p><strong>导航栏</strong>，指向各个子页面的链接，以及网站标题，导航栏应该始终保持一致</p><p><strong>页眉</strong>，通常横跨于页面顶部的大标题、大图、大标志，是网站的主要信息</p><p><strong>主内容</strong>，位于页面的中心部分，放置重要的内容</p><p><strong>侧边栏</strong>，一些少量的信息，如介绍、子导航、引用等</p><p><strong>页脚</strong>，横跨页面底部的狭长区域，一般放置一些公共信息，如版权声明、联系方式。有一些网站也习惯将链接导航放置到页脚</p><p>对应的，HTML提供了相关的语义标签</p><p><strong>&lt; nav&gt; 导航栏</strong>，其中不应包含二级链接等内容</p><p><strong>&lt; header&gt; 页眉</strong></p><p><strong>&lt; main&gt; 主内容</strong>，每个页面上只能用一次 <code>&lt;main&gt;</code>，且直接位于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body">&#96;&#96;</a> 中。最好不要把它嵌套进其它元素</p><p><strong>&lt; aside&gt; 侧边栏</strong></p><p><strong>&lt; footer&gt; 页脚</strong></p><p>还有其它一些<strong>常用的语义标签</strong></p><p><strong>&lt; article&gt; ，</strong>包围的内容即一篇文章，与页面其它部分无关（比如一篇博文）</p><p><strong>&lt; section&gt; ，</strong>适用于组织页面使其按功能（比如迷你地图、一组文章标题和摘要）分块</p><p>一般的<strong>最佳用法</strong>是：以 <a href="https://developer.mozilla.org/en-US/Learn/HTML/Howto/Set_up_a_proper_title_hierarchy">标题</a> 作为开头；把一篇 <code>&lt;article&gt;</code> 分成若干部分并分别置于不同的 <code>&lt;section&gt;</code> 中</p><p><strong>无语义标签</strong></p><p><strong>&lt; div&gt; ，</strong>一般用于没有特殊语义，或者找不到想要的语义标签，但是又要实现特殊的CSS样式或JS脚本</p><p><strong>&lt; span&gt; ，</strong>内联的（inline）无语义元素，最好用于没有特定语义的情况</p><p><strong>换行和水平分割线</strong></p><p><strong>&lt; br&gt;，换行</strong></p><p><strong>&lt; hr&gt;，水平分割线</strong></p><h3 id="七、验证错误"><a href="#七、验证错误" class="headerlink" title="七、验证错误"></a>七、验证错误</h3><p>验证服务网站 <a href="https://validator.w3.org/">Markup Validation Service</a>，由W3C组织提供的标记验证服务</p><h3 id="八、图片"><a href="#八、图片" class="headerlink" title="八、图片"></a>八、图片</h3><p><code>&lt; img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot;&gt;</code></p><ul><li>src，图片的路径</li><li>alt，图片加载失败时显示的文本</li><li>title，鼠标悬停在图片上时显示的文本</li></ul><p>HTML5，有两个个专门的语义元素**&lt; figure&gt; 和&lt; figcaption&gt;**用来放置图片和对应的文字，结构为</p><ul><li>&lt; figure&gt; <ul><li>&lt; img&gt;</li><li>&lt; figcaption&gt;</li></ul></li></ul><p>样式并没有什么不同，但是便于人和机器读懂html文档。</p><p>CSS也可以通过backgorund-image属性来添加图片，但那并没有语义意义。</p><h3 id="九、音视频"><a href="#九、音视频" class="headerlink" title="九、音视频"></a>九、音视频</h3><h4 id="video元素"><a href="#video元素" class="headerlink" title="video元素"></a>video元素</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;rabbit320.webm&quot;</span> <span class="hljs-attr">controls</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>你的浏览器不支持 HTML5 视频。可点击<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;rabbit320.mp4&quot;</span>&gt;</span>此链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>观看<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>src，视频路径</li><li>controls，使用controls来包含浏览器提供的控件界面，布尔属性</li><li>后备内容，开始和结束标签之间的内容，当浏览器不支持video时就会显示出来</li></ul><br><p><strong>另外一种写法，为了提供多个视频源</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">controls</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;rabbit320.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;rabbit320.webm&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/webm&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>你的浏览器不支持 HTML5 视频。可点击<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;rabbit320.mp4&quot;</span>&gt;</span>此链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>观看<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><p>video标签会自动从source标签中寻找想匹配的媒体，type属性是有用的，浏览器会优先检查type，寻找匹配的媒体，否则需要一个个尝试加载，这会浪费大量时间。</p><br><p><strong>H5提供的新属性</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;video controls width<span class="hljs-operator">=</span><span class="hljs-string">&quot;400&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;400&quot;</span> autoplay loop muted poster<span class="hljs-operator">=</span><span class="hljs-string">&quot;poster.png&quot;</span>&gt; &lt;/video&gt;<br></code></pre></td></tr></table></figure><ul><li>width，hegiht控制尺寸，不会改变长宽比，多余空白填充</li><li>autoplay，自动播放</li><li>loop，循环播放</li><li>muted，默认静音</li><li>poster，视频播放前显示的图片</li></ul><h4 id="audio元素"><a href="#audio元素" class="headerlink" title="audio元素"></a>audio元素</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">controls</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;viper.mp3&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/mp3&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;viper.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/ogg&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>你的浏览器不支持 HTML5 音频，可点击<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;viper.mp3&quot;</span>&gt;</span>此链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>收听。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><p>不支持width，height，poster等视觉属性</p><br><p><strong>H5支持了显示音轨文本</strong></p><p>有了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebVTT_API">WebVTT</a> 格式，你可以使用 <strong>track标签</strong></p><p>WebVTT 是一个格式，用来编写文本文件，这个文本文件包含了众多的字符串，这些字符串会带有一些元数据，它们可以用来描述这个字符串将会在<strong>视频中显示的时间</strong>，甚至可以用来描述这些<strong>字符串的样式以及定位信息</strong>。这些字符串叫做 <strong>cues</strong> 。</p><p>一个典型的 WebVTT 文件如下：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">WEBVTT<br><br><span class="hljs-number">1</span><br><span class="hljs-number">00:00:22.230</span> --&gt; <span class="hljs-number">00</span>:<span class="hljs-number">00:24.606</span><br>第一段字幕<br></code></pre></td></tr></table></figure><p><strong>使用方式：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;video controls&gt;<br>    &lt;source src<span class="hljs-operator">=</span><span class="hljs-string">&quot;example.mp4&quot;</span> type<span class="hljs-operator">=</span><span class="hljs-string">&quot;video/mp4&quot;</span>&gt;<br>    &lt;source src<span class="hljs-operator">=</span><span class="hljs-string">&quot;example.webm&quot;</span> type<span class="hljs-operator">=</span><span class="hljs-string">&quot;video/webm&quot;</span>&gt;<br>    &lt;track kind<span class="hljs-operator">=</span><span class="hljs-string">&quot;subtitles&quot;</span> src<span class="hljs-operator">=</span><span class="hljs-string">&quot;subtitles_en.vtt&quot;</span> srclang<span class="hljs-operator">=</span><span class="hljs-string">&quot;en&quot;</span>&gt;<br>&lt;/video&gt;<br></code></pre></td></tr></table></figure><ul><li>kind，指明类型</li><li>src，链接文件</li><li>srclang，说明.vtt文件的编写语言</li></ul><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>subtitles</td><td>通过添加翻译字幕，来帮助那些听不懂外国语言的人们理解音频当中的内容</td></tr><tr><td>captions</td><td>同步翻译对白，或是描述一些有重要信息的声音，来帮助那些不能听音频的人们理解音频中的内容</td></tr><tr><td>timed descriptions</td><td>将文字转换为音频，用于服务那些有视觉障碍的人</td></tr></tbody></table><p>参考链接：<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery/Adding_captions_and_subtitles_to_HTML5_video">Adding captions and subtitles to HTML5 video</a></p><h3 id="十、SVG"><a href="#十、SVG" class="headerlink" title="十、SVG"></a>十、SVG</h3><p><strong>svg是什么</strong></p><p>用于描述矢量图像的<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/XML">XML</a>语言</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.1&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">baseProfile</span>=<span class="hljs-string">&quot;full&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;black&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;150&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;90&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;blue&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>优缺点</strong></p><p>优点：矢量图，放大不变形；可以通过CSS和JS编写样式</p><p>缺点：复杂图像很大；更难创建；旧版浏览器不支持</p><p><strong>跨浏览器支持SVG</strong></p><p>方式一：使用img标签，src引用png文件，srcset引用svg文件，这样会优先加载svg文件，不支持的浏览器会加载png文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;equilateral.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;triangle with equal sides&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;equilateral.svg&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>方式二：作为CSS背景图像，如下代码，新浏览器会加载svg，旧浏览器会加载png</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">background: url(&quot;fallback.png&quot;) no-repeat center;<br>background-image: url(&quot;image.svg&quot;);<br>background-size: contain;<br></code></pre></td></tr></table></figure><p>方式三：html内联svg，将svg代码放置在svg开始结束标签内。优点：减少qequest请求，提高加载速度；可以使用CSS修改样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;green&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="十一、响应式图片"><a href="#十一、响应式图片" class="headerlink" title="十一、响应式图片"></a>十一、响应式图片</h3><p><strong>分辨率切换问题：</strong>使用相同显示效果但不同分辨率的图片来适配不同尺寸大小的设备</p><p><strong>美术设计问题：</strong>使用不同的图片来适应不同的空间分布</p><p><strong>一个响应式设计的实例：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;elva-fairy-320w.jpg 320w,</span></span><br><span class="hljs-string"><span class="hljs-tag">             elva-fairy-480w.jpg 480w,</span></span><br><span class="hljs-string"><span class="hljs-tag">             elva-fairy-800w.jpg 800w&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">sizes</span>=<span class="hljs-string">&quot;(max-width: 320px) 280px,</span></span><br><span class="hljs-string"><span class="hljs-tag">            (max-width: 480px) 440px,</span></span><br><span class="hljs-string"><span class="hljs-tag">            800px&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;elva-fairy-800w.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Elva dressed as a fairy&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>**srcset ** 定义了浏览器选择的图像集，以及图像大小。w代表真实像素单位</li><li><strong>sizes</strong>  定义了媒体查询，括号内是媒体查询条件，括号外是填充的槽宽度。最后一个没有条件，没有一个为true时它会生效</li><li>浏览器所做的工作：<ul><li>查看设备宽度</li><li>从前往后检查sizes属性，直到第一个true条件，获得槽宽度</li><li>加载srcset中最接近槽宽度的图像</li></ul></li></ul><p><strong>分辨率切换的实例</strong>：srcset和x语法结合</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;elva-fairy-320w.jpg,</span></span><br><span class="hljs-string"><span class="hljs-tag">             elva-fairy-480w.jpg 1.5x,</span></span><br><span class="hljs-string"><span class="hljs-tag">             elva-fairy-640w.jpg 2x&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;elva-fairy-640w.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Elva dressed as a fairy&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">img &#123;<br>  width: 320px;<br>&#125;<br></code></pre></td></tr></table></figure><p>宽度固定在320px，如果页面是低分辨率显示，一个设备像素表示一个CSS像素，320w的图像被加载。如果高分辨率显示，2个设备像素表示一个CSS像素，那640w的图像被加载。实现同尺寸，不同分辨率</p><p><strong>美术设计的实例：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(max-width: 799px)&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;elva-480w-close-portrait.jpg&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(min-width: 800px)&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;elva-800w.jpg&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;elva-800w.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Chris standing up holding his daughter Elva&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在任何情况下，你都必须在 <code>&lt;/picture&gt;</code>之前正确提供一个<code>&lt;img&gt;</code>元素以及它的<code>src</code>和<code>alt</code>属性，否则不会有图片显示</p><p><strong>实践发现：</strong>如果不限制img标签（不是picture标签）的大小，图片将按照实际尺寸显示，这将使网页大小变得不可控。</p><h3 id="十二、表格"><a href="#十二、表格" class="headerlink" title="十二、表格"></a>十二、表格</h3><p><strong>定义表格</strong></p><ul><li>table 表格<ul><li>tr 行<ul><li>td 单元格内容  </li><li>th 标题所在的单元格</li></ul></li></ul></li></ul><p><strong>跨行或跨列</strong></p><p>在th属性里加上<code>rowspan=&quot;x&quot; colspan=&quot;x&quot;</code></p><p><strong>为整行&#x2F;整列应用属性样式 colgroup  rowgroup</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">colgroup</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">col</span>&gt;</span> 为第一列设置样式，即使不设置也不能省略，如果想省略需要加span属性，如下<br>    <span class="hljs-tag">&lt;<span class="hljs-name">col</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span>为第二列设置样式<br><span class="hljs-tag">&lt;/<span class="hljs-name">colgroup</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">colgroup</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">col</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">span</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">colgroup</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>添加表格标题</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>表格标题<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>更严谨的表格结构</strong></p><p><code>thead 、 tfoot 、 tbody结构</code></p><p>好处：结构化更容易控制</p><p>三者的顺序没有硬性要求，但是需要放在colgroup下面（如果有的话）。实际上tbody即使不声明也会隐式出现（自动添加）</p><table>    <caption>How I chose to spend my money</caption>    <thead>        <tr>            <th>Purchase</th>            <th>Location</th>            <th>Date</th>            <th>Cost</th>        </tr>    </thead>    <tbody>        <tr>            <td>Haircut</td>            <td>Hairdresser</td>            <td>12/09</td>            <td>30</td>        </tr>        <tr>            <td>Shoes</td>            <td>Shoeshop</td>            <td>13/09</td>            <td>65</td>        </tr>    </tbody>    <tfoot>        <tr>            <td colspan="3">SUM</td>            <td>95</td>        </tr>    </tfoot></table><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>How I chose to spend my money<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Purchase<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Location<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Date<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Cost<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Haircut<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Hairdresser<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>12/09<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Shoes<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Shoeshop<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>13/09<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>65<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tfoot</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>SUM<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>95<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tfoot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发——Web开发概述</title>
    <link href="/2022/04/02/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/04/02/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>了解Web开发相关知识的意义在于</p><span id="more"></span><h2 id="Web开发概述"><a href="#Web开发概述" class="headerlink" title="Web开发概述"></a>Web开发概述</h2><p>了解Web开发相关知识的意义在于，Web拥有一套标准，“<strong>Web 标准</strong>是我们用来建立 Web 网站的技术。这些标准存在于名为规范的较长的技术文档中，该文档详细说明了技术应如何工作“。它规定了web如何工作，这对于从底层去理解、提升web应用的性能具有关键作用。</p><p>而且标准是不断更新的，所以意味着该行业的从业人员也需要时刻保持学习，以适应最新的标准。</p><h4 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h4><ul><li>可用于运行测试以显示您的代码是否按预期运行的 <a href="https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing">测试工具（ Testing tools ）</a>，<strong>跨浏览器测试</strong></li><li>现代浏览器中的 <a href="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_are_browser_developer_tools">开发人员工具（ developer tools ）</a>可用于<strong>调试代码</strong></li><li>所谓的 “ Linters” ，它包含了一组规则，检查您的代码之后，会突出显示您未正确遵循规则的地方</li><li>Minifiers ，它将代码文件中的所有空格删除以使其更小，从而可以更快地从服务器下载</li></ul><h4 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h4><p>前端语言：HTML ， CSS 和 JavaScript</p><p>后端语言，或者叫服务器端语言：ASP.NET ， Python ， PHP 和 NodeJS </p><h4 id="考虑的问题"><a href="#考虑的问题" class="headerlink" title="考虑的问题"></a>考虑的问题</h4><p><strong>跨浏览器兼容性（ Cross-browser compatibility ）</strong>，确保能在尽可能多，包括老旧的设备浏览器上运行</p><p><strong>响应式网页设计（ Responsive Web design ）</strong>，确保能在不同尺寸的浏览器界面中都有良好的浏览体验</p><p><strong>性能（ Performance ）</strong>，尽可能快加载网站，简单易用</p><p><strong>可访问性（ Accessibility ）</strong></p><p><strong>隐私与安全（ Privacy &amp; Security ）</strong>，隐私是指允许人们私下从事其业务，而不是监视他们或收集您绝对不需要的更多数据。安全性是指以安全的方式构建您的网站，以使恶意用户无法从您或您的用户那里窃取信息。</p><h4 id="Web是如何工作的"><a href="#Web是如何工作的" class="headerlink" title="Web是如何工作的"></a>Web是如何工作的</h4><p><strong>第一步</strong>，浏览器输入一个网址，向服务器端发送request，请求拷贝一份网页</p><p><strong>第二步</strong>，服务器端收到请求后，返回一个同意信息，接着把网页文件以数据包的形式发送给浏览器</p><p><strong>第三步</strong>，浏览器解析网页文件。<strong>首先</strong>，从HTML文件中识别出所有”link”和”script”，获取外部文件的链接，一边继续解析HTML文件，一边根据外部文件链接向服务器发送请求，获取再解析CSS和JavaSript文件；<strong>接着</strong>，给解析后的HTML生成一个<strong>DOM树</strong>，给CSS<strong>生成一个CSSOM树</strong>保存在内存中，编译执行解析度JavaScript文件；<strong>最后</strong>，网页界面展示出来。</p><h4 id="网站架构"><a href="#网站架构" class="headerlink" title="网站架构"></a>网站架构</h4><p>也称<strong>信息架构</strong>，规划整个网站内容，需要哪些页面、如何排列组合这些页面、如何互相进行链接</p><p><strong>第一步</strong>，头脑风暴所有需要实现的内容</p><p><strong>第二步</strong>，将所有内容分组罗列出来</p><p><strong>第三步</strong>，绘制站点草图，使用框框作为页面，连线表示页面之间的链接，有点像<strong>UML</strong></p><p><strong>第四步</strong>，确定所有页面的通用部分，一般为导航栏、页脚</p><p><strong>第五步</strong>，绘制网页布局草图</p><h4 id="http完整请求过程"><a href="#http完整请求过程" class="headerlink" title="http完整请求过程"></a>http完整请求过程</h4><p>客户端浏览器一次完整的http请求过程</p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/1620.jpeg" alt="img"></p><ol><li>DNS解析域名得到IP地址</li><li>TCP三次握手（客户端与服务器建立连接）</li><li>客户端发起请求</li><li>服务器根据收到的请求端口号、路径，找到对应的资源文件，发送给客户端</li><li>客户端收到数据，解析页面和请求相关资源</li><li>客户端渲染页面</li><li>服务器断开连接（四次挥手）</li></ol><p>下面是部分详细介绍</p><p><strong>浏览器渲染过程</strong></p><ul><li><p><strong>根据HTML解析出DOM树【遇到<code>&lt;img&gt;</code>标签加载图片】</strong></p><p>解析顺序为从上往下、深度优先遍历；如果遇到link标签，会同时异步请求对应的资源文件；如果遇到script标签，会阻塞解析过程，直到js脚本执行完毕，而CSS文件影响JS代码的执行（不影响JS文件的加载），所以JS代码执行前，必须保证CSS文件已经加载完毕。</p><p>所以script通常放在HTML的末尾声明，但是如果HTML中包含了大量的JS文件代码，而且这些代码不直接影响页面（比如提供交互事件），那么可以将script标签放到前面，并用<code>async</code>或<code>defer</code>关键字声明（详细用法可参见《前端开发——JS（一）》）</p></li><li><p><strong>根据CSS解析出CSS规则树【遇到背景图片链接不加载】</strong></p><p>解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪</p><p>精简CSS可以加快CSS规则树的构建，从而加快页面响应速度</p></li><li><p><strong>结合DOM树和CSS规则树，生成渲染树【遍历DOM树时加载对应样式规则上的背景图片】</strong></p></li><li><p><strong>根据渲染树计算每个节点的信息，根据节点信息绘制页面</strong></p><p><strong>布局</strong>：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</p><p><strong>回流</strong>：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染</p><p>根据计算好的信息绘制页面</p><p><strong>重绘 &amp; 回流</strong></p><p>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘</p><p>回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo常用命令</title>
    <link href="/2022/03/12/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/03/12/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>Hexo常用命令</p><span id="more"></span><h3 id="一、写作"><a href="#一、写作" class="headerlink" title="一、写作"></a>一、写作</h3><ol><li><p><strong>新建空白文档</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">hexo n [layout] <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>layout分为：post、page、draft，默认为post</strong></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p><strong>用法实例：</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">post</span> --path 前端开发/前端开发——Web开发基础 <span class="hljs-string">&quot;前端开发——Web开发概述&quot;</span><br>如果没有最后<span class="hljs-string">&quot;&quot;</span>里面的标题，只会创建文件名为“前端开发——Web开发基础”的文件，title为模板默认值。如果指定的文件目录不存在，则会新建文件目录<br></code></pre></td></tr></table></figure></li><li><p><strong>Front-matter</strong></p><table><thead><tr><th>参数</th><th>描述</th><th>用法</th></tr></thead><tbody><tr><td>title</td><td>文章标题、文件名</td><td></td></tr><tr><td>tags</td><td>标签</td><td>tags: - PS3 - Games</td></tr><tr><td>categories</td><td>分类</td><td>categories: - Diary</td></tr><tr><td>index_img</td><td>首页的缩略图</td><td>index_img: &#x2F;img&#x2F;yangtai&#x2F;p1.jpg</td></tr><tr><td>banner_img</td><td>详细页的顶部背景大图</td><td>banner_img: &#x2F;img&#x2F;yangtai&#x2F;p2.jpg</td></tr><tr><td>comments</td><td>开关文章的评论功能</td><td>comments: true（默认） &#x2F; false</td></tr></tbody></table></li></ol><h3 id="二、发布"><a href="#二、发布" class="headerlink" title="二、发布"></a>二、发布</h3><ol><li><p>生成静态文件</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br></code></pre></td></tr></table></figure></li><li><p>本地预览</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">hexo s  启动服务器。默认情况下，访问网址为： http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">4000</span>/<br></code></pre></td></tr></table></figure></li><li><p>部署网站</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="三、自定义"><a href="#三、自定义" class="headerlink" title="三、自定义"></a>三、自定义</h3><h4 id="自定义模板"><a href="#自定义模板" class="headerlink" title="自定义模板"></a>自定义模板</h4><p>在hexo的<code>scaffolds</code>目录下有三个<code>md</code>文档，按需修改模板即可</p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220312210202990.png" alt="image-20220312210202990" style="zoom:50%;" /><h4 id="自定义默认背景图片"><a href="#自定义默认背景图片" class="headerlink" title="自定义默认背景图片"></a>自定义默认背景图片</h4><p>修改主题配置_config.fluid中的post.banner_img</p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220312212321936.png" alt="image-20220312212321936" style="zoom:50%;" /><h3 id="四、资源文件夹"><a href="#四、资源文件夹" class="headerlink" title="四、资源文件夹"></a>四、资源文件夹</h3><p>资源，指除了文章文本之外的所有文件，诸如：图片（包括文章里的配图）、CSS、JS文件等。</p><p>如果这些资源存放在本地，那么只能在本地服务器上正常浏览使用它们，通过网站浏览时将无法加载。</p><p>针对图片的一种做法是，设置Toypra等markdown编辑器的 <strong>图片上传</strong>功能，接着类似于github提供的<strong>图床</strong>服务，使网站上的在线文档能够正常加载图片。</p><p>另外一种，也就是这里推荐的做法是，使用Hexo的 <strong>相对路径引用的标签插件</strong>。介绍如下：</p><p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的<a href="https://hexo.io/docs/tag-plugins#Include-Assets">标签插件</a>被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">asset_path</span> slug %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">asset_img</span> slug [title] %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">asset_link</span> slug [title] %&#125;</span><br></code></pre></td></tr></table></figure><p>正确的引用图片方式是使用下列的标签插件而不是 markdown ：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">&#123;<span class="hljs-symbol">%</span> asset_img <span class="hljs-built_in">example</span>.jpg This <span class="hljs-built_in">is</span> an <span class="hljs-built_in">example</span> <span class="hljs-built_in">image</span> <span class="hljs-symbol">%</span>&#125;<br></code></pre></td></tr></table></figure><p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p><p>使用这个<strong>便签插件</strong>，首先要调整config.yml的设置，将post_asset_folder设置为true，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>之后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。<strong>这个资源文件夹将会有与这个文章文件一样的名字</strong>。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们</p><p><strong>重点！！实际尝试发现，这种方式体验很差，因为使用标签插件的时候Typora就无法预览到图片</strong></p><p>所以还是放弃这种方式，改为使用github图床吧，这样虽然加载慢一点，但是起码三个地方都可以访问到</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云发布网页Apache</title>
    <link href="/2022/03/12/%E9%98%BF%E9%87%8C%E4%BA%91%E5%8F%91%E5%B8%83%E7%BD%91%E9%A1%B5Apache/"/>
    <url>/2022/03/12/%E9%98%BF%E9%87%8C%E4%BA%91%E5%8F%91%E5%B8%83%E7%BD%91%E9%A1%B5Apache/</url>
    
    <content type="html"><![CDATA[<p>通过apache在阿里云服务器上发布本地制作的网页</p><span id="more"></span><ul><li>服务器：阿里云轻量化云服务器</li><li>系统：CentOS 7</li></ul><h3 id="一、安装Apache"><a href="#一、安装Apache" class="headerlink" title="一、安装Apache"></a>一、安装Apache</h3><h4 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h4><ol><li><p>安装apache</p><p>yum install httpd</p></li><li><p>设置服务器开机自动启动Apache</p><p>systemctl enable httpd.service</p></li><li><p>手动启动Apache</p><p>systemctl start httpd.service</p><p>扩展命令</p><p>手动停止Apache  systemctl stop httpd.service<br>手动重启Apache  systemctl restart httpd.service</p></li><li><p>测试Apache启动结果</p><p>systemctl is-enabled httpd.service<br>如果结果为enable，则启动成功</p><p>也可以在浏览器输入ip地址进行访问，如果安装成功，将会出现apache的首页</p></li></ol><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul><li>apache2 默认的几个配置文件：（<strong>apache2在CentOS 7中叫做httpd</strong>）</li></ul><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</td><td>主要配置文件(这个文件的末尾可以看到，include了其它所有的配置文件)</td></tr><tr><td>&#x2F;etc&#x2F;conf.d&#x2F;<br />conf.modules.d</td><td>其它配置文件</td></tr></tbody></table><ul><li><strong>默认web目录：&#x2F;var&#x2F;www&#x2F;html</strong>，</li><li><strong>设置默认主页的配置文件：&#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;welcome.conf</strong></li></ul><h3 id="二、访问测试"><a href="#二、访问测试" class="headerlink" title="二、访问测试"></a>二、访问测试</h3><p>浏览器访问 localhost:80</p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220312174122367.png" alt="image-20220312174122367"></p><h3 id="三、上传网页"><a href="#三、上传网页" class="headerlink" title="三、上传网页"></a>三、上传网页</h3><p>Apache安装成功之后，在&#x2F;var下面会多出一个.&#x2F;www文件夹，使用XFtp将html文件和所需的css、js、以及其它资源文件夹一并上传到&#x2F;var&#x2F;www&#x2F;html 文件夹下即可</p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220312200709944.png" alt="image-20220312200709944"></p><p>上传完成后，在浏览器中输入ip地址即可访问上传的网页</p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220312200921295.png" alt="image-20220312200921295"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搭建网站</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p>学生，华南师范大学计算机学院在读，现居广州</p><p>爱好旅行、户外徒步、摄影、diy，打篮球、羽毛球</p>]]></content>
    
  </entry>
  
  
  
</search>
