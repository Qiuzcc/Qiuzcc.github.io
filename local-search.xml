<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>post</title>
    <link href="/2022/04/12/%E5%90%8E%E7%AB%AF/nodejs%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/12/%E5%90%8E%E7%AB%AF/nodejs%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Nodejs使用笔记"><a href="#Nodejs使用笔记" class="headerlink" title="Nodejs使用笔记"></a>Nodejs使用笔记</h2><h3 id="一、npm"><a href="#一、npm" class="headerlink" title="一、npm"></a>一、npm</h3><p><strong>常用命令</strong></p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>npm list -g –dept 0</td><td>查看全局安装过的包</td></tr><tr><td>npm ls –dept 0</td><td>查看当前项目下安装的包， –dept 0表示查看深度为0，否则会显示一大串详细的分支</td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>post</title>
    <link href="/2022/04/12/%E5%90%8E%E7%AB%AF/%E4%BA%86%E8%A7%A3HTTP%E4%BB%A3%E7%90%86/"/>
    <url>/2022/04/12/%E5%90%8E%E7%AB%AF/%E4%BA%86%E8%A7%A3HTTP%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理</h2><p>HTTP代理是什么？</p><p>我们又常见“正向代理”和“方向代理”这两个名词，两者又有什么区别？</p><p><strong>正向代理</strong></p><p>一般我们常说的代理，指的就是正向代理。</p><p>正向代理的过程，就是通过一个代理方（软件、或者代理服务器），来帮我们作为中间方传递请求和服务器返回的数据。它隐藏了真实的请求客户端，服务端不知道真正的客户端是谁。一些科学上网工具扮演的就是正向代理的角色。</p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/v2-07ededff1d415c1fa2db3fd89378eda0_720w.jpg" alt="img"></p><p><strong>反向代理</strong></p><p>反向代理隐藏了真实的服务端</p><p>事实上当我们访问一个网址的时候，可能有成千上万台服务器在后面服务，但真正给我们返回数据的只是其中一部分，是哪部分我们并不知道。我们只需要知道反向代理服务器就好，反向代理服务器会帮我们把真实的请求转发到真实服务器上。</p><p>从介绍上不难发现，反向代理服务器可以实现负载均衡的功能。</p><p>除此之外，在一个网站服务器下面可能存在多个端口对应不同的服务，如果要通过端口号来区分的话，难免显得不够优雅，这时候反向代理服务器就可以帮我解决这个问题了。</p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/v2-816f7595d80b7ef36bf958764a873cba_720w.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Express项目部署到云服务器</title>
    <link href="/2022/04/11/Express%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/04/11/Express%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Express项目部署到云服务器"><a href="#Express项目部署到云服务器" class="headerlink" title="Express项目部署到云服务器"></a>Express项目部署到云服务器</h2><p>前期使用 Express + MongoDB 在本地开发了一个图文博客网站的小项目，为了能够实现在线演示，现在准备把项目部署到云服务器上。</p><p><strong>已经完成的内容</strong></p><ul><li>项目的基本功能已经开发完成</li><li>已经购买了一台阿里云服务器（服务器上已经安装过了Apache）</li></ul><h3 id="一、服务器上安装所需环境"><a href="#一、服务器上安装所需环境" class="headerlink" title="一、服务器上安装所需环境"></a>一、服务器上安装所需环境</h3><h4 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h4><ol><li><p>安装源</p><figure class="highlight armasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">curl</span> -<span class="hljs-built_in">sL</span> https:<span class="hljs-comment">//rpm.nodesource.com/setup_12.x | bash -</span><br></code></pre></td></tr></table></figure><p>在Linux中<strong>curl</strong>是一个利用URL规则在命令行下工作的文件传输工具</p></li><li><p>开始安装</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum -y <span class="hljs-keyword">install</span> nodejs<br></code></pre></td></tr></table></figure></li><li><p>查看安装结果</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span><br>npm -v<br></code></pre></td></tr></table></figure></li><li><p><strong>替换镜像</strong>，默认的镜像为：<code>https:*//registry.npmjs.org/*</code>，国内下载可能受限，更换为淘宝镜像</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">npm config <span class="hljs-keyword">set</span> <span class="hljs-keyword">registry</span> <span class="hljs-keyword">http</span>://<span class="hljs-keyword">registry</span>.npm.taobao.org/<br></code></pre></td></tr></table></figure><p>如果想恢复原来的镜像地址：npm config set registry <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a></p></li></ol><h4 id="安装Express"><a href="#安装Express" class="headerlink" title="安装Express"></a>安装Express</h4><p>使用glocal安装，Express是Nodejs下的一个框架</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm -g <span class="hljs-keyword">install</span> express<br></code></pre></td></tr></table></figure><h4 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h4><ol><li><p>下载安装包</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//</span>repo.mongodb.org<span class="hljs-regexp">/yum/</span>redhat<span class="hljs-regexp">/7/m</span>ongodb-org<span class="hljs-regexp">/testing/</span>x86_64<span class="hljs-regexp">/RPMS/m</span>ongodb-org-server-<span class="hljs-number">5.0</span>.<span class="hljs-number">7</span>-<span class="hljs-number">0.1</span>.rc1.el7.x86_64.rpm<br></code></pre></td></tr></table></figure><p>具体的url应该参考[MongoDB官网](<a href="https://www.mongodb.com/try/download/community">MongoDB Community Download | MongoDB</a>)给出的链接为准，Package选择rpm，Platform选择自己对应的版本，我这里是RedHat&#x2F;CentOS 7</p></li><li><p>安装配置</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rpm</span> -ivh mongodb-org-server-<span class="hljs-number">5</span>.<span class="hljs-number">0</span>.<span class="hljs-number">7</span>-<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.rc1.el7.x86_64.rpm<br></code></pre></td></tr></table></figure><p><strong>rpm命令</strong> 是RPM软件包的管理工具</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">-<span class="hljs-selector-tag">i</span>：显示套件的相关信息；-v：显示指令执行过程；-h或<span class="hljs-attr">--hash</span>：套件安装时列出标记；<br></code></pre></td></tr></table></figure><p> 从安装信息可以看出，mongodb安装完成后已经自动开机启动项中</p></li><li><p>查看启动项文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/systemd/</span>system/mongod.service<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/465051-20210727182418375-774943240.png" alt="img"></p></li><li><p>查看配置文件</p><p>从上图可以看到配置文件在&#x2F;etc&#x2F;mongod.conf中</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/etc/m</span>ongod.conf<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/20210727171833476-369942151-16496819084402.png" alt="img"></p><ul><li>数据库目录：&#x2F;var&#x2F;lib&#x2F;mongo</li><li>日志目录：&#x2F;var&#x2F;log&#x2F;mongodb&#x2F;mongod.log</li><li>端口号：27017</li></ul></li><li><p>修改配置文件</p><ul><li>访问IP改为：0.0.0.0（即不限制访问IP）</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vi <span class="hljs-regexp">/etc/m</span>ongod.conf<br></code></pre></td></tr></table></figure></li><li><p>重载系统服务, 启动</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl daemon-reload<br><span class="hljs-params">system</span>ctl start mongod<br></code></pre></td></tr></table></figure><p><strong>启动失败！经过多番查找，发现问题出在文件权限上，解决过程见文章末尾</strong></p></li><li><p>查看启动状态</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl status mongod</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220411224726165.png" alt="image-20220411224726165"></p></li></ol><h3 id="二、服务器端口设置"><a href="#二、服务器端口设置" class="headerlink" title="二、服务器端口设置"></a>二、服务器端口设置</h3><p>开放云服务器的27017端口，并重启服务器</p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-0411231918871.png" alt="image-20220411231918871" style="zoom: 33%;" /><p>在浏览器中输入<code>服务器IP:27017</code>，成功访问到数据库</p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220411232018995.png" alt="image-20220411232018995" style="zoom:50%;" /><h3 id="三、设置HTTP代理"><a href="#三、设置HTTP代理" class="headerlink" title="三、设置HTTP代理"></a>三、设置HTTP代理</h3><p>何为代理？可以参见我另外一篇文章：了解HTTP代理</p><p>由于上一次已经安装过Apache（见这篇文章：[阿里云发布网页Apache](<a href="https://qiuzcc.github.io/2022/03/12/%E9%98%BF%E9%87%8C%E4%BA%91%E5%8F%91%E5%B8%83%E7%BD%91%E9%A1%B5Apache/">阿里云发布网页Apache - Hexo (qiuzcc.github.io)</a>)），所以直接使用Apache的代理</p><p>网上关于Apache设置http代理的文章质量参差不齐，解释不清楚。</p><p>最后发现其实只需要在<strong>httpd.conf</strong>末尾加上两句就可以了。<strong>在CentOS 7中，Apache有另外一个名称，叫httpd</strong></p><p>httpd的配置文件所在目录：<code>/etc/httpd/</code></p><p>打开<code>/etc/httpd/conf/httpd.conf</code>，在末尾添加</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ProxyPass</span> <span class="hljs-string">&quot;/&quot;</span>  <span class="hljs-string">&quot;http://127.0.0.1:3000&quot;</span>         将所有请求（<span class="hljs-string">&quot;/&quot;</span>）代理到一个后端：<br>ProxyPassReverse <span class="hljs-string">&quot;/&quot;</span>  <span class="hljs-string">&quot;http://127.0.0.1:3000&quot;</span>  为了确保Location:将从后端生成的和标头修改为指向反向代理，而不是返回自身<br></code></pre></td></tr></table></figure><p>即可！</p><p>官方文档：<a href="https://www.apachehttpd.com/howto/reverse_proxy.html">反向代理设置指南_Apache中文文档 (apachehttpd.com)</a></p><h3 id="四、上传项目代码"><a href="#四、上传项目代码" class="headerlink" title="四、上传项目代码"></a>四、上传项目代码</h3><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>CentOS 7安装git，通过git从github克隆项目仓库。这样做的好处是：本地所做的更改可以方便地通过git命令同步到服务器上。</p><p>通过yum命令直接安装，方法简单，并且会自动安装依赖的包，而且会从源里安装最新的版本（不过不一定是最新的git）。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> git<br></code></pre></td></tr></table></figure><p>查看git版本</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p>配置name和email</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;timegogo&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>创建SSH Key</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ssh-keygen -t rsa</span><br></code></pre></td></tr></table></figure><p>根据提示，可以看到在&#x2F;root&#x2F;.ssh&#x2F;目录下新增了id_rsa和id_rsa.pub两个文件。登陆github，打开Account Settings 打开SSH Keys页面，添加SSH Key，把id_rsa.pub里面的内容复制进去，保存</p><h4 id="clone项目"><a href="#clone项目" class="headerlink" title="clone项目"></a>clone项目</h4><p>在&#x2F;home下新建&#x2F;node目录，</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">地址</span><br></code></pre></td></tr></table></figure><p><strong>完善数据</strong>，因为是从本地项目移植到服务器上的，所以数据库并不是同一个，需要把数据库的数据同步，或者说重新初始化一份数据。</p><p>这里尝试把本地数据库的数据移植到云上的数据库。</p><h3 id="五、启动Express服务"><a href="#五、启动Express服务" class="headerlink" title="五、启动Express服务"></a>五、启动Express服务</h3><p><strong>安装pm2</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g pm2<br></code></pre></td></tr></table></figure><p><strong>pm2是一个进程管理工具,可以用它来管理你的node进程，并查看node进程的状态，当然也支持性能监控，进程守护，负载均衡等功能</strong></p><p>通过pm2可以让node项目在服务器上永久运行，而且不会一包错就把express服务挂掉，而且运行中还可以进行其它操作。</p><p>切换到Express项目根目录下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">pm2 start .<span class="hljs-regexp">/bin/</span>www<br></code></pre></td></tr></table></figure><p><strong>至此，直接输入域名就可以访问到我们部署的Express项目啦！</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>将一个本地开发好的项目移植到云服务上，主要步骤依次为：搭建项目运行环境、安装并测试数据库连接、安装必要的包、安装git并从github克隆项目、开放服务器的端口、设置服务端的http代理、安装pm2永远运行项目。</p><p>在设置服务端http代理这一步，卡了大量的时间，原因在于对于Apache不熟悉，不知道如何设置反向代理，网上的经验贴质量也参次不齐。最后靠看官网文档 + 大胆尝试 实现了。（官方文档永远都是最靠谱的）</p><p>整个过程下来，熟悉了一遍上线项目的流程，其实理解之后会发现上线的原理很简单，并没有想象的那么难，就是在服务器上创建一个一模一样的环境，让项目运行在上面，同时设置一下访问代理，通过代理访问到项目服务器。中间了解到了一个关键的知识点，就是 <strong>代理</strong>，包括正向代理和反向代理。然后学习了如何通过Apache（在CentOS上httpd）来设置反向代理。</p><p>但是我知道其实还存在很多问题没有解决，比如没有将node的项目环境修改为生产环境，没有做任何性能优化等等。</p><p>路漫漫其修远兮……</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="bug1：无法启动mongod服务"><a href="#bug1：无法启动mongod服务" class="headerlink" title="bug1：无法启动mongod服务"></a>bug1：无法启动mongod服务</h4><p>安装配置好mongodb server之后，使用<code>systemctl start mongod</code>作为系统服务启动，但是失败了，报了下面的错误</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Job <span class="hljs-keyword">for</span> mongod.service failed because <span class="hljs-keyword">the</span> control <span class="hljs-built_in">process</span> exited <span class="hljs-keyword">with</span> error code. See <span class="hljs-string">&quot;systemctl status mongod.service&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;journalctl -xe&quot;</span> <span class="hljs-keyword">for</span> details.<br></code></pre></td></tr></table></figure><p>输入<code>systemctl status mongod.service</code>查看输出如下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk">● mongod.service - MongoDB Database Server<br>   Loaded: loaded (<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/systemd/</span>system/mongod.service; enabled; vendor preset: disabled)<br>   Active: failed (Result: <span class="hljs-keyword">exit</span>-code) since Mon <span class="hljs-number">2022</span>-<span class="hljs-number">04</span>-<span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">49</span> CST; <span class="hljs-number">23</span>min ago<br>     Docs: https:<span class="hljs-regexp">//</span>docs.mongodb.org/manual<br>  Process: <span class="hljs-number">24833</span> ExecStart=<span class="hljs-regexp">/usr/</span>bin/mongod <span class="hljs-variable">$OPTIONS</span> (code=exited, status=<span class="hljs-number">14</span>)<br>  Process: <span class="hljs-number">24830</span> ExecStartPre=<span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/chmod 0755 /</span>var<span class="hljs-regexp">/run/m</span>ongodb (code=exited, status=<span class="hljs-number">0</span>/SUCCESS)<br>  Process: <span class="hljs-number">24826</span> ExecStartPre=<span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/chown mongod:mongod /</span>var<span class="hljs-regexp">/run/m</span>ongodb (code=exited, status=<span class="hljs-number">0</span>/SUCCESS)<br>  Process: <span class="hljs-number">24824</span> ExecStartPre=<span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/mkdir -p /</span>var<span class="hljs-regexp">/run/m</span>ongodb (code=exited, status=<span class="hljs-number">0</span>/SUCCESS)<br><br>Apr <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">48</span> iZwz913vjju8a7uxhrlugnZ systemd[<span class="hljs-number">1</span>]: Starting MongoDB Database Server...<br>Apr <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">48</span> iZwz913vjju8a7uxhrlugnZ mongod[<span class="hljs-number">24833</span>]: about to fork child process, waiting until...s.<br>Apr <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">48</span> iZwz913vjju8a7uxhrlugnZ mongod[<span class="hljs-number">24833</span>]: forked process: <span class="hljs-number">24836</span><br>Apr <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">49</span> iZwz913vjju8a7uxhrlugnZ mongod[<span class="hljs-number">24833</span>]: ERROR: child process failed, exited with <span class="hljs-number">14</span><br>Apr <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">49</span> iZwz913vjju8a7uxhrlugnZ mongod[<span class="hljs-number">24833</span>]: To see additional information <span class="hljs-keyword">in</span> this outp...n.<br>Apr <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">49</span> iZwz913vjju8a7uxhrlugnZ systemd[<span class="hljs-number">1</span>]: mongod.service: control process exited, code=...<span class="hljs-number">14</span><br>Apr <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">49</span> iZwz913vjju8a7uxhrlugnZ systemd[<span class="hljs-number">1</span>]: Failed to start MongoDB Database Server.<br>Apr <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">49</span> iZwz913vjju8a7uxhrlugnZ systemd[<span class="hljs-number">1</span>]: Unit mongod.service entered failed state.<br>Apr <span class="hljs-number">11</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">49</span> iZwz913vjju8a7uxhrlugnZ systemd[<span class="hljs-number">1</span>]: mongod.service failed.<br></code></pre></td></tr></table></figure><p>百度查找，说是文件权限的原因，一开始以为是<code>数据库/var/lib/mongo</code>和<code>日志/var/log/mongodb/mongod.log</code>这两个目录的权限问题，但是发现并没有问题，属主和数组都是mongod（因为是使用rpm安装mongodb server过程中自动创建的）</p><p>再查百度，发现了真正的问题所在，是<code>/tmp/mongodb-27017.sock</code>这个文件的问题，它的属主为root，mongod没有足够的权限</p><p>解决方案：修改<code>/tmp/mongodb-27017.sock</code>的属主为mongod</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">chown mongod:mongod <span class="hljs-regexp">/tmp/m</span>ongodb-<span class="hljs-number">27017</span>.sock<br></code></pre></td></tr></table></figure><p>然后重新启动，即可</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> mongod<br></code></pre></td></tr></table></figure><h4 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h4><p><a href="https://cloud.tencent.com/developer/article/1538014?from=article.detail.1494192">服务器小白的我,是如何将 node+mongodb 项目部署在服务器上并进行性能优化的 - 云+社区 - 腾讯云 (tencent.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>post</title>
    <link href="/2022/04/11/%E5%89%8D%E7%AB%AF/%E4%BA%86%E8%A7%A3Express%E6%A1%86%E6%9E%B6/"/>
    <url>/2022/04/11/%E5%89%8D%E7%AB%AF/%E4%BA%86%E8%A7%A3Express%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>Express是node.js运行环境中，一款最受欢迎的后端开发框架</p><span id="more"></span><h1 id="Express框架"><a href="#Express框架" class="headerlink" title="Express框架"></a>Express框架</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>Node.js 已经成为 Web 后台开发圈一股不容忽视的力量，凭借其良好的异步性能、丰富的 npm 库以及 JavaScript 语言方面的优势，已经成为了很多大公司开发其后台架构的重要技术之一，而 Express 框架则是其中知名度最高、也是最受欢迎的后端开发框架。</p><p>接下来，我们将了解Express在Node内置的http模块上做了怎样的封装，并掌握<strong>路由</strong>和<strong>中间件</strong>这两个关键概念，学习如何使用 <strong>模板引擎</strong>、<strong>静态文件服务</strong>、<strong>错误处理</strong>和 <strong>JSON API</strong></p><h3 id="二、用Express搭建服务器"><a href="#二、用Express搭建服务器" class="headerlink" title="二、用Express搭建服务器"></a>二、用Express搭建服务器</h3><h4 id="强大的Request和Respose对象"><a href="#强大的Request和Respose对象" class="headerlink" title="强大的Request和Respose对象"></a>强大的Request和Respose对象</h4><ul><li><code>req.body</code>：客户端请求体的数据，可能是表单或 JSON 数据</li><li><code>req.params</code>：请求 URI 中的路径参数</li><li><code>req.query</code>：请求 URI 中的查询参数</li><li><code>req.cookies</code>：客户端的 cookies</li></ul><h4 id="路由机制"><a href="#路由机制" class="headerlink" title="路由机制"></a>路由机制</h4><p>客户端向服务器发送请求包含两部分：路径（Url）和请求方法（POST、GET），合起来统称<strong>API端点</strong></p><p>服务器根据客户端访问的端点选择对应的处理逻辑的机制就叫做<strong>路由</strong></p><p>定义方式：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs pgsql">app.<span class="hljs-keyword">METHOD</span>(<span class="hljs-type">PATH</span>, <span class="hljs-keyword">HANDLER</span>)<br></code></pre></td></tr></table></figure><ul><li><code>app</code> 就是一个 <code>express</code> 服务器对象</li><li><code>METHOD</code> 可以是任何<strong>小写</strong>的 HTTP 请求方法，包括 <code>get</code>、<code>post</code>、<code>put</code>、<code>delete</code> 等等</li><li><code>PATH</code> 是客户端访问的 URI，例如 <code>/</code> 或 <code>/about</code></li><li><code>HANDLER</code> 是路由被触发时的回调函数，在函数中可以执行相应的业务逻辑</li></ul><h4 id="nodemon热加载"><a href="#nodemon热加载" class="headerlink" title="nodemon热加载"></a>nodemon热加载</h4><p>Nodemon 是一款颇受欢迎的开发服务器，能够<strong>检测工作区代码的变化，并自动重启</strong>。通过以下命令安装 nodemon：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">npm install nodemon --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>这里我们将 nodemon 安装为开发依赖 <code>devDependencies</code>，因为仅仅只有在开发时才需要用到。同时我们在 package.json 中加入 <code>start</code> 命令，代码如下：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stata">package.json查看完整代码<br>&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;express_resume&quot;</span>,<br>  <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;main&quot;</span>: <span class="hljs-string">&quot;index.js&quot;</span>,<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;nodemon server.js&quot;</span>,<br>    <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;</span><span class="hljs-keyword">Error</span>: <span class="hljs-keyword">no</span> <span class="hljs-keyword">test</span> specified\<span class="hljs-string">&quot; &amp;&amp; exit 1&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;license&quot;</span>: <span class="hljs-string">&quot;ISC&quot;</span>,<br>  <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;express&quot;</span>: <span class="hljs-string">&quot;^4.17.1&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;devDependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;nodemon&quot;</span>: <span class="hljs-string">&quot;^2.0.2&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、编写中间件"><a href="#三、编写中间件" class="headerlink" title="三、编写中间件"></a>三、编写中间件</h3><p><strong>理解中间件</strong>，不是Express独有的概念，是指<strong>将具体的业务逻辑和底层逻辑解耦的组件</strong>。换句话说，中间件就是能够适用多个应用场景、可复用性良好的代码。</p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/middleware.png" alt="img"></p><p>例如博客网站项目里面，用于上传文件的multer中间件，添加在路由参数当中。</p><p><strong>Express里的中间件</strong>，就是函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> some<span class="hljs-constructor">Middleware(<span class="hljs-params">req</span>, <span class="hljs-params">res</span>, <span class="hljs-params">next</span>)</span> &#123;  <span class="hljs-comment">// 自定义逻辑  next();&#125;</span><br></code></pre></td></tr></table></figure><p>三个参数中，<code>req</code> 和 <code>res</code> 就是前面提到的 Request 请求对象和 Response 响应对象；而 <code>next</code> 函数则用来触发下一个中间件的执行。</p><p>在 Express 使用中间件有两种方式：<strong>全局中间件</strong>和<strong>路由中间件</strong>。</p><p>通过 <code>app.use</code> 函数就可以注册中间件，并且此中间件会在用户发起<strong>任何请求</strong>都可能会执行，例如：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">app</span>.<span class="hljs-keyword">use</span>(someMiddleware);<br></code></pre></td></tr></table></figure><h4 id="路由中间件"><a href="#路由中间件" class="headerlink" title="路由中间件"></a>路由中间件</h4><p>通过在路由定义时注册中间件，此中间件只会在用户访问该路由对应的 URI 时执行，例如：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">app.get(<span class="hljs-string">&#x27;/middleware&#x27;</span>, someMiddleware, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;Hello World&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="四、模板引擎"><a href="#四、模板引擎" class="headerlink" title="四、模板引擎"></a>四、模板引擎</h3><p>设置模板引擎</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">app.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;views&#x27;</span>, <span class="hljs-string">&#x27;views&#x27;</span>);    指定模板文件的目录，即第二个参数<br>app.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;hbs&#x27;</span>);指定模板引擎为hbs<br></code></pre></td></tr></table></figure><p>在views文件夹下创建页面文件</p><p>在路由函数中调用res.render即可进行渲染</p><h3 id="五、静态文件服务"><a href="#五、静态文件服务" class="headerlink" title="五、静态文件服务"></a>五、静态文件服务</h3><p>通常网站需要提供静态文件服务，例如图片、CSS 文件、JS 文件等等，而 Express 已经自带了静态文件服务中间件 <code>express.static</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">app.<span class="hljs-keyword">use</span>(express.<span class="hljs-built_in">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>));<br></code></pre></td></tr></table></figure><p>通过以上代码来添加静态文件目录</p><p>可以通过url访问，<code>http://localhost:3000/css/style.css</code>，不必添加public</p><p>也可以在&#x2F;views下的文件引用静态资源，src为<code>/css/style.css</code></p><h3 id="六、处理404和服务器错误"><a href="#六、处理404和服务器错误" class="headerlink" title="六、处理404和服务器错误"></a>六、处理404和服务器错误</h3><ul><li>客户端方面的错误（状态码 4xx），例如访问了不存在的页面（404）、权限不够（403）等等</li><li>服务器方面的错误（状态码 5xx），例如服务器内部出现错误（500）或网关错误（503）等等</li></ul><p>完善一下 Express 中间件的运作流程，如下图所示：</p><p><img src="https://static.powerformer.com/c/cd5b993/middleware-new.png"></p><p>从图中可以看到，中间件和路由是从前往后执行的，当路由匹配到对应的url时，直接返回响应；不匹配则继续检查下一个路由。</p><p>中间件不仅可以调用next函数向下传递、还可以直接抛出异常</p><ul><li><p>404的处理，需要在所有路由后面再加一个中间件，用来接收所有路由均匹配失败的请求</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">app.use(<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>  <span class="hljs-regexp">//</span> ...<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>错误处理，前面所有中间件抛出异常时都会进入错误处理函数</p></li></ul><p><strong>处理内部错误</strong></p><p>Express 的默认错误处理机制可以通过设置 <code>NODE_ENV</code> 来进行切换。我们将其设置为生产环境 <code>production</code>，再开启服务器。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> <span class="hljs-attribute">NODE_ENV</span>=production<br>node server.js<br></code></pre></td></tr></table></figure><p>这样做的目的是，访问出错时，会直接返回 Internal Server Error（服务器内部错误），不会显示任何错误信息，这样避免了被攻击的风险！</p><p><strong>自定义错误处理逻辑</strong></p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">app.use(<span class="hljs-string">&#x27;/&#x27;</span>, indexRouter);  指定到一个正常处理路由的文件<br>app.use(<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-function"><span class="hljs-params">(req,res)</span>=&gt;</span>&#123;<br>res.status(<span class="hljs-number">404</span>).reder(<span class="hljs-string">&#x27;404&#x27;</span>,&#123;<span class="hljs-name">url</span>:req.originalUrl&#125;)  设置状态码<span class="hljs-number">404</span>，显示输入的url<br>&#125;)<br>app.use(<span class="hljs-function"><span class="hljs-params">(err,req,res,<span class="hljs-built_in">next</span>)</span>=&gt;</span>&#123;<br>console.<span class="hljs-built_in">error</span>(err.stack);<br>res.status(<span class="hljs-number">500</span>).render(<span class="hljs-string">&#x27;500&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="七、子路由"><a href="#七、子路由" class="headerlink" title="七、子路由"></a>七、子路由</h3><p>使用子路由拆分逻辑，但项目越大时，全部路由写在server.js或者app.js里面会显得很臃肿。可以通过子路由 <code>Router</code> 来实现逻辑拆分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>();<br></code></pre></td></tr></table></figure><p><code>express.Router</code> 可以理解为一个迷你版的 <code>app</code> 对象，但是它功能完备，同样支持注册中间件和路由：</p><p><strong>使用方法</strong></p><p>在app.js（或server.js）中</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">var</span> express = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> app = <span class="hljs-title function_ invoke__">express</span>();<br><span class="hljs-keyword">var</span> indexRouter = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;./routes/index&#x27;</span>);<br>app.<span class="hljs-keyword">use</span>(<span class="hljs-string">&#x27;/&#x27;</span>, indexRouter);<br></code></pre></td></tr></table></figure><p>在index文件中，也可以正常添加中间件</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> <span class="hljs-built_in">express</span> = require(&#x27;<span class="hljs-built_in">express</span>&#x27;);<br><span class="hljs-built_in">var</span> router = <span class="hljs-built_in">express</span>.Router();<br>router.<span class="hljs-built_in">get</span>(&#x27;/&#x27;, home.home);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发——性能优化</title>
    <link href="/2022/04/11/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2022/04/11/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="前端开发——性能优化"><a href="#前端开发——性能优化" class="headerlink" title="前端开发——性能优化"></a>前端开发——性能优化</h2><p>性能优化的目的一在于为企业节省流量成本，二在于提高用户的使用体验</p><p><strong>分模块论述</strong></p><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><ul><li><strong>减少HTTP请求</strong>，即减少html里面css&#x2F;js等资源的数量</li><li><strong>使用HTTP2.0</strong>，建立在https的基础上（更安全），采用二进制个数传输数据（1.0是文本格式），消息头采用压缩传输可以节省流量</li><li><strong>白屏时间作为加载动画</strong>，优化用户体验</li></ul><h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><ul><li><strong>静态资源做CDN缓存</strong></li><li><strong>把css放在文件头部，js放在底部</strong>，css异步同时开始加载，js会阻塞html的解析</li><li><strong>gzip压缩</strong>，服务器配置gzip压缩传输方式（如nginx可以配置），如果浏览器支持gzip解析，服务器就可以推送gzip资源</li><li><strong>做服务端渲染（ssr）</strong>，在服务侧完成html的拼接，发送到浏览器，然后为其绑定状态和事件，成为一个可交互页面</li></ul><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><ul><li><strong>字体图标代替图片图标</strong>，可以减少对图片资源的请求</li><li><strong>使用精灵图</strong>，把众多的较小的装饰图片合成到一张大图里面，减少加载图片的次数，缺点是精灵图维护比较麻烦</li><li><strong>图片懒加载</strong>，浏览器优先加载可视范围内的图片，其它部分等进入可视区域再加载，实现原理：先给所有img的src赋予一个loading图，图片没有进入可视区域时，赋予真正的src</li><li><strong>使用png格式</strong>，是web图像中最通用的无损压缩格式</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li><strong>减少重绘回流</strong>，回流就是当元素尺寸布局发生变化时，DOM需要重新构建。元素更新外观样式时需要重绘</li><li><strong>慎用全局变量</strong>，全局变量定义在全局执行上下文，是所有作用域链的顶端。局部找不到就会一直往上找，影响性能</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客网站demo</title>
    <link href="/2022/04/10/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99demo/"/>
    <url>/2022/04/10/%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99demo/</url>
    
    <content type="html"><![CDATA[<p>一个使用 Express框架 + bootstrap框架 + mongoDB数据库 搭建的图文博客网站demo，出于个人兴趣的练习项目</p><span id="more"></span><h1 id="个人博客网站"><a href="#个人博客网站" class="headerlink" title="个人博客网站"></a>个人博客网站</h1><h3 id="一、项目简介"><a href="#一、项目简介" class="headerlink" title="一、项目简介"></a>一、项目简介</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>学习计算机专业多年，从来没有自己做过网站，觉得是一个遗憾。今年开年的学期，没有课程了，所以决定自己动手造一个网站，由于自己平时喜欢拍拍照片、出去游玩，所以就决定造一个图文类的博客网站。但是之前没有学过前端的技术，几乎从零开始，边学边做。前一周学和练HTML和CSS，但是只能做静态网页。后面找到了Express框架，终于可以搭建一个能够和服务端数据库交互的真正意义上的网站（而不只是网页）。话不多说，直接上实现后的界面效果图</p><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><strong>主页</strong></p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220410200144622-16495968830811.png" alt="image-20220410200442015"></p><p><strong>分类页</strong></p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220410200248757.png" alt="image-20220410200248757"></p><p><strong>照片页</strong></p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220410200335584.png" alt="image-20220410200335584"></p><p><strong>后台管理页</strong></p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220410200442015-16495968946153.png" alt="image-20220410200144622"></p><p><strong>由于一些突发原因，项目没有上线到服务器</strong>，所以目前停留在本地运行的阶段，没有办法提供链接进行访问（只能在本地运行）。</p><h3 id="二、项目规划"><a href="#二、项目规划" class="headerlink" title="二、项目规划"></a>二、项目规划</h3><p>实际项目搭建花了两次，第一次是刚接触Express框架，作为熟悉入门，但是后面文件越建越多的时候，明显感觉到项目极不规范，</p><p>所以这时重头搭建了一次，从项目的全局规划开始，</p><p><strong>第一步</strong>，设计全局的路由规划、数据Model、资源目录的分组、项目文件的分组；</p><p><strong>第二步</strong>，学习git版本管理，按项目进度阶段保存项目的版本（所以也是git管理的练手项目）；</p><p><strong>第三步</strong>，就是分页面进行UI设计、功能实现。</p><p>下面是具体的规划设计（实际项目过程中有一些变动，另外增加了一个Model）</p><h4 id="路由规划"><a href="#路由规划" class="headerlink" title="路由规划"></a><strong>路由规划</strong></h4><table><thead><tr><th>地址</th><th>页面</th><th>控制器、方法</th><th>view</th></tr></thead><tbody><tr><td>&#x2F;</td><td>首页</td><td>homeController.home</td><td>home</td></tr><tr><td>&#x2F;article&#x2F;:id</td><td>文章详情页</td><td>articleController.detail</td><td>article_detail</td></tr><tr><td>&#x2F;article&#x2F;classifier</td><td>文章分类页</td><td>articleController.classifier</td><td>classifier</td></tr><tr><td>&#x2F;article&#x2F;classifier&#x2F;study</td><td>文章分类页（学习笔记）</td><td>articleController.classifier_study</td><td>classifier_study</td></tr><tr><td>&#x2F;article&#x2F;classifier&#x2F;life</td><td>文章分类页（生活感悟）</td><td>articleController.classifier_life</td><td>classifier_life</td></tr><tr><td>&#x2F;article&#x2F;classifier&#x2F;other</td><td>文章分类页（其它）</td><td>articleController.classifier_other</td><td>classifier_other</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>&#x2F;photos</td><td>照片展示页</td><td>photoController.home</td><td>photos</td></tr><tr><td>&#x2F;photos&#x2F;:id</td><td>照片详情页</td><td>photoController.detail</td><td>photo_detail</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>&#x2F;manage&#x2F;article&#x2F;all</td><td>文章管理页（全部分类）<br />后台管理默认页面</td><td>articleController.manage_list</td><td>manage_article</td></tr><tr><td>&#x2F;manage&#x2F;article&#x2F;study</td><td>文章管理页（学习笔记）</td><td>articleController.manage_study</td><td>manage_article_study</td></tr><tr><td>&#x2F;manage&#x2F;article&#x2F;life</td><td>文章管理页（生活感悟）</td><td>articleController.manage_life</td><td>manage_article_life</td></tr><tr><td>&#x2F;manage&#x2F;article&#x2F;other</td><td>文章管理页（其它）</td><td>articleController.manage_other</td><td>manage_article_other</td></tr><tr><td>&#x2F;manage&#x2F;article&#x2F;:id</td><td>文章详情管理页</td><td>articleController.manage_detail</td><td>manage_article_detail</td></tr><tr><td>&#x2F;manage&#x2F;article&#x2F;:id&#x2F;update</td><td>无页面（提交文章修改post）</td><td>articleController.manage_detail_update</td><td>重定向到文章详情页</td></tr><tr><td>&#x2F;manage&#x2F;article&#x2F;:id&#x2F;remove</td><td>无页面（提交文章删除请求）</td><td>articleController.manage_detail_remove</td><td>重定向到文章管理页（全部）</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>&#x2F;manage&#x2F;photos</td><td>照片管理页</td><td>photoController.manage_list</td><td>manage_photos</td></tr><tr><td>&#x2F;manage&#x2F;photos&#x2F;:id</td><td>照片详情管理页</td><td>photoController.manage_detail</td><td>manage_photos_detail</td></tr><tr><td>&#x2F;manage&#x2F;photos&#x2F;:id&#x2F;update</td><td>无（提交照片修改post）</td><td>photoController.manage_detail_update</td><td>重定向到照片详情页</td></tr><tr><td>&#x2F;manage&#x2F;photos&#x2F;:id&#x2F;remove</td><td>无（提交照片remove）</td><td>photoController.manage_detail_remove</td><td>重定向到照片管理页</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>&#x2F;manage&#x2F;people</td><td>个人信息管理页</td><td>peopleController.manage</td><td>manage_people</td></tr><tr><td>&#x2F;manage&#x2F;people&#x2F;update</td><td>无页面（提交修改表单）</td><td>peopleController.update</td><td>重定向到manage_people</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>&#x2F;manage&#x2F;new&#x2F;article</td><td>文章发布页</td><td>articleController.manage_new</td><td>manage_new_article</td></tr><tr><td>&#x2F;manage&#x2F;new&#x2F;article&#x2F;create</td><td>无页面（提交文章新建的post）</td><td>articleController.manage_new_create</td><td>重定向到文章详情页</td></tr><tr><td>&#x2F;manage&#x2F;new&#x2F;photo</td><td>照片上传页</td><td>photoController.manage_new</td><td>manage_new_photo</td></tr><tr><td>&#x2F;manage&#x2F;new&#x2F;photo&#x2F;upload</td><td>无页面（照片上传的post）</td><td>photoController.manage_new_upload</td><td>重定向到照片详情页</td></tr></tbody></table><h4 id="数据Model"><a href="#数据Model" class="headerlink" title="数据Model"></a><strong>数据Model</strong></h4><ul><li>Article</li></ul><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td>String</td><td>文章标题 required:true</td></tr><tr><td>classification</td><td>String</td><td>文章分类 required: true, default: “其它”</td></tr><tr><td>abstract</td><td>String</td><td>文章摘要</td></tr><tr><td>content</td><td>String</td><td>文章内容</td></tr><tr><td>picture</td><td>String</td><td>配图的路径+文件名</td></tr><tr><td>timestamp</td><td>Date</td><td>创建时间 default: Date.now()</td></tr><tr><td>url</td><td>virtual</td><td>&#x2F;article&#x2F;this.id</td></tr><tr><td>date</td><td>virtual</td><td>moment(this.timestamp).format(“YYYY MMMM Do”)</td></tr></tbody></table><ul><li>People</li></ul><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>String</td><td>昵称</td></tr><tr><td>description</td><td>String</td><td>简介</td></tr><tr><td>photo</td><td>String</td><td>头像的路径+文件名</td></tr><tr><td>github</td><td>String</td><td>github链接（需要添加前缀https:&#x2F;&#x2F;)</td></tr><tr><td>wechat</td><td>String</td><td>微信名片图片的路径+文件名</td></tr><tr><td>weibo</td><td>String</td><td>微博首页链接（需要添加前缀https:&#x2F;&#x2F;)</td></tr></tbody></table><ul><li>Photos</li></ul><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td>String</td><td>照片标题</td></tr><tr><td>description</td><td>String</td><td>照片简介</td></tr><tr><td>file</td><td>String</td><td>照片保存的路径+文件名</td></tr><tr><td>timestamp</td><td>Date</td><td>照片上传的时间 default:Date.now()</td></tr><tr><td>views</td><td>Number</td><td>点击量 default:0</td></tr><tr><td>url</td><td>virtual</td><td>&#x2F;photos&#x2F;this.id</td></tr><tr><td>date</td><td>virtual</td><td>moment(this.timestamp).format(“YYYY MMMM Do”)</td></tr></tbody></table><h4 id="public目录"><a href="#public目录" class="headerlink" title="public目录"></a><strong>public目录</strong></h4><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>…</td><td>其它自带的目录</td></tr><tr><td>&#x2F;images&#x2F;article</td><td>保存所有的文章配图</td></tr><tr><td>&#x2F;images&#x2F;people</td><td>保存个人头像、微信名片</td></tr><tr><td>&#x2F;images&#x2F;photos</td><td>保存所有上传的照片</td></tr></tbody></table><h3 id="三、项目收获"><a href="#三、项目收获" class="headerlink" title="三、项目收获"></a>三、项目收获</h3><h4 id="项目亮点"><a href="#项目亮点" class="headerlink" title="项目亮点"></a>项目亮点</h4><p>外观设计比较整洁美观，页面做了响应式设计，具有交互性的动效</p><p>功能比较完整，能够在网页上实现增删改的操作</p><h4 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h4><p><strong>富文本编辑器的应用</strong></p><p>这是目前为止，没有解决的问题。文章管理那一部分，我本来是想通过一个富文本编辑器的插件来实现编辑和修改的。可用的富文本编辑器插件有很多，原理基本都是把编辑器的内容保存为html文件，存放到服务器上，访问文章的时候返回html文件。这里涉及到一个冲突，因为文章页我自己设计的是有一个导航栏+页头背景图的，所以已经需要有一个jade文件来渲染了，所以没有办法直接返回只有文章内容的html（学习了html之后，发现可能可以通过iframe实现html的嵌入）。另外文章图片的插入预想也比较麻烦，文章里面（或者说html里面）不可能直接放置照片，只能放置照片的url，所以照片的保存需要另外处理。文章的修改也比较麻烦，预想方案是文章纯文本和html各自保存一份，修改直接在纯文本上做，改完覆盖掉原来的html。</p><p><strong>文章分类数量的管理</strong></p><p>算不上难点，但也能算是一个技术点，涉及到数据库的操作思路。在首页放置了一个分类的卡片标签，左侧为分类名字，右侧为该分类下的文章数量。一开始规划的时候之后Article一个数据模型，里面保存了文章的详细信息和分类信息，但是如果只有这个Model的话，每次加载首页的时候，都要把Article 集合（Collection）里面所有记录遍历一遍，所以明显不够合理。为此，增加了一个Classifier的数据Model，专门用来记录分类的数量信息。这样做的优势在于：查询效率很高；缺点在于：文章做增删改查时多了一个要维护的数据Model，增加了文章增删改查的工作量。</p><h4 id="实践经验"><a href="#实践经验" class="headerlink" title="实践经验"></a>实践经验</h4><p>通过这次项目，上手练习了多项技术，有<strong>Express框架、bootstrap框架、MongoDB数据库、Node.js服务器、jade语言，还有git版本管理工具</strong>。</p><p>以上列举的，都是第一次使用的框架和工具。</p><p><strong>Express框架</strong>是通过另外一个教程接触的，但是在搭建本项目的过程中，才更深刻地了解到里面的一些原理，如它的路由机制是怎样一条链路（网页的链接url——router文件——Controller管理器的具体函数——[渲染的新页面]）。</p><p>为了高效的管理页面样式，在编辑页面UI之前，特定花了一两天时间，阅读了一边<strong>bootstrap5</strong>的参考文档，在设计页面的时候尽量使用了bootstrap的元素和组件，比如所有的卡片、照片页的轮播图、表单、侧边导航栏。</p><p>为了实现开发过程中的版本管理，花了半天的时间学习<strong>git如何使用</strong>，并记录了阅读笔记，在开发过程中，通过tag和分支保存并同步到github多个版本。</p><p>页面采用<strong>jade语言</strong>写的（问为什么选jade，因为express默认采用了jade模板引擎），这个语言也是之前完全陌生的，所以写的时候遇到很多不知道解决的问题，尽管它确实有很多优势（语法糖、书写简洁、可以嵌套、可以复用等），但是配套的教程文档太少，有时一些特别的问题无从解决。</p><p>在开发过程中，也深切感受到了Express的一些局限（也有可能是我还没有发掘出Express对应的用法）</p><p>比如Express使用jade模板引擎，有一个好处就是每次可以传入不同的数据从而渲染出不同的页面。但是也有一个弊端，就是jade没有办法像html一样嵌入javasript代码或文件，所以想要实现涉及到数据方面的交互很困难（一般都交互还是可以的，把javasript文件放到public目录下就可以引用了）。当时想要在页面里面做一个分类管理的时候，发现没有办法通过js交互来改变显示的数据。</p><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><p>这个项目是在零星学了一些HTML和CSS的基础上开始的，在做这个项目之前没有比较体系化地接受到前端知识的培训，所以在实际做的过程中存在着挺多局限。在写此文的时候，笔者已经较为系统地学习了HTML和CSS的入门知识，就已经发现了一个很不规范的地方，就是页面书写的时候没有结构化的意识，大量使用了div这种无语义的元素（知识局限、不知道有那么多的语义元素），所以写出来的文件可读性较差。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发——JS</title>
    <link href="/2022/04/10/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94JS%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2022/04/10/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94JS%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前端开发——JavaScript"><a href="#前端开发——JavaScript" class="headerlink" title="前端开发——JavaScript"></a>前端开发——JavaScript</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p><strong>在HTML中加载JS</strong></p><ol><li><p><strong>方式一</strong>，在ＨＴＭＬ中通过script标签，将JS代码包裹在内，推荐在外层包裹一层，确保HTML先加载完毕</p><figure class="highlight nim"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs nim">document.addEventListener(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, function() <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>方式二</strong>，通过script标签引入外部js文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>async关键字</strong>，如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 <code>async</code></p><p><strong>defer关键字</strong>，如果脚本需要等待页面解析，且依赖于其它脚本，调用这些脚本时应使用 <code>defer</code>，将关联的脚本按所需顺序置于 HTML 中</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构——队列</title>
    <link href="/2022/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/"/>
    <url>/2022/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>FIFO，先进先出</p><span id="more"></span><h2 id="数据结构——队列"><a href="#数据结构——队列" class="headerlink" title="数据结构——队列"></a>数据结构——队列</h2><p><strong>语法：</strong><code>template&lt;class T, class Container = deque&lt;T&gt; &gt; class queue</code></p><p><strong>特性：FIFO</strong>，先进先出，队尾插入、队头删除</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><table><thead><tr><th>empty</th><th>如果队列为空，则该函数返回true，否则返回false</th></tr></thead><tbody><tr><td><strong>size</strong></td><td>返回队列中元素的个数</td></tr><tr><td><strong>push</strong></td><td>在末尾插入一个新元素，返回值为void</td></tr><tr><td><strong>pop</strong></td><td>删除第一个元素，返回值为void</td></tr><tr><td><strong>front</strong></td><td>返回第一个元素</td></tr><tr><td><strong>back</strong></td><td>返回最后一个元素</td></tr></tbody></table><h4 id="leetcode题库"><a href="#leetcode题库" class="headerlink" title="leetcode题库"></a>leetcode题库</h4><table><thead><tr><th>题目</th><th>题解</th></tr></thead><tbody><tr><td>225.用队列实现栈</td><td>双队列，push时不断交换，让栈顶始终在队头</td></tr><tr><td>232.用栈实现队列</td><td>双栈，push时不断倒换，让队头始终在栈顶</td></tr><tr><td>341.扁平化嵌套列表迭代器</td><td>深度优先遍历 + 队列的应用 + 现学接口如何使用</td></tr><tr><td>387.第一个唯一字符</td><td>两次遍历字符串，用map或者int数组保存字符出现次数，简单题</td></tr><tr><td>239.滑动窗口最大值</td><td>双向队列deque，保存数组指针（而非数组值），队头到队尾单调递减。空间换时间，困难题<br />拓展：滑动窗口平均值</td></tr></tbody></table><h2 id="双向队列，deque"><a href="#双向队列，deque" class="headerlink" title="双向队列，deque"></a>双向队列，deque</h2><h4 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h4><table><thead><tr><th><strong>push_back</strong></th><th>插入队尾</th></tr></thead><tbody><tr><td><strong>push_front</strong></td><td>插入队头</td></tr><tr><td><strong>pop_back</strong></td><td>从队尾删除</td></tr><tr><td><strong>pop_front</strong></td><td>从队头删除</td></tr><tr><td><strong>front</strong></td><td>返回队头元素</td></tr><tr><td><strong>back</strong></td><td>返回队尾元素</td></tr><tr><td><strong>insert</strong></td><td>insert (iterator position, const value_type&amp; val)，指定位置插入值<br />void insert (iterator position, size_type n, const value_type&amp; val)，指定位置插入值，重复插入n个<br />void insert (iterator position, InputIterator first, InputIterator last)，指定位置插入另外一个容器的值列表</td></tr><tr><td><strong>erase</strong></td><td>两种参数，<br />erase (iterator position);<br />erase (iterator first, iterator last);</td></tr><tr><td><strong>size</strong></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发——JavaScript</title>
    <link href="/2022/04/02/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94JavaScript/"/>
    <url>/2022/04/02/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94JavaScript/</url>
    
    <content type="html"><![CDATA[<p>JavaScript是异步的</p><span id="more"></span><h3 id="一、Callback-回调机制"><a href="#一、Callback-回调机制" class="headerlink" title="一、Callback(回调机制)"></a>一、Callback(回调机制)</h3><p>JavaScript是异步执行的，看以下例子</p><ul><li>例一，</li></ul><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">first</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">second</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-title function_">first</span>();<br><span class="hljs-title function_">second</span>();<br>输出结果为:<span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><ul><li>例二</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">first</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    &#125;,<span class="hljs-number">500</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">second</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-title function_">first</span>();<br><span class="hljs-title function_">second</span>();<br>输出结果为:<span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>解释：JavaScript是异步的，所有延迟处理会被放到循环队列里</p><p><strong>简单的定义：</strong>回调就是一个在另外一个函数执行完后要执行的函数</p><p><strong>定义方式：</strong>在函数定义时，加入一个callback参数</p><p><strong>调用方式：</strong>调用函数时，直接在callback参数位置定义回调执行的函数体（例一）；在callback参数位置传入另外一个函数名作为回调函数执行（例二）</p><p>见下面例子：</p><ul><li>例一</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doHomework</span>(<span class="hljs-params">subject,callback</span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;do $&#123;subject&#125; homework&#x27;</span>);<br>&#125;;<br><br><span class="hljs-title function_">doHomework</span>(<span class="hljs-string">&#x27;math&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finish math homework&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>例二</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doHomework</span>(<span class="hljs-params">subject,callback</span>)&#123;<br>conse.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;do $&#123;subject&#125; homework&#x27;</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">finishHomework</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finish homework&#x27;</span>);<br>&#125;;<br><br><span class="hljs-title function_">doHomework</span>(<span class="hljs-string">&#x27;math&#x27;</span>,finishHomework);<br></code></pre></td></tr></table></figure><h3 id="二、Async"><a href="#二、Async" class="headerlink" title="二、Async"></a>二、Async</h3><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><p>作为一个关键字放到函数前面，用于表示函数是一个异步函数，异步函数也就意味着该函数的执行不会阻塞后面代码的执行。</p><p>实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">timeout</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;)<br>&#125;<br><span class="hljs-title function_">timeout</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello2&#x27;</span>)<br>输出结果：<br>hello2<br>hello<br></code></pre></td></tr></table></figure><p>async 函数返回的是一个promise 对象，如果要获取到promise 返回值，我们应该用then 方法</p><h4 id="await关键字"><a href="#await关键字" class="headerlink" title="await关键字"></a>await关键字</h4><p><strong>await 关键字只能放到async 函数里面</strong></p><p>await后面可以放任何表达式，更多的是放一个返回promise 对象的表达式，使用await关键字之后，表示等待异步函数执行完成之后，才继续执行后面的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doubleAfter2seconds</span>(<span class="hljs-params">num</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-title function_">resovle</span>(<span class="hljs-number">2</span> * num)<br>        &#125;,<span class="hljs-number">2000</span>);<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testResult</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> result1= <span class="hljs-keyword">await</span> <span class="hljs-title function_">doubleAfter2seconds</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">let</span> result2= <span class="hljs-keyword">await</span> <span class="hljs-title function_">doubleAfter2seconds</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1+result2);<br>&#125;<br><span class="hljs-title function_">testResult</span>();<br><span class="hljs-number">4</span>秒后，输出结果:<br><span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><p><strong>捕获错误，使用try-catch的方式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testResult</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-keyword">let</span> result1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">doubleAfter2seconds</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">let</span> result2= <span class="hljs-keyword">await</span> <span class="hljs-title function_">doubleAfter2seconds</span>(<span class="hljs-number">20</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1+result2);<br>&#125;<span class="hljs-keyword">catch</span>(err)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解决“回调地狱”问题"><a href="#解决“回调地狱”问题" class="headerlink" title="解决“回调地狱”问题"></a>解决“回调地狱”问题</h4><p>Async.js可将一系列函数粘连起来，既可以是串行，也可以是并行。</p><p>使用之前需要先安装async包，</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install <span class="hljs-keyword">async</span> —-save<br></code></pre></td></tr></table></figure><p>场景实例：先后读取两个文本数据，按顺序展示文本</p><ul><li>使用callback回调的方式，嵌套读取</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs  = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.<span class="hljs-title function_">readFile</span>(<br>    <span class="hljs-string">&#x27;a-text-file.txt&#x27;</span>,      <span class="hljs-comment">//读取第一个文本</span><br>    <span class="hljs-string">&#x27;utf8&#x27;</span>,                <br>    <span class="hljs-keyword">function</span>(<span class="hljs-params">err,text</span>) &#123;    <span class="hljs-comment">//读取完成，回调</span><br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);           <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;First text file:&#x27;</span>,text);    <span class="hljs-comment">//显示第一段文本</span><br>            fs.<span class="hljs-title function_">readFile</span>(<br>                <span class="hljs-string">&#x27;another-text-file.txt&#x27;</span>,  <span class="hljs-comment">//读取第二个文本</span><br>                <span class="hljs-string">&#x27;utf8&#x27;</span>,                   <br>                <span class="hljs-keyword">function</span>(<span class="hljs-params">err,text</span>) &#123;      <span class="hljs-comment">//读取完成，回调</span><br>                    <span class="hljs-keyword">if</span> (err) &#123;<br>                        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);                      <br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Second text file:&#x27;</span>,text);    <span class="hljs-comment">//显示第二段文本</span><br>                    &#125;<br>                &#125;<br>            );<br>        &#125;<br>    &#125;<br>); <br></code></pre></td></tr></table></figure><p>缺点：嵌套使得可读性、可维护性变差，串行加载，时间效率低</p><ul><li>使用async的方式（简洁、高效）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs  = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">var</span> <span class="hljs-keyword">async</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;async&#x27;</span>);<br><br><span class="hljs-keyword">async</span>.<span class="hljs-title function_">series</span>([<br><br><span class="hljs-keyword">function</span>(<span class="hljs-params">cb</span>)&#123;<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;a-text-file.txt&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,cb);<br>&#125;,<br><br><span class="hljs-keyword">function</span>(<span class="hljs-params">cb</span>)&#123;<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;another-text-file.txt&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,cb);<br>&#125;<br><br>],<span class="hljs-keyword">function</span>(<span class="hljs-params">err,value</span>)&#123;<br><span class="hljs-keyword">if</span>(err) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;File 1:&#x27;</span>,values[<span class="hljs-number">0</span>]);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;File 2:&#x27;</span>,values[<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p> async.series取一个函数数组作为参数，并串行执行它们；</p><p>每个函数只能有一个参数，即回调（cb）。cb执行时应该与其他任意回调一样具有相同类型的参数，所以我们将其传入为fs.readFile的参数；</p><p>最后，它们的结果被发送到最后的回调，即async.series的第二个参数。 这些结果被存在一个数组中，它们按async.series第一个参数中的函数的顺序而排列。</p><p>通过async.js，错误处理被简化了，因为如果遇到一个错误，它会返回错误到最后一个回调中，并且不在执行任何其他异步函数。</p><h3 id="三、条件判断"><a href="#三、条件判断" class="headerlink" title="三、条件判断"></a>三、条件判断</h3><p><strong>判等</strong></p><img src="前端开发——JavaScript.assets/image-20220326212616410.png" alt="image-20220326212616410" style="zoom:50%;" /><p><strong>判断空数组</strong></p><p>通过array.length 判断，如果array.length&#x3D;&#x3D;&#x3D;0 ，数组为空</p><p><strong>判断空集合</strong></p><p>通过keys的长度判断，如果Object.keys(obj).length&#x3D;&#x3D;&#x3D;0，集合为空</p><h3 id="四、数组"><a href="#四、数组" class="headerlink" title="四、数组"></a>四、数组</h3><p><strong>插入</strong></p><p>头插入：<code>数组.unshift(元素)</code></p><p>尾插入：<code>数组.push(元素)</code></p><h3 id="五、script设置点击事件"><a href="#五、script设置点击事件" class="headerlink" title="五、script设置点击事件"></a>五、script设置点击事件</h3><p><strong>方式一：通过addEventListener方法添加</strong></p><ul><li>参数一：执行的事件</li><li>参数二：事件发生后的回调方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">666</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>或者把函数体写在外面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">666</span>);<br>&#125;<br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>,test);<br></code></pre></td></tr></table></figure><p><strong>方式二：通过元素属性添加</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">btn.onclick = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">666</span>);&#125;<br>或者<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">666</span>);<br>&#125;<br>btn.onclick = test;<br></code></pre></td></tr></table></figure><h3 id="六、script获取控件元素"><a href="#六、script获取控件元素" class="headerlink" title="六、script获取控件元素"></a>六、script获取控件元素</h3><p><strong>方式一：通过document.getElementById(“id”)获取</strong></p><p><strong>方式二：通过css选择器，document.querySelector(#id)获取</strong></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记——bootstrap框架</title>
    <link href="/2022/04/02/%E5%89%8D%E7%AB%AF/%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94bootstrap%E6%A1%86%E6%9E%B6/"/>
    <url>/2022/04/02/%E5%89%8D%E7%AB%AF/%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94bootstrap%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>bootstrap框架一些常用元素的笔记</p><span id="more"></span><h3 id="一、布局"><a href="#一、布局" class="headerlink" title="一、布局"></a>一、布局</h3><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220321223711524.png" alt="image-20220321223711524"></p><h4 id="列布局"><a href="#列布局" class="headerlink" title="列布局"></a>列布局</h4><p>相当于flex布局</p><table><thead><tr><th>属性</th><th>css</th><th>bootstrap</th></tr></thead><tbody><tr><td>主轴对齐方式</td><td>justify-content: space-between</td><td><br />justify-content-center</td></tr><tr><td>交叉轴对齐方式</td><td>align-items: flex-start</td><td>align-items-start</td></tr><tr><td>子元素交叉轴对齐</td><td>align-self: start</td><td>align-self-start</td></tr></tbody></table><h4 id="间隙"><a href="#间隙" class="headerlink" title="间隙"></a>间隙</h4><table><thead><tr><th>属性</th><th>css</th><th>bootstrap</th></tr></thead><tbody><tr><td>内边距</td><td>padding&#x3D;**</td><td>p-5（水平+垂直）  px-5（水平内边距）  py-5（垂直内边距）</td></tr><tr><td>外边距</td><td>margin &#x3D; **</td><td>g-5（水平+垂直）  gx-5（水平外边距）  gy-5（垂直外边距）</td></tr></tbody></table><p>建议在父级容器中添加 overflow-hidden 的类属性</p><h4 id="边界border"><a href="#边界border" class="headerlink" title="边界border"></a>边界border</h4><p>通过添加 border类名 为容器添加边界</p><h3 id="二、文本"><a href="#二、文本" class="headerlink" title="二、文本"></a>二、文本</h3><h4 id="文本对齐"><a href="#文本对齐" class="headerlink" title="文本对齐"></a>文本对齐</h4><table><thead><tr><th>.text-center</th><th>居中</th></tr></thead><tbody><tr><td>.text-start</td><td>居左</td></tr><tr><td>.text-end</td><td>居右</td></tr><tr><td>.text-sm-center</td><td>响应式的对齐方式</td></tr></tbody></table><h4 id="自动换行"><a href="#自动换行" class="headerlink" title="自动换行"></a>自动换行</h4><table><thead><tr><th>.text-wrap</th><th>自动换行</th></tr></thead><tbody><tr><td>.text-nowrap</td><td>不换行</td></tr><tr><td>.text-break</td><td>文本断行（防止长单词溢出）</td></tr></tbody></table><h4 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h4><table><thead><tr><th>.text-lowercase</th><th>全部转为小写</th></tr></thead><tbody><tr><td>.text-uppercase</td><td>全部转为大写</td></tr></tbody></table><h4 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h4><p>.fs-1  .fs-2 …</p><h4 id="字体粗细和斜体"><a href="#字体粗细和斜体" class="headerlink" title="字体粗细和斜体"></a>字体粗细和斜体</h4><p>font-weight通用类别的缩写为.fw-* </p><p>font-style通用类别的缩写为.fst-*</p><table><thead><tr><th>fw-bold</th><th>加粗</th></tr></thead><tbody><tr><td>fw-bolder</td><td>再加粗</td></tr><tr><td>fw-light</td><td>浅色</td></tr><tr><td>fw-lighter</td><td>再浅色</td></tr><tr><td>fst-italic</td><td>斜体</td></tr></tbody></table><h4 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h4><p>使用.lh-*通用类别来改变行高</p><table><thead><tr><th>lh-base</th><th>1.5倍行高</th></tr></thead><tbody><tr><td>lh-lg</td><td>2倍行高</td></tr></tbody></table><h4 id="旁注小文本"><a href="#旁注小文本" class="headerlink" title="旁注小文本"></a>旁注小文本</h4><p>内联文本元素</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">figure</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;blockquote&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A well-known quote, contained in a blockquote element.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">figcaption</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;blockquote-footer&quot;</span>&gt;</span><br>Someone famous in <span class="hljs-tag">&lt;<span class="hljs-name">cite</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Source Title&quot;</span>&gt;</span>Source Title<span class="hljs-tag">&lt;/<span class="hljs-name">cite</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">figcaption</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220328181502807.png" alt="image-20220322150011313"></p><h3 id="三、列表"><a href="#三、列表" class="headerlink" title="三、列表"></a>三、列表</h3><h4 id="无样式"><a href="#无样式" class="headerlink" title="无样式"></a>无样式</h4><p>*注意：只对直接子元素生效</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-unstyled&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="内联子元素"><a href="#内联子元素" class="headerlink" title="内联子元素"></a>内联子元素</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-inline-item&quot;</span>&gt;</span>This is a list item.<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="dl-amp-dt-amp-dd"><a href="#dl-amp-dt-amp-dd" class="headerlink" title="dl &amp; dt &amp; dd"></a>dl &amp; dt &amp; dd</h4><p>描述型列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-3&quot;</span>&gt;</span>Description lists<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dd</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-9&quot;</span>&gt;</span>A description list is perfect for defining terms.<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-3&quot;</span>&gt;</span>Term<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dd</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-9&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Definition for the term.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And some more placeholder definition text.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-3&quot;</span>&gt;</span>Another term<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dd</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-9&quot;</span>&gt;</span>This definition is short, so no extra paragraphs or anything.<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-3 text-truncate&quot;</span>&gt;</span>Truncated term is truncated<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dd</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-9&quot;</span>&gt;</span>This can be useful when space is tight. Adds an ellipsis at the end.<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-3&quot;</span>&gt;</span>Nesting<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dd</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-9&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dl</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-4&quot;</span>&gt;</span>Nested definition list<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dd</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-sm-8&quot;</span>&gt;</span>I heard you like definition lists. Let me put a definition list inside your definition list.<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220322150011313.png" alt="image-20220322150543976"></p><h3 id="四、图片"><a href="#四、图片" class="headerlink" title="四、图片"></a>四、图片</h3><h4 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h4><p>通过 Bootstrap 所提供的<code>.img-fluid</code> 类让图片支持响应式布局。其原理是将<code>max-width: 100%;</code> 和 <code>height: auto;</code> 赋予图片，以便随父元素一起缩放。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-fluid&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="缩略图"><a href="#缩略图" class="headerlink" title="缩略图"></a>缩略图</h4><p>200 x 200 尺寸，带有1px宽度的圆形边框</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-thumbnail&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h4><p>.rounded 是一个200 x 200的 img元素</p><ul><li>靠左&#x2F;靠右对齐</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rounded float-start&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rounded float-end&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>居中对齐</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">方式一：<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rounded mx-auto d-block&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>方式二：<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-center&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rounded&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="五、轮廓-Figures"><a href="#五、轮廓-Figures" class="headerlink" title="五、轮廓 Figures"></a>五、轮廓 Figures</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">figure</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;figure&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;figure-img img-fluid rounded&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">figcaption</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;figure-caption text-end&quot;</span>&gt;</span>A caption for the above image.<span class="hljs-tag">&lt;/<span class="hljs-name">figcaption</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220322150543976.png" alt="image-20220322152325398"></p><h3 id="六、表单"><a href="#六、表单" class="headerlink" title="六、表单"></a>六、表单</h3><p><strong>禁用控件：</strong>在属性中添加disabled</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;disabledInput&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Disabled input here...&quot;</span> <span class="hljs-attr">disabled</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>只读文本：</strong>在属性中添加readonly</p><h3 id="七、颜色"><a href="#七、颜色" class="headerlink" title="七、颜色"></a>七、颜色</h3><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220322152325398.png" alt="image-20220328181502807" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bootstrap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习笔记</title>
    <link href="/2022/04/02/Git/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/02/Git/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>学习使用Git过程的一些笔记，方便日常使用查询</p><span id="more"></span><h2 id="Git学习笔记"><a href="#Git学习笔记" class="headerlink" title="Git学习笔记"></a>Git学习笔记</h2><h3 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h3><ol><li><p>初始化仓库</p><figure class="highlight csharp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure></li><li><p>把文件添加到暂存区</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">git <span class="hljs-built_in">add</span> <span class="hljs-built_in">file</span>.txt<br></code></pre></td></tr></table></figure></li><li><p>把暂存区的所有文件提交到仓库的当前分支</p><p>一次可以commit多个add的文件，创建仓库时，默认创建一个master分支</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;提交时的描述&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>查看仓库当前状态</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git status</span><br></code></pre></td></tr></table></figure></li><li><p>查看修改内容</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git diff <span class="hljs-built_in">file</span>.txt<br>可以查看 <span class="hljs-built_in">file</span>.txt 与上次提交相比，更改了哪些内容<br></code></pre></td></tr></table></figure></li></ol><h3 id="二、全局配置"><a href="#二、全局配置" class="headerlink" title="二、全局配置"></a>二、全局配置</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;Your Name&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;email@example.com&quot;</span><br></code></pre></td></tr></table></figure><h3 id="三、版本回退"><a href="#三、版本回退" class="headerlink" title="三、版本回退"></a>三、版本回退</h3><ol><li><p>查看历史提交记录</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git <span class="hljs-built_in">log</span> [<span class="hljs-comment">--pretty=oneline]</span><br></code></pre></td></tr></table></figure><p>显示从最近到最远的提交日志，添加参数可以精简打印的内容</p></li><li><p>版本回退</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^</span><br></code></pre></td></tr></table></figure><p>HEAD^ 表示上一个版本，</p><p>也可以通过commit id来更改版本，下面介绍</p></li><li><p>查找commit id ，等同于查阅历史命令</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">git <span class="hljs-built_in">ref</span>log<br></code></pre></td></tr></table></figure><p>将输出类似于下面的东西</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">e475afc HEAD@&#123;<span class="hljs-number">1</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> HEAD^<br><span class="hljs-number">1094</span>adb (HEAD -&gt; master) HEAD@&#123;<span class="hljs-number">2</span>&#125;: <span class="hljs-keyword">commit</span>: append GPL<br>e475afc HEAD@&#123;<span class="hljs-number">3</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">add</span> distributed<br></code></pre></td></tr></table></figure><p>每行第一个就是commit id</p><p>可以通过下面的命令，<strong>更改到指定版本</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard 1094a</span><br></code></pre></td></tr></table></figure><p>*注：1094a为版本号的前几位</p></li></ol><h3 id="四、撤销修改"><a href="#四、撤销修改" class="headerlink" title="四、撤销修改"></a>四、撤销修改</h3><ul><li><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git checkout <span class="hljs-comment">-- file</span><br></code></pre></td></tr></table></figure><p>两种情况：</p><ul><li><p>文件修改后，没有<code>git add file</code>到暂存区：</p><p>那么将恢复到上一次commit的状态</p></li><li><p>文件<code>git add file</code>添加到暂存区之后：</p><p>不管有没有做修改，都将恢复到添加到暂存区时的状态</p></li></ul></li><li><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，把暂存区的修改也丢掉</p><p>第一步：把暂存区的修改退回工作区</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">git <span class="hljs-keyword">reset</span> HEAD <span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><p>第二步：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git checkout <span class="hljs-comment">-- file</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="五、删除文件"><a href="#五、删除文件" class="headerlink" title="五、删除文件"></a>五、删除文件</h3><ul><li><p>删除本地和版本库两个地方的文件</p><p>本地使用本地的删除方法，</p><p>这里介绍git的删除方法：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">git <span class="hljs-keyword">rm</span> <span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><p>删除后需要commit才能生效</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;remove file&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>误删本地文件，从版本库恢复</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git checkout <span class="hljs-comment">-- file</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="六、分支管理"><a href="#六、分支管理" class="headerlink" title="六、分支管理"></a>六、分支管理</h3><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>创建一个名为dev的分支</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch dev</span><br></code></pre></td></tr></table></figure><p>创建的新分支，建立在当前分支的基础上</p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220323103134658.png" alt="image-20220323103134658" style="zoom:50%;" /><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><p>从当前分支切换到dev分支</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">git <span class="hljs-keyword">switch</span> dev<br></code></pre></td></tr></table></figure><p>创建并切换分支</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">git <span class="hljs-keyword">switch</span> -<span class="hljs-keyword">c</span> dev<br></code></pre></td></tr></table></figure><h4 id="查看当前分支"><a href="#查看当前分支" class="headerlink" title="查看当前分支"></a>查看当前分支</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span><br></code></pre></td></tr></table></figure><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><p>将指定分支合并到当前分支，例如：当前分支为master，下面命令将dev分支合并到master分支上</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">git <span class="hljs-keyword">merge</span> dev  这种方式删除分支后，会丢掉分支信息<br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">git <span class="hljs-built_in">merge</span> <span class="hljs-comment">--no-ff dev   这种方式从分支历史上就可以看出分支信息</span><br></code></pre></td></tr></table></figure><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><p>删除dev分支</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch -d dev</span><br></code></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">git</span> <span class="hljs-variable">branch</span> <span class="hljs-operator">-</span><span class="hljs-built_in">D</span> <span class="hljs-variable">dev</span>  强行删除一个没有被合并过的新分支<br></code></pre></td></tr></table></figure><h4 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h4><ul><li>分工合作策略</li></ul><table><thead><tr><th>master</th><th>稳定版本的分支</th></tr></thead><tbody><tr><td>dev</td><td>实际工作过程中使用的主分支，dev完成阶段任务时，才把dev分支合并到master上</td></tr><tr><td>user1</td><td>工作分支一，在dev分支的基础上创建，完成任务后，合并到dev分支</td></tr><tr><td>user2</td><td>工作分支二</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220323104839946-16488933038285.png" alt="image-20220323104839946"></p><ul><li>依赖分支实现的版本管理策略（串行策略）</li></ul><table><thead><tr><th>master</th><th>最新分支</th></tr></thead><tbody><tr><td>dev1</td><td>工作阶段一分支，完成后在此分支上创建dev2，合并dev1到master，切换都dev2继续工作</td></tr><tr><td>dev2</td><td>工作阶段二分支，同上</td></tr><tr><td>…</td><td></td></tr><tr><td>dev9</td><td>最后一个工作阶段，完成后，合并dev9到master，不必再创建新分支</td></tr></tbody></table><p>这样就实现了一个分支一个版本</p><h3 id="七、远程仓库"><a href="#七、远程仓库" class="headerlink" title="七、远程仓库"></a>七、远程仓库</h3><p><strong>由于本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要设置SSH Key</strong></p><p><strong>创建SSH Key</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥</p><p><strong>登陆GitHub，打开“Account settings”，“SSH Keys”页面</strong></p><p><strong>点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容</strong></p><p><strong>点“Add Key”</strong></p><p><strong>查看远程仓库信息</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git remote -v</span><br></code></pre></td></tr></table></figure><p><strong>推送分支</strong></p><p>推送时，要指定本地分支（如：master），git会把该分支推送到远程库的对应分支上</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><p>如果是在远程仓库新建分支，可以加上-u参数，这样可以把本地分支和远程分支关联起来，下次push就可以省略远程分支名</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><p><strong>抓取分支</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">克隆链接</span><br></code></pre></td></tr></table></figure><p>默认只能抓取master分支</p><p><strong>多人协作</strong></p><p>抓取了master分支后，在本地创建dev分支，在dev分支修改；</p><p>创建本地dev分支与远程&#x2F;origin&#x2F;dev分支点链接</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">git branch --<span class="hljs-built_in">set</span>-upstream-to=origin/<span class="hljs-built_in">dev</span> <span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>要推送到远程库时，先git pull 把最新的提交从origin&#x2F;dev抓取下来，在本地合并（git pull自动完成）</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git pull</span><br></code></pre></td></tr></table></figure><p>解决冲突（如果有需要的话）</p><p>最后<code>git push</code></p><h3 id="八、标签tag"><a href="#八、标签tag" class="headerlink" title="八、标签tag"></a>八、标签tag</h3><p>标签是版本库的一个快照，是指向某个commit的指针</p><h4 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h4><p><strong>在当前分支当前commit打上标签v1.0</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>对指定的commit打标签</strong></p><p>v1.0是标签，  f52c633是commit id，可以通过git log查找</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.<span class="hljs-number">0</span> f52c633<br></code></pre></td></tr></table></figure><p>创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> v1.<span class="hljs-number">0</span> -m <span class="hljs-string">&quot;version 1.0 released&quot;</span> <span class="hljs-number">1094</span>adb<br></code></pre></td></tr></table></figure><h4 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h4><p><strong>查看所有标签</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title"></span><br></code></pre></td></tr></table></figure><p><strong>查看指定标签信息</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">show </span><span class="hljs-built_in">v1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> v1.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="推送标签"><a href="#推送标签" class="headerlink" title="推送标签"></a>推送标签</h4><p>将本地标签推送到远程库</p><p><strong>推送指定标签</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> origin <span class="hljs-built_in">v1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>推送所有未推送的标签</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --tags<br></code></pre></td></tr></table></figure><p><strong>删除远程标签</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">git push origin <span class="hljs-symbol">:refs/tags/v1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="九、-gitignore"><a href="#九、-gitignore" class="headerlink" title="九、.gitignore"></a>九、.gitignore</h3><p>在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件</p><p>例如：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs clean"># Windows:<br>Thumbs.db<br>ehthumbs.db<br>Desktop.ini<br><br># My configurations:<br>db.ini<br>deploy_key_rsa<br><br># 排除所有.开头的隐藏文件:<br>.*<br># 排除所有.<span class="hljs-keyword">class</span>文件:<br>*.<span class="hljs-keyword">class</span><br><br># 不排除.gitignore和App.<span class="hljs-keyword">class</span>:<br>!.gitignore<br>!App.<span class="hljs-keyword">class</span><br></code></pre></td></tr></table></figure><h3 id="十、查看提交历史"><a href="#十、查看提交历史" class="headerlink" title="十、查看提交历史"></a>十、查看提交历史</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">git</span> <span class="hljs-comment">log</span> --<span class="hljs-comment">graph</span> --<span class="hljs-comment">pretty=oneline</span> --<span class="hljs-comment">abbrev</span><span class="hljs-literal">-</span><span class="hljs-comment">commit</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构——栈</title>
    <link href="/2022/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/"/>
    <url>/2022/04/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>STL 栈的常用函数、算法题</p><span id="more"></span><h1 id="C-Stack（栈）"><a href="#C-Stack（栈）" class="headerlink" title="C++ Stack（栈）"></a>C++ Stack（栈）</h1><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><table><thead><tr><th><a href="https://www.cainiaojc.com/cpp/cpp-stack-empty-function.html">empty</a></th><th>该函数用于测试堆栈是否为空。如果堆栈为空，则该函数返回true，否则返回false。</th></tr></thead><tbody><tr><td><a href="https://www.cainiaojc.com/cpp/cpp-stack-size-function.html">size</a></td><td>该函数返回堆栈容器的大小，该大小是堆栈中存储的元素数量的度量。</td></tr><tr><td><a href="https://www.cainiaojc.com/cpp/cpp-stack-top-function.html">top</a></td><td>该函数用于访问堆栈的顶部元素。该元素起着非常重要的作用，因为所有插入和删除操作都是在顶部元素上执行的。</td></tr><tr><td><a href="https://www.cainiaojc.com/cpp/cpp-stack-push-function.html">push</a></td><td>该函数用于在堆栈顶部插入新元素。</td></tr><tr><td><a href="https://www.cainiaojc.com/cpp/cpp-stack-pop-function.html">pop</a></td><td>该函数用于删除元素，堆栈中的元素从顶部删除。</td></tr><tr><td>swap</td><td>该函数用于交换引用的两个容器的内容。</td></tr></tbody></table><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p>Q1：栈空的时候，使用top访问，或者使用pop会发生什么？</p><p>A1：栈空的时候，使用top和使用pop都会发生访问错误，程序会报错终止。</p><h4 id="leetcode题库"><a href="#leetcode题库" class="headerlink" title="leetcode题库"></a>leetcode题库</h4><table><thead><tr><th>题目</th><th>备注</th></tr></thead><tbody><tr><td>20.有效的括号（简单）</td><td>简单的匹配前后括号(),{},[]</td></tr><tr><td>32.最长的括号（困难）</td><td>计算最长有效括号，分两种情况：()()和(())，巧妙地利用栈和右括号下标</td></tr><tr><td>42.接雨水（困难）</td><td>做了两次，第二次还做了两个小时，把问题想复杂化了，虽然细节很多，但是也没有那么多，没有把握住分析思路。</td></tr><tr><td>71.简化路径（中等）</td><td>标准化输入路径的题目，借鉴编译原理gettoken函数，难点在于需要考虑的情况和细节比较多</td></tr><tr><td>84.柱状图中最大的矩形（困难）</td><td>单调栈+哨兵（边界加一个特殊值，称为“哨兵”），单调栈常用来求左右边界的问题，分为递增、递减栈，具体选哪个取决于详细情况</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发——CSS</title>
    <link href="/2022/04/02/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94CSS/"/>
    <url>/2022/04/02/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94CSS/</url>
    
    <content type="html"><![CDATA[<p>CSS，级联样式表</p><span id="more"></span><h2 id="CSS-（Cascading-Style-Sheets-，级联样式表）"><a href="#CSS-（Cascading-Style-Sheets-，级联样式表）" class="headerlink" title="CSS  （Cascading Style Sheets ，级联样式表）"></a>CSS  （Cascading Style Sheets ，级联样式表）</h2><h3 id="一、选择器概述"><a href="#一、选择器概述" class="headerlink" title="一、选择器概述"></a>一、选择器概述</h3><p><strong>选择符号</strong></p><ul><li><p><strong>包含选择符</strong>，单纯地在两个选择器之间加一个空格，如下</p><figure class="highlight css"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">em</span> &#123;<br>  <span class="hljs-attribute">color</span>: rebeccapurple;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在两个选择器之间加了逗号分割，表示选择了多个元素</p></li><li><p><strong>相邻选择符 +</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> + <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">200%</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>直接子级选择符 &gt;</strong></p></li></ul><br><p><strong>选择器列表</strong></p><p>通过逗号，将几个将应用同样样式的选择器合并在一起。</p><br><p><strong>元素、类名、ID选择器</strong></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">h1</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-punctuation">&#125;</span><br>.<span class="hljs-title class_">box</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-meta">#unique &#123; &#125;</span><br></code></pre></td></tr></table></figure><br><p><strong>标签属性选择器</strong></p><p>根据标签属性来选择元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[title]</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>根据特定值的标签属性选择</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href=<span class="hljs-string">&quot;https://example.com&quot;</span>]</span> &#123; &#125;<br></code></pre></td></tr></table></figure><br><p><strong>伪类、伪元素</strong></p><p>通过伪类来样式化元素的特定状态</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123; &#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span><span class="hljs-selector-tag">-child</span> &#123; &#125;<br></code></pre></td></tr></table></figure><p>通过伪元素选择元素的一部分，而不是元素全部</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123; &#125;<br></code></pre></td></tr></table></figure><br><p><strong>如何在HTML中添加css</strong></p><p><strong>方式一</strong>，在head头部中，用style标签包裹css代码</p><p><strong>方式二</strong>，在head头部中，用link标签引入外部css文件，<code>&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;</code></p><br><br><h3 id="二、构建CSS"><a href="#二、构建CSS" class="headerlink" title="二、构建CSS"></a>二、构建CSS</h3><p><strong>函数</strong></p><p>如<code>width: calc(90% - 30px)</code></p><p>还可以定义一些变量 ，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">定义：<span class="hljs-attr">--banner-height</span>:<span class="hljs-number">100vh</span>;<br>使用：<span class="hljs-selector-tag">var</span>(<span class="hljs-attr">--banner-height</span>)<br></code></pre></td></tr></table></figure><br><p><strong>媒体查询</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">body &#123;<br>  background-color: pink;<br>&#125;<br><br>@media (min-width: 30em) &#123;<br>  body &#123;<br>    background-color: blue;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p><strong>速记属性，如font、background、margin、border等</strong></p><p><strong>注释：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*css的注释*/</span><br></code></pre></td></tr></table></figure><h3 id="三、CSS工作原理"><a href="#三、CSS工作原理" class="headerlink" title="三、CSS工作原理"></a>三、CSS工作原理</h3><p><strong>浏览器加载网页流程</strong></p><ol><li>浏览器载入HTML文件</li><li>Parse（解析）HTML文件，转化成DOM（Doucument Object Model）</li><li>载入相关资源，图片、视频、样式</li><li>解析CSS，根据选择器的不同分到不同的“桶”中，将不同的规则应用到对应的DOM节点中</li><li>渲染DOM，展示</li></ol><img src="https://mdn.mozillademos.org/files/11781/rendering.svg" style="zoom: 25%;" /><h3 id="四、层叠与继承"><a href="#四、层叠与继承" class="headerlink" title="四、层叠与继承"></a>四、层叠与继承</h3><p><strong>继承</strong></p><p>哪些属性属于默认继承很大程度上是由常识决定的</p><p>三个通用的属性值</p><ul><li><strong>inherit</strong>，子元素属性上声明，表示与父元素相同</li><li><strong>initial</strong>，与浏览器默认样式相同，如果浏览器没有该属性，且该属性是自然继承的，那么会设置为inherit</li><li><strong>unset</strong>，重置为自然值，如果是自然继承的，就是inferit，否则就是initial。可以在样式表中声明<code>all:unset</code>，将重置所有属性</li></ul><br><p><strong>层叠</strong></p><p>考虑层叠从三个方面出发，根据重要性依次为：<strong>重要程度</strong>、<strong>优先级</strong>、<strong>资源顺序</strong></p><ul><li><p><strong>资源顺序</strong></p><p>后面的规则覆盖前面的规则</p></li><li><p><strong>优先级</strong></p><p>html中的style属性  &gt;  ID选择器  &gt;  类选择器、属性选择器、伪类  &gt;  元素、伪元素选择器</p><p>【千位】                        【百位】            【十位】                                        【个位】</p><p><strong>!important</strong>，可以覆盖所有优先级，它会使调试 CSS 问题非常困难，谨慎使用！使用方式：<code>border: none !important;</code></p></li></ul><h3 id="五、选择器"><a href="#五、选择器" class="headerlink" title="五、选择器"></a>五、选择器</h3><h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><ol><li><p><strong>类型选择器</strong>，又叫标签选择器、元素选择器</p></li><li><p><strong>全局选择器</strong>，由一个*号代指，选中了文档中所有内容</p><p>有时会使用全局选择器来使选择器更易读，比如<code>article :first-child</code>和<code>article *:first-child</code>都表示article元素的第一个子元素，但是前者容易和<code>article:first-child</code>混淆，后者表示作为第一个子元素的artcle标签</p></li><li><p><strong>类选择器</strong>，以.号开头。同时也有另外一种方式缩小范围，如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.brimary</span>&#123;&#125;<br><span class="hljs-selector-tag">h1</span><span class="hljs-selector-class">.highlight</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>中间没有空格，代表 <strong>指向特定元素的类</strong></p><p>当<strong>几个类不加空格连成一串</strong>时，匹配的是同时具有这些类的元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.notebox</span><span class="hljs-selector-class">.danger</span> &#123;<br>  <span class="hljs-attribute">border-color</span>: red;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>ID选择器</strong>，以#开头</p></li></ol><br><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a><strong>属性选择器</strong></h4><ol><li><p><strong>属性值选择器</strong></p><table><thead><tr><th align="left">示例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>a[title]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素——方括号里的值。</td></tr><tr><td align="left"><code>a[href=&quot;https://example.com&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值正为<em>value</em>——引号中的字符串。</td></tr><tr><td align="left"><code>p[class~=&quot;special&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素 ，其值正为<em>value</em>，或者匹配带有一个<em>attr</em>属性的元素，其值有一个或者更多，至少有一个和<em>value</em>匹配。注意，在一列中的好几个值，是用空格隔开的。</td></tr><tr><td align="left">&#96;div[lang</td><td align="left">&#x3D;”zh”]&#96;</td></tr></tbody></table><p>强调，<code>li[class=&#39;a&#39;]</code>匹配的元素，其class属性里面只能有a，不能有其它类名</p></li><li><p><strong>子字符串选择器</strong></p><table><thead><tr><th align="left">选择器</th><th align="left">示例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>[*attr*^=*value*]</code></td><td align="left"><code>li[class^=&quot;box-&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值开头为<em>value</em>子字符串。</td></tr><tr><td align="left"><code>[*attr*$=*value*]</code></td><td align="left"><code>li[class$=&quot;-box&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值结尾为<em>value</em>子字符串</td></tr><tr><td align="left"><code>[*attr**=*value*]</code></td><td align="left"><code>li[class*=&quot;box&quot;]</code></td><td align="left">匹配带有一个名为<em>attr</em>的属性的元素，其值的字符串中的任何地方，至少出现了一次<em>value</em>子字符串。</td></tr></tbody></table></li><li><p><strong>大小写敏感</strong>，后面加一个<code>i</code>，使大小写不敏感</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">只能匹配以<span class="hljs-selector-tag">a</span>开头的<br><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class^=<span class="hljs-string">&quot;a&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>&#125;<br><br>可以匹配以 <span class="hljs-selector-tag">a</span>或者<span class="hljs-selector-tag">A</span>开头的<br><span class="hljs-selector-tag">li</span><span class="hljs-selector-attr">[class^=<span class="hljs-string">&quot;a&quot;</span> i]</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h4><p><strong>伪类</strong>，是选择器的一种，是开头写着<code>:</code>冒号的关键字，它的作用是帮助减少标记文本中多余的类，让代码更易于维护</p><p>举例：</p><p>简单伪类，<code>:first-child</code>、<code>last-child</code>、<code>:invalid</code>（任意内容未通过验证的 input或其他form元素）</p><p>用户行为伪类，<code>:hover</code>、<code>:hover</code></p><p><strong>伪元素</strong>，以<code>::</code>双冒号开头的关键字，表现出来更像是在HTML上加了新元素，而不是在已有元素上应用样式。</p><p>例如：<code>::first-line</code>将始终选中第一行，不管宽度怎么变化</p><p><strong>::before和::after</strong></p><p>必须添加的属性<code>content</code>，可以用来在元素前后添加文件（但不建议这么做），更多的用法是添加一些图标，屏幕阅读器不会发现它们。也可以将它声明为<code>diaplay:block</code>这样就可以用<code>width</code>和<code>height</code>在它上面应用样式，比如结合绝对布局添加背景图片。</p><h3 id="六、盒模型"><a href="#六、盒模型" class="headerlink" title="六、盒模型"></a>六、盒模型</h3><p><strong>块级盒子（block box）</strong></p><ul><li>在内联方向（通常是横向）上占据父容器的所有宽度</li><li>每个盒子会换行</li><li>width和height可以发挥作用</li><li>内外边距、border会将其它元素推开</li></ul><br><p><strong>内联盒子（inline box）</strong></p><ul><li>不换行</li><li>width和hegiht不起作用</li><li>垂直方向的边距会被应用，但不会把其它inline box推开</li><li>水平方向的边距会把其它inline box推开</li></ul><img src="前端开发——CSS.assets/image-20220407164132124.png" alt="image-20220407164132124" style="zoom:50%;" /><br><p><strong>block和inline是元素的外部显示类型，还有内部显示类型</strong>，内部显示类型决定了元素内部的布局流，例如flex，gird</p><br><p><strong>盒模型</strong>，包含四个元素<code>content box</code>、<code>padding box</code>、 <code>border box</code>、<code>margin box</code></p><p><strong>标准盒模型</strong>的尺寸计算，等于<code>content box</code>+<code>padding box</code>+ <code>border box</code>，margin不算入盒子范围</p><p><strong>替代盒模型</strong>的尺寸为实际盒子尺寸（content加padding加border），实际的content尺寸需要减去padding和border，<strong>声明的方式为：</strong><code>box-sizing: border-box;</code></p><br><p><strong>inline-block</strong>，介于block和inline之间的选项，width和height可以生效，不换行，会推开其它元素。将一些默认的inline元素声明为inline-block是有意义的。</p><img src="前端开发——CSS.assets/image-20220407164335987.png" alt="image-20220407164335987" style="zoom: 25%;" /><h3 id="七、背景与边框"><a href="#七、背景与边框" class="headerlink" title="七、背景与边框"></a>七、背景与边框</h3><p><strong>background</strong>，简写属性，可以一次性声明多个属性值</p><ul><li>background-color，颜色，不会覆盖图像</li><li>background-image</li><li>background-repeat，背景图片的重复方式 <code>no-repeat</code>、<code>repeat-x</code>、<code>repeat-y</code>、<code>repeat</code></li><li>background-size，图像大小，<code>cover</code>等比例缩放填充整个容器，<code>contain</code>图像大小适应容器（可能出现间隙）</li><li>background-position，两个值（也可以4个值），空格隔开，分别表示x轴y轴，可以用<code>长度值</code>、<code>百分比</code>、<code>关键字</code>，如<code>top</code>、<code>center</code></li></ul><p><strong>多个背景图像</strong>，background-image可以有多个url，前面的url将显示在顶部。对应的，其余属性也可以有多组，如果组数不够，将循环使用</p><p><strong>边框，border</strong>，简写属性</p><ul><li>border-width</li><li>border-style，<code>solid</code>、<code>double</code>、<code>dotted</code>、</li><li>border-color</li><li>border-radius，1个值或4个值</li></ul><h3 id="八、竖向文本（块）"><a href="#八、竖向文本（块）" class="headerlink" title="八、竖向文本（块）"></a>八、竖向文本（块）</h3><p><strong>书写模式，writing-mode</strong></p><ul><li><code>horizontal-tb</code>: 块流向从上至下。对应的文本方向是横向的。</li><li><code>vertical-rl</code>: 块流向从右向左。对应的文本方向是纵向的。</li><li><code>vertical-lr</code>: 块流向从左向右。对应的文本方向是纵向的。</li></ul><p><strong>逻辑属性与逻辑值</strong>，当改变文本方向后，width的方向并没有改变（特指纵向），需要通过逻辑值<code>inline-size</code>来映射到width，才能正确控制盒子宽度</p><p>具体可参考：（<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties">Logical Properties and Values</a>）</p><p><strong>块维度：</strong>块的布局流方向</p><p><strong>内联维度：</strong>文本方向</p><h3 id="九、处理溢出"><a href="#九、处理溢出" class="headerlink" title="九、处理溢出"></a>九、处理溢出</h3><p><strong>overflow属性</strong></p><ul><li>visible（默认）</li><li>hidden，隐藏</li><li>scroll，（总是）显示滚动条，包括x轴和y轴两个方向的滚动条，可以通过overflow-x或y来设置单独的滚动条</li><li>auto，文本将溢出时，增加滚动条</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发——HTML</title>
    <link href="/2022/04/02/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94HTML/"/>
    <url>/2022/04/02/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94HTML/</url>
    
    <content type="html"><![CDATA[<p>HyperText Markup Language 不是一门编程语言，而是一种用来告知浏览器如何组织页面的<strong>标记语言</strong></p><span id="more"></span><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>HyperText Markup Language 不是一门编程语言，而是一种用来告知浏览器如何组织页面的<strong>标记语言</strong></p><p><strong>（注：以下所有html标签，都在&lt; 后面增加了一个空格，以避免被编辑器识别为html元素）</strong></p><p><strong>元素（Element）</strong></p><p>标签+内容，组成了元素，HTML就是由一系列元素组成的。<strong>注意：HTML 标签不区分大小写</strong></p><p><strong>属性（Attribute）</strong></p><h3 id="一、剖析元素"><a href="#一、剖析元素" class="headerlink" title="一、剖析元素"></a>一、剖析元素</h3><p><strong>文字样式的元素</strong></p><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt; i&gt;&lt; &#x2F;i&gt;</td><td>斜体，行内元素</td></tr><tr><td>&lt; strong&gt;&lt; &#x2F;strong&gt;</td><td>加粗，表示重要性</td></tr><tr><td>&lt; del&gt;&lt; &#x2F;del&gt;</td><td>删除线</td></tr><tr><td>&lt; u&gt;&lt; &#x2F;u&gt;</td><td>下划线</td></tr></tbody></table><p><strong>文字排版的元素</strong></p><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt; p&gt; &lt; &#x2F;p&gt;</td><td>段落</td></tr><tr><td>&lt; br&gt;</td><td>换行</td></tr><tr><td>&lt; hr&gt;</td><td>水平线</td></tr></tbody></table><p><strong>块级元素 &amp; 内联元素</strong></p><ul><li><p><strong>块级元素</strong>在页面中以块的形式展现，会换行</p></li><li><p><strong>内联元素</strong>出现在<strong>块级元素</strong>里面，不换行</p><p>常见的内联元素：</p><table><thead><tr><th>标签</th><th>描述</th><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt; a&gt;&lt; &#x2F;a&gt;</td><td>超链接</td><td>&lt; br&gt;</td><td>换行符号</td></tr><tr><td>&lt; audio&gt;</td><td>在文档中嵌入音频</td><td>&lt; button&gt;</td><td>按钮</td></tr><tr><td>&lt; canvas&gt;</td><td>被用来通过 JavaScript绘制图形及图形动画</td><td>&lt; code&gt;&lt; &#x2F;code&gt;</td><td>代码块</td></tr><tr><td>&lt; i&gt;&lt; &#x2F;i&gt;</td><td>用于表现因某些原因需要区分普通文本的一系列文本</td><td>&lt; iframe&gt;</td><td><strong>内联框架元素</strong></td></tr><tr><td>……</td><td></td><td></td><td></td></tr></tbody></table></li></ul><h4 id="语义元素"><a href="#语义元素" class="headerlink" title="语义元素"></a><strong>语义元素</strong></h4><p>HTML，有很多标签的原因之一在于，每种标签都有对应的语义，尽管它们在样式上的表现可能相差无几，我想这么做的原因应该是为了方便读取数据，比如爬取数据时，可以通过标签的名字来获取到对应所需要的内容，而且使用对应语义的元素标签也会使得HTML的可读性更强</p><table><thead><tr><th>标签</th><th>含义</th></tr></thead><tbody><tr><td>&lt; footer&gt;</td><td>定义文档或节的页脚。</td></tr><tr><td>&lt; header&gt;</td><td>规定文档或节的页眉。</td></tr><tr><td>&lt; main&gt;</td><td>规定文档的主内容。</td></tr><tr><td>&lt; nav&gt;</td><td>定义导航链接。</td></tr><tr><td>&lt; aside&gt;</td><td>定义页面内容以外的内容。</td></tr><tr><td>&lt; article&gt;</td><td>定义文章。</td></tr><tr><td>&lt; section&gt;</td><td>定义文档中的节。</td></tr><tr><td>&lt; time&gt;</td><td>定义日期&#x2F;时间。</td></tr><tr><td>&lt; figure&gt;</td><td>定义媒介内容的分组，以及它们的标题。</td></tr><tr><td>&lt; figcation&gt;</td><td>定义 figure 元素的标题。</td></tr><tr><td>&lt; mark&gt;</td><td>定义重要的或强调的文本。</td></tr><tr><td>&lt; dialog&gt;</td><td>对话框盒子</td></tr><tr><td>&lt; address&gt;</td><td>地址</td></tr><tr><td>&lt; cite&gt;</td><td>标记著<strong>作者</strong></td></tr><tr><td>&lt; dfn&gt;</td><td>标记术语的定义实例</td></tr><tr><td>&lt; abbr&gt;</td><td>定义缩写</td></tr><tr><td>&lt; blockquote&gt;</td><td>定义长的引用。</td></tr><tr><td>&lt; q&gt;</td><td>定义行内引用</td></tr></tbody></table><p>**[点击](<a href="https://www.w3school.com.cn/tags/html_ref_byfunc.asp">HTML 标签参考手册 - 功能排序 (w3school.com.cn)</a>)**查看更多元素</p><p><strong>空元素</strong></p><p>一个元素只有一个标签，没有结束标签的元素，如&lt; img&gt; ，通常用来插入一些东西</p><h3 id="二、剖析HTML文档"><a href="#二、剖析HTML文档" class="headerlink" title="二、剖析HTML文档"></a>二、剖析HTML文档</h3><p><strong>（以下所有的标签，在&lt; 后面都多加了一个空格，以避免被编辑器识别为html文本，实际使用时需要去掉那个空格）</strong></p><br><p><strong>&lt; !DOCTYPE html&gt;</strong></p><p>是现在是最短有效的文档声明</p><br><p><strong>&lt; html&gt;&lt; &#x2F;html&gt;</strong></p><p>包裹了整个完整的页面，是一个根元素</p><br><p><strong><!-- -->注释</strong></p><br><h4 id="head-元数据"><a href="#head-元数据" class="headerlink" title="head 元数据"></a>head 元数据</h4><p><strong>&lt; head&gt;&lt; &#x2F;head&gt;</strong></p><p>包含了所有你想包含在HTML页面中但不想在HTML页面中显示的内容</p><p>包括你想在搜索结果中出现的关键字和页面描述，CSS样式，字符集声明等等</p><br><p><strong>&lt; title&gt;&lt; &#x2F;title&gt;</strong></p><p> 设置页面标题，出现在浏览器标签上，当你标记&#x2F;收藏页面时它可用来描述页面</p><br><p><strong>&lt; meta charset&#x3D;”utf-8”&gt;</strong></p><p>设置文档使用utf-8字符集编码</p><br><p><strong>meta 添加元数据</strong></p><ul><li><code>name</code> 指定了meta 元素的类型； 说明该元素包含了什么类型的信息。</li><li><code>content</code> 指定了实际的元数据内容</li></ul><p>description也被使用在<strong>搜索引擎显示的结果</strong>页中，如下，content的内容将显示在搜索页面中</p><figure class="highlight routeros"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs routeros">meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;The MDN Web Docs site</span><br><span class="hljs-string">    provides information about Open Web technologies</span><br><span class="hljs-string">    including HTML, CSS, and APIs for both Web sites and</span><br><span class="hljs-string">    progressive web apps.&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>添加自定义图标</strong>，显示在标签页标题左边的小图标，设置方法，在head中添加如下代码，大多数浏览器都可以支持.gif和.png格式了</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;shortcut icon&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;favicon.ico&quot;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;image/x-icon&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>添加CSS</strong>，属性：<code>rel:&quot;stylesheet&quot; href:文件路径</code></p><br><h4 id="body-主体"><a href="#body-主体" class="headerlink" title="body 主体"></a>body 主体</h4><p><strong>&lt; body&gt;&lt; &#x2F;body&gt;</strong></p><p>页面上显示的所有元素，script标签可以添加到body内，<strong>事实上，把script放在文档尾部是一个更好的选择</strong>，这样可以确保先解析html内容之后才加载脚本，避免因为脚本找不到某个元素而出错，<strong>script需要开始和结束标签</strong>，因为它既可以引用外部标签，也可以把脚本写在script元素内</p><h3 id="三、实体引用"><a href="#三、实体引用" class="headerlink" title="三、实体引用"></a>三、实体引用</h3><table><thead><tr><th align="left">原义字符</th><th align="left">等价字符引用</th></tr></thead><tbody><tr><td align="left">&lt;</td><td align="left">&amp;lt ;</td></tr><tr><td align="left">&gt;</td><td align="left">&amp;gt ;</td></tr><tr><td align="left">“</td><td align="left">&amp;quot ;</td></tr><tr><td align="left">‘</td><td align="left">&amp;apos ;</td></tr><tr><td align="left">&amp;</td><td align="left">&amp;amp ;</td></tr><tr><td align="left">空格</td><td align="left">&amp;nbsp ;</td></tr></tbody></table><p><strong>注：等价字符的字符与分号;之间并没有空格，这里为了能够显示出来，多加了空格</strong></p><p>以上仅列出一些常用的引用，更多可参考<a href="http://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references">XML和HTML字符实体引用列表</a></p><h3 id="四、常用元素"><a href="#四、常用元素" class="headerlink" title="四、常用元素"></a>四、常用元素</h3><h4 id="lt-a-gt-链接"><a href="#lt-a-gt-链接" class="headerlink" title="&lt; a&gt; 链接"></a>&lt; a&gt; 链接</h4><table><thead><tr><th>href</th><th>链接地址</th></tr></thead><tbody><tr><td>title</td><td>鼠标悬停时，以工具提示显示的信息</td></tr><tr><td>target</td><td>跳转链接的方式，如”_blank”为打开新标签页</td></tr><tr><td>download</td><td>当链接是下载资源时，使用download属性提供一个默认的保存文件名，仅适用于<strong>同源URL</strong>（host相同）</td></tr></tbody></table><br><h4 id="iframe内联框架"><a href="#iframe内联框架" class="headerlink" title="iframe内联框架"></a>iframe内联框架</h4><p><strong>HTML 内联框架元素 (<code>&lt;iframe&gt;</code>)</strong> 表示嵌套的<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Browsing_context">browsing context</a>。它能够将另一个 HTML 页面嵌入到当前页面中。</p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220401171641215.png" alt="image-20220401171641215"></p><h3 id="五、文字基础"><a href="#五、文字基础" class="headerlink" title="五、文字基础"></a>五、文字基础</h3><p><strong>标题和段落</strong></p><ul><li>您应该最好只对每个页面使用一次&lt; h1&gt; — 这是顶级标题，所有其他标题位于层次结构中的下方</li><li>在可用的六个标题级别中，您应该只在每页使用不超过三个</li></ul><p><strong>语义标签</strong></p><p>我们可以通过css样式让任何一个标签达到我们想要的外形效果，但是在别人阅读这份html时可能很难理解该部分属于哪一个结构。所以使用语义化标签是必要的，也是html存在那么多标签的意义。</p><p>我之前使用类名或id的方式来标注每个标签代表的含义，但是这样仍然不够直观，不能够让人一眼就看出来每个标签所代表的结构内容 </p><p><strong>高级文字排版</strong></p><ol><li><p><strong>引用</strong>，引用会有默认的缩进，<strong>cite属性</strong>可以添加引用的链接，但是要使用JS或者CSS，浏览器才会显示cite的内容</p><p><strong>行内引用 &lt; q&gt;</strong> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 这是引文：<span class="hljs-tag">&lt;<span class="hljs-name">q</span> <span class="hljs-attr">cite</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span> 水调歌头——苏轼 <span class="hljs-tag">&lt;/<span class="hljs-name">q</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这是引文：<q cite=""> 水调歌头——苏轼</q></p><p><strong>块引用 &lt; blockquote cite&#x3D;””&gt;</strong> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段引用：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span> <span class="hljs-attr">cite</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>水调歌头——苏轼<span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这是一段引用：</p><blockquote cite="">水调歌头——苏轼</blockquote></li><li><p><strong>描述列表 &lt; dl&gt;</strong></p><dl>    <dt>小标题一</dt>    <dd>        描述一    </dd>    <dt>小标题二</dt>    <dd>        描述二    </dd></dl></li><li><p><strong>缩略语 &lt; abbr&gt;</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我们使用 <span class="hljs-tag">&lt;<span class="hljs-name">abbr</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;超文本标记语言（Hyper text Markup Language）&quot;</span>&gt;</span>HTML<span class="hljs-tag">&lt;/<span class="hljs-name">abbr</span>&gt;</span> 来组织网页文档。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们使用 <abbr title="超文本标记语言（Hyper text Markup Language）">HTML</abbr> 来组织网页文档。</p></li><li><p>**上标 &lt; sup&gt;  下标 &lt; sub&gt; **</p><p>x<sup>2</sup>  x<sub>2</sub></p></li><li><p><strong>代码块</strong></p><ul><li>&lt; code&gt;: 用于标记计算机通用代码。</li><li>&lt; pre&gt;: 用于保留空白字符（通常用于代码块）——如果您在文本中使用缩进或多余的空白，浏览器将忽略它，您将不会在呈现的页面上看到它。但是，如果您将文本包含在<code>&lt;pre&gt;&lt;/pre&gt;</code>标签中，那么空白将会以与你在文本编辑器中看到的相同的方式渲染出来。</li><li>&lt; kbd&gt;: 用于标记输入电脑的键盘（或其他类型）输入。</li><li>&lt; samp&gt;: 用于标记计算机程序的输出。</li></ul><p>请不要使用 <code>&lt;font&gt;</code> 、 <code>&lt;center&gt;</code> 等表象元素。</p><p>在上述的 JavaScript 示例中，<var>para</var> 表示一个段落元素。</p><p>按 <kbd>Ctrl</kbd>/<kbd>Cmd</kbd> + <kbd>A</kbd> 选择全部内容。</p><div class="code-wrapper"><pre>$ <kbd>ping mozilla.org</kbd><samp>PING mozilla.org (63.245.215.20): 56 data bytes64 bytes from 63.245.215.20: icmp_seq=0 ttl=40 time=158.233 ms</samp></pre></div></li><li><p><strong>时间和日期 &lt; time datetime&#x3D;””&gt;</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;time datetime=<span class="hljs-string">&quot;2016-01-20&quot;</span>&gt;</span><span class="hljs-attribute">2016</span>年<span class="hljs-number">1</span>月<span class="hljs-number">20</span>日&lt;/time&gt;<br></code></pre></td></tr></table></figure><p><time datetime="2016-01-20">2016年1月20日</time></p></li></ol><h3 id="六、网页架构"><a href="#六、网页架构" class="headerlink" title="六、网页架构"></a>六、网页架构</h3><p>一般都网页布局包含了以下5个部分</p><p><strong>导航栏</strong>，指向各个子页面的链接，以及网站标题，导航栏应该始终保持一致</p><p><strong>页眉</strong>，通常横跨于页面顶部的大标题、大图、大标志，是网站的主要信息</p><p><strong>主内容</strong>，位于页面的中心部分，放置重要的内容</p><p><strong>侧边栏</strong>，一些少量的信息，如介绍、子导航、引用等</p><p><strong>页脚</strong>，横跨页面底部的狭长区域，一般放置一些公共信息，如版权声明、联系方式。有一些网站也习惯将链接导航放置到页脚</p><p>对应的，HTML提供了相关的语义标签</p><p><strong>&lt; nav&gt; 导航栏</strong>，其中不应包含二级链接等内容</p><p><strong>&lt; header&gt; 页眉</strong></p><p><strong>&lt; main&gt; 主内容</strong>，每个页面上只能用一次 <code>&lt;main&gt;</code>，且直接位于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/body">&#96;&#96;</a> 中。最好不要把它嵌套进其它元素</p><p><strong>&lt; aside&gt; 侧边栏</strong></p><p><strong>&lt; footer&gt; 页脚</strong></p><p>还有其它一些<strong>常用的语义标签</strong></p><p><strong>&lt; article&gt; ，</strong>包围的内容即一篇文章，与页面其它部分无关（比如一篇博文）</p><p><strong>&lt; section&gt; ，</strong>适用于组织页面使其按功能（比如迷你地图、一组文章标题和摘要）分块</p><p>一般的<strong>最佳用法</strong>是：以 <a href="https://developer.mozilla.org/en-US/Learn/HTML/Howto/Set_up_a_proper_title_hierarchy">标题</a> 作为开头；把一篇 <code>&lt;article&gt;</code> 分成若干部分并分别置于不同的 <code>&lt;section&gt;</code> 中</p><p><strong>无语义标签</strong></p><p><strong>&lt; div&gt; ，</strong>一般用于没有特殊语义，或者找不到想要的语义标签，但是又要实现特殊的CSS样式或JS脚本</p><p><strong>&lt; span&gt; ，</strong>内联的（inline）无语义元素，最好用于没有特定语义的情况</p><p><strong>换行和水平分割线</strong></p><p><strong>&lt; br&gt;，换行</strong></p><p><strong>&lt; hr&gt;，水平分割线</strong></p><h3 id="七、验证错误"><a href="#七、验证错误" class="headerlink" title="七、验证错误"></a>七、验证错误</h3><p>验证服务网站 <a href="https://validator.w3.org/">Markup Validation Service</a>，由W3C组织提供的标记验证服务</p><h3 id="八、图片"><a href="#八、图片" class="headerlink" title="八、图片"></a>八、图片</h3><p><code>&lt; img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot;&gt;</code></p><ul><li>src，图片的路径</li><li>alt，图片加载失败时显示的文本</li><li>title，鼠标悬停在图片上时显示的文本</li></ul><p>HTML5，有两个个专门的语义元素**&lt; figure&gt; 和&lt; figcaption&gt;**用来放置图片和对应的文字，结构为</p><ul><li>&lt; figure&gt; <ul><li>&lt; img&gt;</li><li>&lt; figcaption&gt;</li></ul></li></ul><p>样式并没有什么不同，但是便于人和机器读懂html文档。</p><p>CSS也可以通过backgorund-image属性来添加图片，但那并没有语义意义。</p><h3 id="九、音视频"><a href="#九、音视频" class="headerlink" title="九、音视频"></a>九、音视频</h3><h4 id="video元素"><a href="#video元素" class="headerlink" title="video元素"></a>video元素</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;rabbit320.webm&quot;</span> <span class="hljs-attr">controls</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>你的浏览器不支持 HTML5 视频。可点击<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;rabbit320.mp4&quot;</span>&gt;</span>此链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>观看<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>src，视频路径</li><li>controls，使用controls来包含浏览器提供的控件界面，布尔属性</li><li>后备内容，开始和结束标签之间的内容，当浏览器不支持video时就会显示出来</li></ul><br><p><strong>另外一种写法，为了提供多个视频源</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">controls</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;rabbit320.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;rabbit320.webm&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/webm&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>你的浏览器不支持 HTML5 视频。可点击<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;rabbit320.mp4&quot;</span>&gt;</span>此链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>观看<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><p>video标签会自动从source标签中寻找想匹配的媒体，type属性是有用的，浏览器会优先检查type，寻找匹配的媒体，否则需要一个个尝试加载，这会浪费大量时间。</p><br><p><strong>H5提供的新属性</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;video controls width<span class="hljs-operator">=</span><span class="hljs-string">&quot;400&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;400&quot;</span> autoplay loop muted poster<span class="hljs-operator">=</span><span class="hljs-string">&quot;poster.png&quot;</span>&gt; &lt;/video&gt;<br></code></pre></td></tr></table></figure><ul><li>width，hegiht控制尺寸，不会改变长宽比，多余空白填充</li><li>autoplay，自动播放</li><li>loop，循环播放</li><li>muted，默认静音</li><li>poster，视频播放前显示的图片</li></ul><h4 id="audio元素"><a href="#audio元素" class="headerlink" title="audio元素"></a>audio元素</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">controls</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;viper.mp3&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/mp3&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;viper.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/ogg&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>你的浏览器不支持 HTML5 音频，可点击<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;viper.mp3&quot;</span>&gt;</span>此链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>收听。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><p>不支持width，height，poster等视觉属性</p><br><p><strong>H5支持了显示音轨文本</strong></p><p>有了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebVTT_API">WebVTT</a> 格式，你可以使用 <strong>track标签</strong></p><p>WebVTT 是一个格式，用来编写文本文件，这个文本文件包含了众多的字符串，这些字符串会带有一些元数据，它们可以用来描述这个字符串将会在<strong>视频中显示的时间</strong>，甚至可以用来描述这些<strong>字符串的样式以及定位信息</strong>。这些字符串叫做 <strong>cues</strong> 。</p><p>一个典型的 WebVTT 文件如下：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">WEBVTT<br><br><span class="hljs-number">1</span><br><span class="hljs-number">00:00:22.230</span> --&gt; <span class="hljs-number">00</span>:<span class="hljs-number">00:24.606</span><br>第一段字幕<br></code></pre></td></tr></table></figure><p><strong>使用方式：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;video controls&gt;<br>    &lt;source src<span class="hljs-operator">=</span><span class="hljs-string">&quot;example.mp4&quot;</span> type<span class="hljs-operator">=</span><span class="hljs-string">&quot;video/mp4&quot;</span>&gt;<br>    &lt;source src<span class="hljs-operator">=</span><span class="hljs-string">&quot;example.webm&quot;</span> type<span class="hljs-operator">=</span><span class="hljs-string">&quot;video/webm&quot;</span>&gt;<br>    &lt;track kind<span class="hljs-operator">=</span><span class="hljs-string">&quot;subtitles&quot;</span> src<span class="hljs-operator">=</span><span class="hljs-string">&quot;subtitles_en.vtt&quot;</span> srclang<span class="hljs-operator">=</span><span class="hljs-string">&quot;en&quot;</span>&gt;<br>&lt;/video&gt;<br></code></pre></td></tr></table></figure><ul><li>kind，指明类型</li><li>src，链接文件</li><li>srclang，说明.vtt文件的编写语言</li></ul><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>subtitles</td><td>通过添加翻译字幕，来帮助那些听不懂外国语言的人们理解音频当中的内容</td></tr><tr><td>captions</td><td>同步翻译对白，或是描述一些有重要信息的声音，来帮助那些不能听音频的人们理解音频中的内容</td></tr><tr><td>timed descriptions</td><td>将文字转换为音频，用于服务那些有视觉障碍的人</td></tr></tbody></table><p>参考链接：<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery/Adding_captions_and_subtitles_to_HTML5_video">Adding captions and subtitles to HTML5 video</a></p><h3 id="十、SVG"><a href="#十、SVG" class="headerlink" title="十、SVG"></a>十、SVG</h3><p><strong>svg是什么</strong></p><p>用于描述矢量图像的<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/XML">XML</a>语言</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.1&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">baseProfile</span>=<span class="hljs-string">&quot;full&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;black&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;150&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;90&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;blue&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>优缺点</strong></p><p>优点：矢量图，放大不变形；可以通过CSS和JS编写样式</p><p>缺点：复杂图像很大；更难创建；旧版浏览器不支持</p><p><strong>跨浏览器支持SVG</strong></p><p>方式一：使用img标签，src引用png文件，srcset引用svg文件，这样会优先加载svg文件，不支持的浏览器会加载png文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;equilateral.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;triangle with equal sides&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;equilateral.svg&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>方式二：作为CSS背景图像，如下代码，新浏览器会加载svg，旧浏览器会加载png</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">background: url(&quot;fallback.png&quot;) no-repeat center;<br>background-image: url(&quot;image.svg&quot;);<br>background-size: contain;<br></code></pre></td></tr></table></figure><p>方式三：html内联svg，将svg代码放置在svg开始结束标签内。优点：减少qequest请求，提高加载速度；可以使用CSS修改样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;green&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="十一、响应式图片"><a href="#十一、响应式图片" class="headerlink" title="十一、响应式图片"></a>十一、响应式图片</h3><p><strong>分辨率切换问题：</strong>使用相同显示效果但不同分辨率的图片来适配不同尺寸大小的设备</p><p><strong>美术设计问题：</strong>使用不同的图片来适应不同的空间分布</p><p><strong>一个响应式设计的实例：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;elva-fairy-320w.jpg 320w,</span></span><br><span class="hljs-string"><span class="hljs-tag">             elva-fairy-480w.jpg 480w,</span></span><br><span class="hljs-string"><span class="hljs-tag">             elva-fairy-800w.jpg 800w&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">sizes</span>=<span class="hljs-string">&quot;(max-width: 320px) 280px,</span></span><br><span class="hljs-string"><span class="hljs-tag">            (max-width: 480px) 440px,</span></span><br><span class="hljs-string"><span class="hljs-tag">            800px&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;elva-fairy-800w.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Elva dressed as a fairy&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>**srcset ** 定义了浏览器选择的图像集，以及图像大小。w代表真实像素单位</li><li><strong>sizes</strong>  定义了媒体查询，括号内是媒体查询条件，括号外是填充的槽宽度。最后一个没有条件，没有一个为true时它会生效</li><li>浏览器所做的工作：<ul><li>查看设备宽度</li><li>从前往后检查sizes属性，直到第一个true条件，获得槽宽度</li><li>加载srcset中最接近槽宽度的图像</li></ul></li></ul><p><strong>分辨率切换的实例</strong>：srcset和x语法结合</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;elva-fairy-320w.jpg,</span></span><br><span class="hljs-string"><span class="hljs-tag">             elva-fairy-480w.jpg 1.5x,</span></span><br><span class="hljs-string"><span class="hljs-tag">             elva-fairy-640w.jpg 2x&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;elva-fairy-640w.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Elva dressed as a fairy&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">img &#123;<br>  width: 320px;<br>&#125;<br></code></pre></td></tr></table></figure><p>宽度固定在320px，如果页面是低分辨率显示，一个设备像素表示一个CSS像素，320w的图像被加载。如果高分辨率显示，2个设备像素表示一个CSS像素，那640w的图像被加载。实现同尺寸，不同分辨率</p><p><strong>美术设计的实例：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(max-width: 799px)&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;elva-480w-close-portrait.jpg&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(min-width: 800px)&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;elva-800w.jpg&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;elva-800w.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Chris standing up holding his daughter Elva&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在任何情况下，你都必须在 <code>&lt;/picture&gt;</code>之前正确提供一个<code>&lt;img&gt;</code>元素以及它的<code>src</code>和<code>alt</code>属性，否则不会有图片显示</p><p><strong>实践发现：</strong>如果不限制img标签（不是picture标签）的大小，图片将按照实际尺寸显示，这将使网页大小变得不可控。</p><h3 id="十二、表格"><a href="#十二、表格" class="headerlink" title="十二、表格"></a>十二、表格</h3><p><strong>定义表格</strong></p><ul><li>table 表格<ul><li>tr 行<ul><li>td 单元格内容  </li><li>th 标题所在的单元格</li></ul></li></ul></li></ul><p><strong>跨行或跨列</strong></p><p>在th属性里加上<code>rowspan=&quot;x&quot; colspan=&quot;x&quot;</code></p><p><strong>为整行&#x2F;整列应用属性样式 colgroup  rowgroup</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">colgroup</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">col</span>&gt;</span> 为第一列设置样式，即使不设置也不能省略，如果想省略需要加span属性，如下<br>    <span class="hljs-tag">&lt;<span class="hljs-name">col</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span>为第二列设置样式<br><span class="hljs-tag">&lt;/<span class="hljs-name">colgroup</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">colgroup</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">col</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-attr">span</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">colgroup</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>添加表格标题</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>表格标题<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>更严谨的表格结构</strong></p><p><code>thead 、 tfoot 、 tbody结构</code></p><p>好处：结构化更容易控制</p><p>三者的顺序没有硬性要求，但是需要放在colgroup下面（如果有的话）。实际上tbody即使不声明也会隐式出现（自动添加）</p><table>    <caption>How I chose to spend my money</caption>    <thead>        <tr>            <th>Purchase</th>            <th>Location</th>            <th>Date</th>            <th>Cost</th>        </tr>    </thead>    <tbody>        <tr>            <td>Haircut</td>            <td>Hairdresser</td>            <td>12/09</td>            <td>30</td>        </tr>        <tr>            <td>Shoes</td>            <td>Shoeshop</td>            <td>13/09</td>            <td>65</td>        </tr>    </tbody>    <tfoot>        <tr>            <td colspan="3">SUM</td>            <td>95</td>        </tr>    </tfoot></table><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>How I chose to spend my money<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Purchase<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Location<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Date<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Cost<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Haircut<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Hairdresser<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>12/09<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Shoes<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Shoeshop<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>13/09<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>65<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tfoot</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>SUM<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>95<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tfoot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发——Web开发概述</title>
    <link href="/2022/04/02/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/04/02/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94Web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>了解Web开发相关知识的意义在于</p><span id="more"></span><h2 id="Web开发概述"><a href="#Web开发概述" class="headerlink" title="Web开发概述"></a>Web开发概述</h2><p>了解Web开发相关知识的意义在于，Web拥有一套标准，“<strong>Web 标准</strong>是我们用来建立 Web 网站的技术。这些标准存在于名为规范的较长的技术文档中，该文档详细说明了技术应如何工作“。它规定了web如何工作，这对于从底层去理解、提升web应用的性能具有关键作用。</p><p>而且标准是不断更新的，所以意味着该行业的从业人员也需要时刻保持学习，以适应最新的标准。</p><h4 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h4><ul><li>可用于运行测试以显示您的代码是否按预期运行的 <a href="https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing">测试工具（ Testing tools ）</a>，<strong>跨浏览器测试</strong></li><li>现代浏览器中的 <a href="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_are_browser_developer_tools">开发人员工具（ developer tools ）</a>可用于<strong>调试代码</strong></li><li>所谓的 “ Linters” ，它包含了一组规则，检查您的代码之后，会突出显示您未正确遵循规则的地方</li><li>Minifiers ，它将代码文件中的所有空格删除以使其更小，从而可以更快地从服务器下载</li></ul><h4 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h4><p>前端语言：HTML ， CSS 和 JavaScript</p><p>后端语言，或者叫服务器端语言：ASP.NET ， Python ， PHP 和 NodeJS </p><h4 id="考虑的问题"><a href="#考虑的问题" class="headerlink" title="考虑的问题"></a>考虑的问题</h4><p><strong>跨浏览器兼容性（ Cross-browser compatibility ）</strong>，确保能在尽可能多，包括老旧的设备浏览器上运行</p><p><strong>响应式网页设计（ Responsive Web design ）</strong>，确保能在不同尺寸的浏览器界面中都有良好的浏览体验</p><p><strong>性能（ Performance ）</strong>，尽可能快加载网站，简单易用</p><p><strong>可访问性（ Accessibility ）</strong></p><p><strong>隐私与安全（ Privacy &amp; Security ）</strong>，隐私是指允许人们私下从事其业务，而不是监视他们或收集您绝对不需要的更多数据。安全性是指以安全的方式构建您的网站，以使恶意用户无法从您或您的用户那里窃取信息。</p><h4 id="Web是如何工作的"><a href="#Web是如何工作的" class="headerlink" title="Web是如何工作的"></a>Web是如何工作的</h4><p><strong>第一步</strong>，浏览器输入一个网址，向服务器端发送request，请求拷贝一份网页</p><p><strong>第二步</strong>，服务器端收到请求后，返回一个同意信息，接着把网页文件以数据包的形式发送给浏览器</p><p><strong>第三步</strong>，浏览器解析网页文件。<strong>首先</strong>，从HTML文件中识别出所有”link”和”script”，获取外部文件的链接，一边继续解析HTML文件，一边根据外部文件链接向服务器发送请求，获取再解析CSS和JavaSript文件；<strong>接着</strong>，给解析后的HTML生成一个<strong>DOM树</strong>，给CSS<strong>生成一个CSSOM树</strong>保存在内存中，编译执行解析度JavaScript文件；<strong>最后</strong>，网页界面展示出来。</p><h4 id="网站架构"><a href="#网站架构" class="headerlink" title="网站架构"></a>网站架构</h4><p>也称<strong>信息架构</strong>，规划整个网站内容，需要哪些页面、如何排列组合这些页面、如何互相进行链接</p><p><strong>第一步</strong>，头脑风暴所有需要实现的内容</p><p><strong>第二步</strong>，将所有内容分组罗列出来</p><p><strong>第三步</strong>，绘制站点草图，使用框框作为页面，连线表示页面之间的链接，有点像<strong>UML</strong></p><p><strong>第四步</strong>，确定所有页面的通用部分，一般为导航栏、页脚</p><p><strong>第五步</strong>，绘制网页布局草图</p><h4 id="http完整请求过程"><a href="#http完整请求过程" class="headerlink" title="http完整请求过程"></a>http完整请求过程</h4><p>客户端浏览器一次完整的http请求过程</p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/1620.jpeg" alt="img"></p><ol><li>DNS解析域名得到IP地址</li><li>TCP三次握手（客户端与服务器建立连接）</li><li>客户端发起请求</li><li>服务器根据收到的请求端口号、路径，找到对应的资源文件，发送给客户端</li><li>客户端收到数据，解析页面和请求相关资源</li><li>客户端渲染页面</li><li>服务器断开连接（四次挥手）</li></ol><p>下面是部分详细介绍</p><p><strong>浏览器渲染过程</strong></p><ul><li><p><strong>根据HTML解析出DOM树【遇到<code>&lt;img&gt;</code>标签加载图片】</strong></p><p>解析顺序为从上往下、深度优先遍历；如果遇到link标签，会同时异步请求对应的资源文件；如果遇到script标签，会阻塞解析过程，直到js脚本执行完毕，而CSS文件影响JS代码的执行（不影响JS文件的加载），所以JS代码执行前，必须保证CSS文件已经加载完毕。</p><p>所以script通常放在HTML的末尾声明，但是如果HTML中包含了大量的JS文件代码，而且这些代码不直接影响页面（比如提供交互事件），那么可以将script标签放到前面，并用<code>async</code>或<code>defer</code>关键字声明（详细用法可参见《前端开发——JS（一）》）</p></li><li><p><strong>根据CSS解析出CSS规则树【遇到背景图片链接不加载】</strong></p><p>解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪</p><p>精简CSS可以加快CSS规则树的构建，从而加快页面响应速度</p></li><li><p><strong>结合DOM树和CSS规则树，生成渲染树【遍历DOM树时加载对应样式规则上的背景图片】</strong></p></li><li><p><strong>根据渲染树计算每个节点的信息，根据节点信息绘制页面</strong></p><p><strong>布局</strong>：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</p><p><strong>回流</strong>：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染</p><p>根据计算好的信息绘制页面</p><p><strong>重绘 &amp; 回流</strong></p><p>重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘</p><p>回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo常用命令</title>
    <link href="/2022/03/12/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/03/12/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>Hexo常用命令</p><span id="more"></span><h3 id="一、写作"><a href="#一、写作" class="headerlink" title="一、写作"></a>一、写作</h3><ol><li><p><strong>新建空白文档</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs xml">hexo n [layout] <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>layout分为：post、page、draft，默认为post</strong></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p><strong>用法实例：</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">post</span> --path 前端开发/前端开发——Web开发基础 <span class="hljs-string">&quot;前端开发——Web开发概述&quot;</span><br>如果没有最后<span class="hljs-string">&quot;&quot;</span>里面的标题，只会创建文件名为“前端开发——Web开发基础”的文件，title为模板默认值。如果指定的文件目录不存在，则会新建文件目录<br></code></pre></td></tr></table></figure></li><li><p><strong>Front-matter</strong></p><table><thead><tr><th>参数</th><th>描述</th><th>用法</th></tr></thead><tbody><tr><td>title</td><td>文章标题、文件名</td><td></td></tr><tr><td>tags</td><td>标签</td><td>tags: - PS3 - Games</td></tr><tr><td>categories</td><td>分类</td><td>categories: - Diary</td></tr><tr><td>index_img</td><td>首页的缩略图</td><td>index_img: &#x2F;img&#x2F;yangtai&#x2F;p1.jpg</td></tr><tr><td>banner_img</td><td>详细页的顶部背景大图</td><td>banner_img: &#x2F;img&#x2F;yangtai&#x2F;p2.jpg</td></tr><tr><td>comments</td><td>开关文章的评论功能</td><td>comments: true（默认） &#x2F; false</td></tr></tbody></table></li></ol><h3 id="二、发布"><a href="#二、发布" class="headerlink" title="二、发布"></a>二、发布</h3><ol><li><p>生成静态文件</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br></code></pre></td></tr></table></figure></li><li><p>本地预览</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">hexo s  启动服务器。默认情况下，访问网址为： http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">4000</span>/<br></code></pre></td></tr></table></figure></li><li><p>部署网站</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="三、自定义"><a href="#三、自定义" class="headerlink" title="三、自定义"></a>三、自定义</h3><h4 id="自定义模板"><a href="#自定义模板" class="headerlink" title="自定义模板"></a>自定义模板</h4><p>在hexo的<code>scaffolds</code>目录下有三个<code>md</code>文档，按需修改模板即可</p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220312210202990.png" alt="image-20220312210202990" style="zoom:50%;" /><h4 id="自定义默认背景图片"><a href="#自定义默认背景图片" class="headerlink" title="自定义默认背景图片"></a>自定义默认背景图片</h4><p>修改主题配置_config.fluid中的post.banner_img</p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220312212321936.png" alt="image-20220312212321936" style="zoom:50%;" /><h3 id="四、资源文件夹"><a href="#四、资源文件夹" class="headerlink" title="四、资源文件夹"></a>四、资源文件夹</h3><p>资源，指除了文章文本之外的所有文件，诸如：图片（包括文章里的配图）、CSS、JS文件等。</p><p>如果这些资源存放在本地，那么只能在本地服务器上正常浏览使用它们，通过网站浏览时将无法加载。</p><p>针对图片的一种做法是，设置Toypra等markdown编辑器的 <strong>图片上传</strong>功能，接着类似于github提供的<strong>图床</strong>服务，使网站上的在线文档能够正常加载图片。</p><p>另外一种，也就是这里推荐的做法是，使用Hexo的 <strong>相对路径引用的标签插件</strong>。介绍如下：</p><p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的<a href="https://hexo.io/docs/tag-plugins#Include-Assets">标签插件</a>被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">asset_path</span> slug %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">asset_img</span> slug [title] %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">asset_link</span> slug [title] %&#125;</span><br></code></pre></td></tr></table></figure><p>正确的引用图片方式是使用下列的标签插件而不是 markdown ：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">&#123;<span class="hljs-symbol">%</span> asset_img <span class="hljs-built_in">example</span>.jpg This <span class="hljs-built_in">is</span> an <span class="hljs-built_in">example</span> <span class="hljs-built_in">image</span> <span class="hljs-symbol">%</span>&#125;<br></code></pre></td></tr></table></figure><p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p><p>使用这个<strong>便签插件</strong>，首先要调整config.yml的设置，将post_asset_folder设置为true，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>之后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。<strong>这个资源文件夹将会有与这个文章文件一样的名字</strong>。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们</p><p><strong>重点！！实际尝试发现，这种方式体验很差，因为使用标签插件的时候Typora就无法预览到图片</strong></p><p>所以还是放弃这种方式，改为使用github图床吧，这样虽然加载慢一点，但是起码三个地方都可以访问到</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云发布网页Apache</title>
    <link href="/2022/03/12/%E9%98%BF%E9%87%8C%E4%BA%91%E5%8F%91%E5%B8%83%E7%BD%91%E9%A1%B5Apache/"/>
    <url>/2022/03/12/%E9%98%BF%E9%87%8C%E4%BA%91%E5%8F%91%E5%B8%83%E7%BD%91%E9%A1%B5Apache/</url>
    
    <content type="html"><![CDATA[<p>通过apache在阿里云服务器上发布本地制作的网页</p><span id="more"></span><ul><li>服务器：阿里云轻量化云服务器</li><li>系统：CentOS 7</li></ul><h3 id="一、安装Apache"><a href="#一、安装Apache" class="headerlink" title="一、安装Apache"></a>一、安装Apache</h3><h4 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h4><ol><li><p>安装apache</p><p>yum install httpd</p></li><li><p>设置服务器开机自动启动Apache</p><p>systemctl enable httpd.service</p></li><li><p>手动启动Apache</p><p>systemctl start httpd.service</p><p>扩展命令</p><p>手动停止Apache  systemctl stop httpd.service<br>手动重启Apache  systemctl restart httpd.service</p></li><li><p>测试Apache启动结果</p><p>systemctl is-enabled httpd.service<br>如果结果为enable，则启动成功</p><p>也可以在浏览器输入ip地址进行访问，如果安装成功，将会出现apache的首页</p></li></ol><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul><li>apache2 默认的几个配置文件：（<strong>apache2在CentOS 7中叫做httpd</strong>）</li></ul><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</td><td>主要配置文件(这个文件的末尾可以看到，include了其它所有的配置文件)</td></tr><tr><td>&#x2F;etc&#x2F;conf.d&#x2F;<br />conf.modules.d</td><td>其它配置文件</td></tr></tbody></table><ul><li><strong>默认web目录：&#x2F;var&#x2F;www&#x2F;html</strong>，</li><li><strong>设置默认主页的配置文件：&#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;welcome.conf</strong></li></ul><h3 id="二、访问测试"><a href="#二、访问测试" class="headerlink" title="二、访问测试"></a>二、访问测试</h3><p>浏览器访问 localhost:80</p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220312174122367.png" alt="image-20220312174122367"></p><h3 id="三、上传网页"><a href="#三、上传网页" class="headerlink" title="三、上传网页"></a>三、上传网页</h3><p>Apache安装成功之后，在&#x2F;var下面会多出一个.&#x2F;www文件夹，使用XFtp将html文件和所需的css、js、以及其它资源文件夹一并上传到&#x2F;var&#x2F;www&#x2F;html 文件夹下即可</p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220312200709944.png" alt="image-20220312200709944"></p><p>上传完成后，在浏览器中输入ip地址即可访问上传的网页</p><p><img src="https://raw.githubusercontent.com/Qiuzcc/images/master/imgs/image-20220312200921295.png" alt="image-20220312200921295"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搭建网站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阳台改造方案</title>
    <link href="/2022/02/28/%E9%98%B3%E5%8F%B0%E6%94%B9%E9%80%A0%E6%96%B9%E6%A1%88/"/>
    <url>/2022/02/28/%E9%98%B3%E5%8F%B0%E6%94%B9%E9%80%A0%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h3 id="一、改造目的"><a href="#一、改造目的" class="headerlink" title="一、改造目的"></a>一、改造目的</h3><p>利用闲置的阳台一角，搭建一个简易的家庭图书角</p><h3 id="二、改造内容"><a href="#二、改造内容" class="headerlink" title="二、改造内容"></a>二、改造内容</h3><ul><li>翻新墙面</li><li>增加物品<ol><li>书架+射灯</li><li>落地台灯</li><li>单人沙发</li><li>小茶几</li><li>氛围灯带</li><li>地毯</li></ol></li></ul><h3 id="三、配色方案"><a href="#三、配色方案" class="headerlink" title="三、配色方案"></a>三、配色方案</h3><ul><li>基础色</li><li>主配色</li><li>点缀色</li></ul><table><thead><tr><th>物品</th><th>色调</th></tr></thead><tbody><tr><td>墙面</td><td>浅蓝+花白 &#x2F; 少白</td></tr><tr><td>书架</td><td>原木色</td></tr><tr><td>茶几</td><td>白色+实木色</td></tr><tr><td>沙发榻榻米</td><td>玉米黄</td></tr><tr><td>地毯(PUD材料)</td><td>橙黄色调</td></tr><tr><td>落地台灯</td><td>白色</td></tr><tr><td>氛围灯带（灯光）</td><td>暖白色</td></tr></tbody></table><h3 id="四、成本计算"><a href="#四、成本计算" class="headerlink" title="四、成本计算"></a>四、成本计算</h3><table><thead><tr><th>物品</th><th>成本</th></tr></thead><tbody><tr><td>北欧简约书架</td><td>166</td></tr><tr><td>简约茶几（双层）</td><td>54</td></tr><tr><td>三棵树内墙乳胶漆</td><td>146</td></tr><tr><td>落地台灯</td><td>141</td></tr><tr><td>沙发椅</td><td>273</td></tr><tr><td>氛围灯带+射灯</td><td>82</td></tr><tr><td>地毯</td><td>149</td></tr><tr><td></td><td></td></tr><tr><td>滚筒刷（3把）+延长杆</td><td>26</td></tr><tr><td>插座</td><td>36</td></tr><tr><td>走线卡扣</td><td>7</td></tr></tbody></table><ul><li>材料总成本：1080</li></ul><h3 id="感想："><a href="#感想：" class="headerlink" title="感想："></a>感想：</h3><p>​ 临近过年回家前，突然起了一个改造阳台的想法。边复习边做计划，在网上购买装修物品，回家之后马上开始动手，刷墙、接线、搭书架、铺地毯，连续干了两天多，一步一步把脑海中的想法实现出来，利用原来闲置的阳台一角，搭出了一个简易的图书角。明亮的灯光、整洁的墙面地面，营造出了一种温馨的环境氛围。 ——2022年2月1日</p>]]></content>
    
    
    <categories>
      
      <category>日常文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
